diff -Naru5 clFFT.old/src/client/client.cpp clFFT/src/client/client.cpp
--- clFFT.old/src/client/client.cpp	2020-11-04 16:35:17.422391075 +0000
+++ clFFT/src/client/client.cpp	2020-11-04 16:48:27.206337650 +0000
@@ -43,10 +43,11 @@
 }
 
 
 template < typename T >
 int transform( size_t* lengths, const size_t *inStrides, const size_t *outStrides, size_t batch_size,
+				size_t offsetIn, size_t offsetOut,
 				clfftLayout in_layout, clfftLayout out_layout,
 				clfftResultLocation place, clfftPrecision precision, clfftDirection dir,
 				cl_device_type deviceType, cl_int deviceId, cl_int platformId, bool printInfo,
 				cl_uint command_queue_flags, cl_uint profile_count,
 				std::auto_ptr< clfftSetupData > setupData )
@@ -64,10 +65,11 @@
 	size_t outfftVectorSize = 0;
 	size_t outfftVectorSizePadded = 0;
 	size_t outfftBatchSize = 0;
 	size_t size_of_input_buffers_in_bytes = 0;
 	size_t size_of_output_buffers_in_bytes = 0;
+
 	cl_uint number_of_output_buffers = 0;
 	clfftDim	dim = CLFFT_1D;
 	cl_mem input_cl_mem_buffers [2] = { NULL, NULL };
 	cl_mem output_cl_mem_buffers[2] = { NULL, NULL };
 	std::vector< cl_device_id > device_id;
@@ -137,49 +139,49 @@
 
 	switch( out_layout )
 	{
 	case CLFFT_COMPLEX_INTERLEAVED:
 		number_of_output_buffers = 1;
-		size_of_output_buffers_in_bytes = outfftBatchSize * sizeof( std::complex< T > );
+		size_of_output_buffers_in_bytes = ( outfftBatchSize + offsetOut ) * sizeof( std::complex< T > );
 		break;
 	case CLFFT_COMPLEX_PLANAR:
 		number_of_output_buffers = 2;
-		size_of_output_buffers_in_bytes = outfftBatchSize * sizeof(T);
+		size_of_output_buffers_in_bytes = ( outfftBatchSize + offsetOut ) * sizeof(T);
 		break;
 	case CLFFT_HERMITIAN_INTERLEAVED:
 		number_of_output_buffers = 1;
-		size_of_output_buffers_in_bytes = outfftBatchSize * sizeof( std::complex< T > );
+		size_of_output_buffers_in_bytes = ( outfftBatchSize + offsetOut ) * sizeof( std::complex< T > );
 		break;
 	case CLFFT_HERMITIAN_PLANAR:
 		number_of_output_buffers = 2;
-		size_of_output_buffers_in_bytes = outfftBatchSize * sizeof(T);
+		size_of_output_buffers_in_bytes = ( outfftBatchSize + offsetOut ) * sizeof(T);
 		break;
 	case CLFFT_REAL:
 		number_of_output_buffers = 1;
-		size_of_output_buffers_in_bytes = outfftBatchSize * sizeof(T);
+		size_of_output_buffers_in_bytes = ( outfftBatchSize + offsetOut ) * sizeof(T);
 		break;
 	}
 
 	// Fill the input buffers
 	switch( in_layout )
 	{
 	case CLFFT_COMPLEX_INTERLEAVED:
 		{
 			//	This call creates our openCL context and sets up our devices; expected to throw on error
-			size_of_input_buffers_in_bytes = fftBatchSize * sizeof( std::complex< T > );
+			size_of_input_buffers_in_bytes = ( fftBatchSize + offsetIn ) * sizeof( std::complex< T > );
 
 			device_id = initializeCL( deviceType, deviceId, platformId, context, printInfo );
 			createOpenCLCommandQueue( context,
 				command_queue_flags, queue,
 				device_id,
 				size_of_input_buffers_in_bytes, 1, input_cl_mem_buffers,
 				size_of_output_buffers_in_bytes, number_of_output_buffers, output_cl_mem_buffers);
 
-			std::vector< std::complex< T > > input( fftBatchSize );
+			std::vector< std::complex< T > > input( fftBatchSize + offsetIn );
 
 			// set zero
-			for( cl_uint i = 0; i < fftBatchSize; ++i )
+			for( cl_uint i = 0; i < ( fftBatchSize + offsetIn ); ++i )
 			{
 				input[ i ] = 0;
 			}
 
 			// impulse test case
@@ -209,24 +211,24 @@
 		}
 		break;
 	case CLFFT_COMPLEX_PLANAR:
 		{
 			//	This call creates our openCL context and sets up our devices; expected to throw on error
-			size_of_input_buffers_in_bytes = fftBatchSize * sizeof( T );
+			size_of_input_buffers_in_bytes = ( fftBatchSize + offsetIn ) * sizeof( T );
 
 			device_id = initializeCL( deviceType, deviceId, platformId, context, printInfo );
 			createOpenCLCommandQueue( context,
 				command_queue_flags, queue,
 				device_id,
 				size_of_input_buffers_in_bytes, 2, input_cl_mem_buffers,
 				size_of_output_buffers_in_bytes, number_of_output_buffers, output_cl_mem_buffers);
 
-			std::vector< T > real( fftBatchSize );
-			std::vector< T > imag( fftBatchSize );
+			std::vector< T > real( fftBatchSize + offsetIn );
+			std::vector< T > imag( fftBatchSize + offsetIn );
 
 			// set zero
-			for( cl_uint i = 0; i < fftBatchSize; ++i )
+			for( cl_uint i = 0; i < (fftBatchSize + offsetIn ); ++i )
 			{
 				real[ i ] = 0;
 				imag[ i ] = 0;
 			}
 
@@ -259,23 +261,23 @@
 		}
 		break;
 	case CLFFT_HERMITIAN_INTERLEAVED:
 		{
 			//	This call creates our openCL context and sets up our devices; expected to throw on error
-			size_of_input_buffers_in_bytes = fftBatchSize * sizeof( std::complex< T > );
+			size_of_input_buffers_in_bytes = ( fftBatchSize + offsetIn ) * sizeof( std::complex< T > );
 
 			device_id = initializeCL( deviceType, deviceId, platformId, context, printInfo );
 			createOpenCLCommandQueue( context,
 				command_queue_flags, queue,
 				device_id,
 				size_of_input_buffers_in_bytes, 1, input_cl_mem_buffers,
 				size_of_output_buffers_in_bytes, number_of_output_buffers, output_cl_mem_buffers);
 
-			std::vector< std::complex< T > > input( fftBatchSize );
+			std::vector< std::complex< T > > input( fftBatchSize + offsetIn );
 
 			// set zero
-			for( cl_uint i = 0; i < fftBatchSize; ++i )
+			for( cl_uint i = 0; i < ( fftBatchSize + offsetIn ); ++i )
 			{
 				input[ i ] = 0;
 			}
 
 			// impulse test case
@@ -293,24 +295,24 @@
 		}
 		break;
 	case CLFFT_HERMITIAN_PLANAR:
 		{
 			//	This call creates our openCL context and sets up our devices; expected to throw on error
-			size_of_input_buffers_in_bytes = fftBatchSize * sizeof( T );
+			size_of_input_buffers_in_bytes = ( fftBatchSize + offsetIn ) * sizeof( T );
 
 			device_id = initializeCL( deviceType, deviceId, platformId, context, printInfo );
 			createOpenCLCommandQueue( context,
 				command_queue_flags, queue,
 				device_id,
 				size_of_input_buffers_in_bytes, 2, input_cl_mem_buffers,
 				size_of_output_buffers_in_bytes, number_of_output_buffers, output_cl_mem_buffers);
 
-			std::vector< T > real( fftBatchSize );
-			std::vector< T > imag( fftBatchSize );
+			std::vector< T > real( fftBatchSize + offsetIn );
+			std::vector< T > imag( fftBatchSize + offsetIn );
 
 			// set zero
-			for( cl_uint i = 0; i < fftBatchSize; ++i )
+			for( cl_uint i = 0; i < ( fftBatchSize + offsetIn ); ++i )
 			{
 				real[ i ] = 0;
 				imag[ i ] = 0;
 			}
 
@@ -332,23 +334,23 @@
 		}
 		break;
 	case CLFFT_REAL:
 		{
 			//	This call creates our openCL context and sets up our devices; expected to throw on error
-			size_of_input_buffers_in_bytes = fftBatchSize * sizeof( T );
+			size_of_input_buffers_in_bytes = ( fftBatchSize + offsetIn ) * sizeof( T );
 
 			device_id = initializeCL( deviceType, deviceId, platformId, context, printInfo );
 			createOpenCLCommandQueue( context,
 				command_queue_flags, queue,
 				device_id,
 				size_of_input_buffers_in_bytes, 1, input_cl_mem_buffers,
 				size_of_output_buffers_in_bytes, number_of_output_buffers, output_cl_mem_buffers);
 
-			std::vector< T > real( fftBatchSize );
+			std::vector< T > real( fftBatchSize + offsetIn );
 
 			// set zero
-			for( cl_uint i = 0; i < fftBatchSize; ++i )
+			for( cl_uint i = 0; i < ( fftBatchSize + offsetIn ); ++i )
 			{
 				real[ i ] = 0;
 			}
 
 			// impulse test case
@@ -406,10 +408,13 @@
 
 	OPENCL_V_THROW (clfftSetPlanInStride  ( plan_handle, dim, strides ), "clfftSetPlanInStride failed" );
 	OPENCL_V_THROW (clfftSetPlanOutStride ( plan_handle, dim, o_strides ), "clfftSetPlanOutStride failed" );
 	OPENCL_V_THROW (clfftSetPlanDistance  ( plan_handle, strides[ 3 ], o_strides[ 3 ]), "clfftSetPlanDistance failed" );
 
+	OPENCL_V_THROW (clfftSetPlanOffsetIn  ( plan_handle, offsetIn  ), "clfftSetPlanOffsetIn failed" );
+	OPENCL_V_THROW (clfftSetPlanOffsetOut ( plan_handle, offsetOut ), "clfftSetPlanOffsetOut failed" );
+
 	// Set backward scale factor to 1.0 for non real FFTs to do correct output checks
 	if(dir == CLFFT_BACKWARD && in_layout != CLFFT_REAL && out_layout != CLFFT_REAL)
 		OPENCL_V_THROW (clfftSetPlanScale( plan_handle, CLFFT_BACKWARD, (cl_float)1.0f ), "clfftSetPlanScale failed" );
 
 	OPENCL_V_THROW( clfftBakePlan( plan_handle, 1, &queue, NULL, NULL ), "clfftBakePlan failed" );
@@ -592,11 +597,11 @@
 		switch( out_layout )
 		{
 		case CLFFT_HERMITIAN_INTERLEAVED:
 		case CLFFT_COMPLEX_INTERLEAVED:
 			{
-				std::vector< std::complex< T > > output( outfftBatchSize );
+				std::vector< std::complex< T > > output( outfftBatchSize + offsetOut );
 
 				if( place == CLFFT_INPLACE )
 				{
 					OPENCL_V_THROW( clEnqueueReadBuffer( queue, input_cl_mem_buffers[ 0 ], CL_TRUE, 0, size_of_input_buffers_in_bytes, &output[ 0 ],
 						0, NULL, NULL ),
@@ -608,11 +613,11 @@
 						0, NULL, NULL ),
 						"Reading the result buffer failed" );
 				}
 
 				//check output data
-				for( cl_uint i = 0; i < outfftBatchSize; ++i )
+				for( cl_uint i = 0; i < ( outfftBatchSize + offsetOut ); ++i )
 				{
 					if (0 == (i % outfftVectorSizePadded))
 					{
 						if (output[i].real() != outfftVectorSize)
 						{
@@ -638,12 +643,12 @@
 			}
 			break;
 		case CLFFT_HERMITIAN_PLANAR:
 		case CLFFT_COMPLEX_PLANAR:
 			{
-				std::valarray< T > real( outfftBatchSize );
-				std::valarray< T > imag( outfftBatchSize );
+				std::valarray< T > real( outfftBatchSize + offsetOut );
+				std::valarray< T > imag( outfftBatchSize + offsetOut );
 
 				if( place == CLFFT_INPLACE )
 				{
 					OPENCL_V_THROW( clEnqueueReadBuffer( queue, input_cl_mem_buffers[ 0 ], CL_TRUE, 0, size_of_input_buffers_in_bytes, &real[ 0 ],
 						0, NULL, NULL ),
@@ -661,11 +666,11 @@
 						0, NULL, NULL ),
 						"Reading the result buffer failed" );
 				}
 
 				//  Check output data
-				for( cl_uint i = 0; i < outfftBatchSize; ++i )
+				for( cl_uint i = 0; i < ( outfftBatchSize + offsetOut ); ++i )
 				{
 					if (0 == (i % outfftVectorSizePadded))
 					{
 						if (real[i] != outfftVectorSize)
 						{
@@ -690,11 +695,11 @@
 				}
 			}
 			break;
 		case CLFFT_REAL:
 			{
-				std::valarray< T > real( outfftBatchSize );
+				std::valarray< T > real( outfftBatchSize + offsetOut );
 
 				if( place == CLFFT_INPLACE )
 				{
 					OPENCL_V_THROW( clEnqueueReadBuffer( queue, input_cl_mem_buffers[ 0 ], CL_TRUE, 0, size_of_input_buffers_in_bytes, &real[ 0 ],
 						0, NULL, NULL ),
@@ -812,11 +817,12 @@
 	size_t oStrides[ 4 ] = {0,0,0,0};
 	cl_uint profile_count = 0;
 
 	cl_uint command_queue_flags = 0;
 	size_t batchSize = 1;
-
+	size_t offsetIn  = 0;
+	size_t offsetOut = 0;
 
 	//	Initialize flags for FFT library
 	std::auto_ptr< clfftSetupData > setupData( new clfftSetupData );
 	OPENCL_V_THROW( clfftInitSetupData( setupData.get( ) ),
 		"clfftInitSetupData failed" );
@@ -852,10 +858,12 @@
 			( "oD", po::value< size_t >( &oStrides[ 3 ] )->default_value( 0 ), "output distance between subsequent sets of data when batch size > 1" )
 			( "batchSize,b",   po::value< size_t >( &batchSize )->default_value( 1 ), "If this value is greater than one, arrays will be used " )
 			( "profile,p",     po::value< cl_uint >( &profile_count )->default_value( 1 ), "Time and report the kernel speed of the FFT (default: profiling off)" )
 			( "inLayout",      po::value< clfftLayout >( &inLayout )->default_value( CLFFT_COMPLEX_INTERLEAVED ), "Layout of input data:\n1) interleaved\n2) planar\n3) hermitian interleaved\n4) hermitian planar\n5) real" )
 			( "outLayout",     po::value< clfftLayout >( &outLayout )->default_value( CLFFT_COMPLEX_INTERLEAVED ), "Layout of input data:\n1) interleaved\n2) planar\n3) hermitian interleaved\n4) hermitian planar\n5) real" )
+			( "offsetIn",   po::value< size_t >( &offsetIn )->default_value( 0 ), "Input  offset to be used in number of elements" )
+			( "offsetOut",  po::value< size_t >( &offsetOut)->default_value( 0 ), "Output offset to be used in number of elements" )
 			;
 
 		po::variables_map vm;
 		po::store( po::parse_command_line( argc, argv, desc ), vm );
 		po::notify( vm );
@@ -1026,13 +1034,13 @@
 			cst[2] = cst[2] ? cst[2] : lengths[1] * cst[1];
 			cst[3] = cst[3] ? cst[3] : lengths[2] * cst[2];
 		}
 
 		if( precision == CLFFT_SINGLE )
-			transform<float>( lengths, iStrides, oStrides, batchSize, inLayout, outLayout, place, precision, dir, deviceType, deviceId, platformId, printInfo, command_queue_flags, profile_count, setupData );
+			transform<float>(  lengths, iStrides, oStrides, batchSize, offsetIn, offsetOut, inLayout, outLayout, place, precision, dir, deviceType, deviceId, platformId, printInfo, command_queue_flags, profile_count, setupData );
 		else
-			transform<double>( lengths, iStrides, oStrides, batchSize, inLayout, outLayout, place, precision, dir, deviceType, deviceId, platformId, printInfo, command_queue_flags, profile_count, setupData );
+			transform<double>( lengths, iStrides, oStrides, batchSize, offsetIn, offsetOut, inLayout, outLayout, place, precision, dir, deviceType, deviceId, platformId, printInfo, command_queue_flags, profile_count, setupData );
 	}
 	catch( std::exception& e )
 	{
 		terr << _T( "clFFT error condition reported:" ) << std::endl << e.what() << std::endl;
 		return 1;
diff -Naru5 clFFT.old/src/include/clFFT.h clFFT/src/include/clFFT.h
--- clFFT.old/src/include/clFFT.h	2020-11-04 16:35:17.422391075 +0000
+++ clFFT/src/include/clFFT.h	2020-11-04 16:48:27.206337650 +0000
@@ -346,10 +346,42 @@
 	 *  @param[in] precision Reference to the user clfftPrecision enum
 	 *  @return Enum describing error condition; superset of OpenCL error codes
 	 */
 	CLFFTAPI clfftStatus	clfftSetPlanPrecision( clfftPlanHandle plHandle, clfftPrecision precision );
 
+	/*! @brief Set the offset in number of elements for the input array
+	 *  @details Sets the plan property which sets offset in number elements for the input array
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[in] offset size
+	 *  @return Enum describing error condition; superset of OpenCL error codes
+	 */
+	CLFFTAPI clfftStatus clfftSetPlanOffsetIn( clfftPlanHandle plHandle, size_t offsetIn );
+
+	/*! @brief Retrieve the offset  in number of elements for the input array
+	 *  @details Queries a plan object and retrieves the value of the offset  in number of elements for the input array
+	 *  @param[in]  plHandle Handle to a previously created plan
+	 *  @param[out] offset size
+	 *  @return Enum describing error condition; superset of OpenCL error codes
+	 */
+	CLFFTAPI clfftStatus clfftGetPlanOffsetIn( const clfftPlanHandle plHandle, size_t* offsetIn );
+
+	/*! @brief Retrieve the offset  in number of elements for the output array
+	 *  @details Queries a plan object and retrieves the value of the offset  in number of elements for the input array
+	 *  @param[in]  plHandle Handle to a previously created plan
+	 *  @param[out] offset size
+	 *  @return Enum describing error condition; superset of OpenCL error codes
+	 */
+	CLFFTAPI clfftStatus clfftSetPlanOffsetOut( clfftPlanHandle plHandle, size_t offsetOut );
+
+	/*! @brief Retrieve the offset  in number of elements for the output array
+	 *  @details Queries a plan object and retrieves the value of the offset  in number of elements for the input array
+	 *  @param[in]  plHandle Handle to a previously created plan
+	 *  @param[out] offset size
+	 *  @return Enum describing error condition; superset of OpenCL error codes
+	 */
+	CLFFTAPI clfftStatus clfftGetPlanOffsetOut( const clfftPlanHandle plHandle, size_t* offsetOut );
+
 	/*! @brief Retrieve the scaling factor that is applied to the FFT data
 	 *  @details The user must pass a reference to a cl_float variable, which is set to the
 	 *  floating point scaling factor that is multiplied across the FFT data.
 	 *  @param[in] plHandle Handle to a previously created plan
 	 *  @param[in] dir Direction of the applied scaling factor
diff -Naru5 clFFT.old/src/include/clFFT.h.orig clFFT/src/include/clFFT.h.orig
--- clFFT.old/src/include/clFFT.h.orig	1970-01-01 00:00:00.000000000 +0000
+++ clFFT/src/include/clFFT.h.orig	2020-11-04 16:48:27.206337650 +0000
@@ -0,0 +1,608 @@
+/* ************************************************************************
+ * Copyright 2013-2015 Advanced Micro Devices, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * ************************************************************************/
+
+
+/*! @file clFFT.h
+ * clFFT.h defines all the public interfaces and types that are used by clFFT clients
+ * This is the only public header file that should be consumed by clFFT clients.  It is written to adhere to native "C"
+ * interfaces to make clFFT library as portable as possible; it should be callable from C, C++, .NET and Fortran,
+ * either with the proper linking or using wrapper classes.
+ *
+ */
+
+#pragma once
+#if !defined( CLFFT_H )
+#define CLFFT_H
+
+#if defined(__APPLE__) || defined(__MACOSX)
+	#include <OpenCL/cl.h>
+#else
+	#include <CL/cl.h>
+#endif
+
+#include "clFFT.version.h"
+
+/*! This preprocessor definition is the standard way to export APIs
+ *  from a DLL simpler. All files within this DLL are compiled with the CLFFT_EXPORTS
+ *  symbol defined on the command line. This symbol must not be defined on any project
+ *  that uses this DLL. This ensures source files of any other project that include this file see
+ *  clfft functions as being imported from a DLL, whereas the DLL sees symbols
+ *  defined with this macro as being exported.
+ */
+#if defined( _WIN32 )
+	#if !defined( __cplusplus )
+		#define inline __inline
+	#endif
+
+    #if defined( CLFFT_STATIC )
+        #define CLFFTAPI
+    #elif defined( CLFFT_EXPORTS )
+        #define CLFFTAPI __declspec( dllexport )
+    #else
+        #define CLFFTAPI __declspec( dllimport )
+    #endif
+#else
+	#define CLFFTAPI
+#endif
+
+/*	In general, you cannot use namespaces for strict C compliance, so we prefix our public accessible names
+ *	with the string clfft
+ */
+
+/*	All functions return pre-defined error codes, and do NOT throw exceptions to the caller.
+ */
+
+/*!  @brief clfft error codes definition(incorporating OpenCL error definitions)
+ *
+ *   This enumeration is a superset of the OpenCL error codes.  For example, CL_OUT_OF_HOST_MEMORY,
+ *   which is defined in cl.h is aliased as CLFFT_OUT_OF_HOST_MEMORY.  The set of basic OpenCL
+ *   error codes is extended to add extra values specific to the clfft package.
+ */
+enum clfftStatus_
+{
+	CLFFT_INVALID_GLOBAL_WORK_SIZE			= CL_INVALID_GLOBAL_WORK_SIZE,
+	CLFFT_INVALID_MIP_LEVEL					= CL_INVALID_MIP_LEVEL,
+	CLFFT_INVALID_BUFFER_SIZE				= CL_INVALID_BUFFER_SIZE,
+	CLFFT_INVALID_GL_OBJECT					= CL_INVALID_GL_OBJECT,
+	CLFFT_INVALID_OPERATION					= CL_INVALID_OPERATION,
+	CLFFT_INVALID_EVENT						= CL_INVALID_EVENT,
+	CLFFT_INVALID_EVENT_WAIT_LIST			= CL_INVALID_EVENT_WAIT_LIST,
+	CLFFT_INVALID_GLOBAL_OFFSET				= CL_INVALID_GLOBAL_OFFSET,
+	CLFFT_INVALID_WORK_ITEM_SIZE			= CL_INVALID_WORK_ITEM_SIZE,
+	CLFFT_INVALID_WORK_GROUP_SIZE			= CL_INVALID_WORK_GROUP_SIZE,
+	CLFFT_INVALID_WORK_DIMENSION			= CL_INVALID_WORK_DIMENSION,
+	CLFFT_INVALID_KERNEL_ARGS				= CL_INVALID_KERNEL_ARGS,
+	CLFFT_INVALID_ARG_SIZE					= CL_INVALID_ARG_SIZE,
+	CLFFT_INVALID_ARG_VALUE					= CL_INVALID_ARG_VALUE,
+	CLFFT_INVALID_ARG_INDEX					= CL_INVALID_ARG_INDEX,
+	CLFFT_INVALID_KERNEL					= CL_INVALID_KERNEL,
+	CLFFT_INVALID_KERNEL_DEFINITION			= CL_INVALID_KERNEL_DEFINITION,
+	CLFFT_INVALID_KERNEL_NAME				= CL_INVALID_KERNEL_NAME,
+	CLFFT_INVALID_PROGRAM_EXECUTABLE		= CL_INVALID_PROGRAM_EXECUTABLE,
+	CLFFT_INVALID_PROGRAM					= CL_INVALID_PROGRAM,
+	CLFFT_INVALID_BUILD_OPTIONS				= CL_INVALID_BUILD_OPTIONS,
+	CLFFT_INVALID_BINARY					= CL_INVALID_BINARY,
+	CLFFT_INVALID_SAMPLER					= CL_INVALID_SAMPLER,
+	CLFFT_INVALID_IMAGE_SIZE				= CL_INVALID_IMAGE_SIZE,
+	CLFFT_INVALID_IMAGE_FORMAT_DESCRIPTOR	= CL_INVALID_IMAGE_FORMAT_DESCRIPTOR,
+	CLFFT_INVALID_MEM_OBJECT				= CL_INVALID_MEM_OBJECT,
+	CLFFT_INVALID_HOST_PTR					= CL_INVALID_HOST_PTR,
+	CLFFT_INVALID_COMMAND_QUEUE				= CL_INVALID_COMMAND_QUEUE,
+	CLFFT_INVALID_QUEUE_PROPERTIES			= CL_INVALID_QUEUE_PROPERTIES,
+	CLFFT_INVALID_CONTEXT					= CL_INVALID_CONTEXT,
+	CLFFT_INVALID_DEVICE					= CL_INVALID_DEVICE,
+	CLFFT_INVALID_PLATFORM					= CL_INVALID_PLATFORM,
+	CLFFT_INVALID_DEVICE_TYPE				= CL_INVALID_DEVICE_TYPE,
+	CLFFT_INVALID_VALUE						= CL_INVALID_VALUE,
+	CLFFT_MAP_FAILURE						= CL_MAP_FAILURE,
+	CLFFT_BUILD_PROGRAM_FAILURE				= CL_BUILD_PROGRAM_FAILURE,
+	CLFFT_IMAGE_FORMAT_NOT_SUPPORTED		= CL_IMAGE_FORMAT_NOT_SUPPORTED,
+	CLFFT_IMAGE_FORMAT_MISMATCH				= CL_IMAGE_FORMAT_MISMATCH,
+	CLFFT_MEM_COPY_OVERLAP					= CL_MEM_COPY_OVERLAP,
+	CLFFT_PROFILING_INFO_NOT_AVAILABLE		= CL_PROFILING_INFO_NOT_AVAILABLE,
+	CLFFT_OUT_OF_HOST_MEMORY				= CL_OUT_OF_HOST_MEMORY,
+	CLFFT_OUT_OF_RESOURCES					= CL_OUT_OF_RESOURCES,
+	CLFFT_MEM_OBJECT_ALLOCATION_FAILURE		= CL_MEM_OBJECT_ALLOCATION_FAILURE,
+	CLFFT_COMPILER_NOT_AVAILABLE			= CL_COMPILER_NOT_AVAILABLE,
+	CLFFT_DEVICE_NOT_AVAILABLE				= CL_DEVICE_NOT_AVAILABLE,
+	CLFFT_DEVICE_NOT_FOUND					= CL_DEVICE_NOT_FOUND,
+	CLFFT_SUCCESS							= CL_SUCCESS,
+	//-------------------------- Extended status codes for clfft ----------------------------------------
+	CLFFT_BUGCHECK =  4*1024,	/*!< Bugcheck. */
+	CLFFT_NOTIMPLEMENTED,		/*!< Functionality is not implemented yet. */
+	CLFFT_TRANSPOSED_NOTIMPLEMENTED, /*!< Transposed functionality is not implemented for this transformation. */
+	CLFFT_FILE_NOT_FOUND,		/*!< Tried to open an existing file on the host system, but failed. */
+	CLFFT_FILE_CREATE_FAILURE,	/*!< Tried to create a file on the host system, but failed. */
+	CLFFT_VERSION_MISMATCH,		/*!< Version conflict between client and library. */
+	CLFFT_INVALID_PLAN,			/*!< Requested plan could not be found. */
+	CLFFT_DEVICE_NO_DOUBLE,		/*!< Double precision not supported on this device. */
+	CLFFT_DEVICE_MISMATCH,		/*!< Attempt to run on a device using a plan baked for a different device. */
+	CLFFT_ENDSTATUS				/* The last value of the enum, and marks the length of clfftStatus. */
+};
+typedef enum clfftStatus_ clfftStatus;
+
+/*!  @brief The dimension of the input and output buffers that is fed into all FFT transforms */
+typedef enum clfftDim_
+{
+	CLFFT_1D		= 1,		/*!< 1 Dimensional FFT transform (default). */
+	CLFFT_2D,					/*!< 2 Dimensional FFT transform. */
+	CLFFT_3D,					/*!< 3 Dimensional FFT transform. */
+	ENDDIMENSION			/*!< The last value of the enum, and marks the length of clfftDim. */
+} clfftDim;
+
+/*!  @brief Specify the expected layouts of the buffers */
+typedef enum clfftLayout_
+{
+	CLFFT_COMPLEX_INTERLEAVED	= 1,	/*!< An array of complex numbers, with real and imaginary components together (default). */
+	CLFFT_COMPLEX_PLANAR,				/*!< Separate arrays of real components and imaginary components. */
+	CLFFT_HERMITIAN_INTERLEAVED,		/*!< Compressed form of complex numbers; complex-conjugates are not stored, real and imaginary components are stored in the same array. */
+	CLFFT_HERMITIAN_PLANAR,				/*!< Compressed form of complex numbers; complex-conjugates are not stored, real and imaginary components are stored in separate arrays. */
+	CLFFT_REAL,							/*!< An array of real numbers, with no corresponding imaginary components. */
+	ENDLAYOUT			/*!< The last value of the enum, and marks the length of clfftLayout. */
+} clfftLayout;
+
+/*!  @brief Specify the expected precision of each FFT.
+ */
+typedef enum clfftPrecision_
+{
+	CLFFT_SINGLE	= 1,	/*!< An array of complex numbers, with real and imaginary components saved as floats (default). */
+	CLFFT_DOUBLE,			/*!< An array of complex numbers, with real and imaginary components saved as doubles. */
+	CLFFT_SINGLE_FAST,		/*!< Faster implementation preferred. */
+	CLFFT_DOUBLE_FAST,		/*!< Faster implementation preferred. */
+	ENDPRECISION	/*!< The last value of the enum, and marks the length of clfftPrecision. */
+} clfftPrecision;
+
+/*!  @brief Specify the expected direction of each FFT, time or the frequency domains */
+typedef enum clfftDirection_
+{
+	CLFFT_FORWARD	= -1,		/*!< FFT transform from time to frequency domain. */
+	CLFFT_BACKWARD	= 1,		/*!< FFT transform from frequency to time domain. */
+	CLFFT_MINUS		= -1,		/*!< Alias for the forward transform. */
+	CLFFT_PLUS		= 1,		/*!< Alias for the backward transform. */
+	ENDDIRECTION			/*!< The last value of the enum, and marks the length of clfftDirection. */
+} clfftDirection;
+
+/*!  @brief Specify wheter the input buffers are overwritten with results */
+typedef enum clfftResultLocation_
+{
+	CLFFT_INPLACE		= 1,		/*!< Input and output buffers are the same (default). */
+	CLFFT_OUTOFPLACE,				/*!< Input and output buffers are separate. */
+	ENDPLACE				/*!< The last value of the enum, and marks the length of clfftPlaceness. */
+} clfftResultLocation;
+
+/*! @brief Determines whether the result is returned in original order. It is valid only for
+dimensions greater than 1. */
+typedef enum clfftResultTransposed_ {
+	CLFFT_NOTRANSPOSE = 1,		/*!< The result is returned in the original order (default) */
+	CLFFT_TRANSPOSED,			/*!< The result is transposed where transpose kernel is supported (possibly faster) */
+	ENDTRANSPOSED			/*!< The last value of the enum, and marks the length of clfftResultTransposed */
+} clfftResultTransposed;
+
+/*! 	BitMasks to be used with clfftSetupData.debugFlags */
+#define CLFFT_DUMP_PROGRAMS 0x1
+
+/*! @brief Data structure that can be passed to clfftSetup() to control the behavior of the FFT runtime
+ *  @details This structure contains values that can be initialized before instantiation of the FFT runtime
+ *  with ::clfftSetup().  To initialize this structure, pass a pointer to a user struct to ::clfftInitSetupData( ),
+ *  which clears the structure and sets the version member variables to the current values.
+ */
+struct clfftSetupData_
+{
+	cl_uint major;		/*!< Major version number of the project; signifies possible major API changes. */
+	cl_uint minor;		/*!< Minor version number of the project; minor API changes that can break backward compatibility. */
+	cl_uint patch;		/*!< Patch version number of the project; always incrementing number, signifies change over time. */
+
+	/*! 	Bitwise flags that control the behavior of library debug logic. */
+	cl_ulong debugFlags;  /*! This must be set to zero, except when debugging the clfft library.
+	                       *  <p> debugFlags can be set to CLFFT_DUMP_PROGRAMS, in which case the dynamically generated OpenCL kernels are
+	                       *  written to text files in the current working directory.  These files have a *.cl suffix.
+	                       */
+};
+typedef struct clfftSetupData_ clfftSetupData;
+
+/*! @brief Type of Callback function.
+*/
+typedef enum clfftCallbackType_
+{
+	PRECALLBACK,	/*!< Callback function is invoked only once for every point of input at the beginning of FFT transform. */
+	POSTCALLBACK	/*!< Callback function is invoked only once for every point of output at the end of FFT transform. */
+}clfftCallbackType;
+
+/*!  @brief An abstract handle to the object that represents the state of the FFT(s) */
+typedef size_t clfftPlanHandle;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+	/*! @brief Initialize a clfftSetupData struct for the client
+	 *  @details clfftSetupData is passed to clfftSetup to control behavior of the FFT runtime.
+	 *  @param[out] setupData Data structure is cleared and initialized with version information and default values
+	 *  @return Enum describes the error condition; superset of OpenCL error codes
+	 */
+	__inline clfftStatus clfftInitSetupData( clfftSetupData* setupData )
+	{
+		setupData->major	= clfftVersionMajor;
+		setupData->minor	= clfftVersionMinor;
+		setupData->patch	= clfftVersionPatch;
+		setupData->debugFlags	= 0;
+
+		return	CLFFT_SUCCESS;
+	}
+
+	/*! @brief Initialize the internal FFT resources.
+	 *  @details The internal resources include FFT implementation caches kernels, programs, and buffers.
+	 *  @param[in] setupData Data structure that is passed into the setup routine to control FFT generation behavior
+	 * 	and debug functionality
+	 *  @return Enum describing error condition; superset of OpenCL error codes
+	 */
+	CLFFTAPI clfftStatus	clfftSetup( const clfftSetupData* setupData );
+
+	/*! @brief Release all internal resources.
+	 *  @details Called when client is done with the FFT library, allowing the library to destroy all resources it has cached
+	 *  @return Enum describing error condition; superset of OpenCL error codes
+	 */
+	CLFFTAPI clfftStatus	clfftTeardown( );
+
+	/*! @brief Query the FFT library for version information
+	 *  @details Returns the major, minor and patch version numbers associated with the FFT library
+	 *  @param[out] major Major functionality change
+	 *  @param[out] minor Minor functionality change
+	 *  @param[out] patch Bug fixes, documentation changes, no new features introduced
+	 *  @return Enum describing error condition; superset of OpenCL error codes
+	 */
+	CLFFTAPI clfftStatus	clfftGetVersion( cl_uint* major, cl_uint* minor, cl_uint* patch );
+
+	/*! @brief Create a plan object initialized entirely with default values.
+	 *  @details A plan is a repository of state for calculating FFT's.  Allows the runtime to pre-calculate kernels, programs
+	 * 	and buffers and associate them with buffers of specified dimensions.
+	 *  @param[out] plHandle Handle to the newly created plan
+	 *  @param[in] context Client is responsible for providing an OpenCL context for the plan
+	 *  @param[in] dim Dimensionality of the FFT transform; describes how many elements are in the array
+	 *  @param[in] clLengths An array of length of size 'dim';  each array value describes the length of each dimension
+	 *  @return Enum describing error condition; superset of OpenCL error codes
+	 */
+	CLFFTAPI clfftStatus	clfftCreateDefaultPlan( clfftPlanHandle* plHandle, cl_context context, const clfftDim dim,
+								const size_t* clLengths );
+
+	/*! @brief Create a copy of an existing plan.
+	 *  @details This API allows a client to create a new plan based upon an existing plan.  This function can be used to
+	 *  quickly create plans that are similar, but may differ slightly.
+	 *  @param[out] out_plHandle Handle to the newly created plan that is based on in_plHandle
+	 *  @param[in] new_context Client is responsible for providing a new context for the new plan
+	 *  @param[in] in_plHandle Handle to a previously created plan that is to be copied
+	 *  @return Enum describing error condition; superset of OpenCL error codes
+	 */
+	CLFFTAPI clfftStatus	clfftCopyPlan( clfftPlanHandle* out_plHandle, cl_context new_context, clfftPlanHandle in_plHandle );
+
+	/*! @brief Prepare the plan for execution.
+	 *  @details After all plan parameters are set, the client has the option of 'baking' the plan, which informs the runtime that
+	 *  no more change to the parameters of the plan is expected, and the OpenCL kernels can be compiled.  This optional function
+	 *  allows the client application to perform the OpenCL kernel compilation when the application is initialized instead of during the first
+	 *  execution.
+	 *  At this point, the clfft runtime applies all implimented optimizations, including
+	 *  running kernel experiments on the devices in the plan context.
+	 *  <p>  This function takes a long time to execute. If a plan is not baked before being executed,
+	 *  the first call to clfftEnqueueTransform takes a long time to execute.
+	 *  <p>  If any significant parameter of a plan is changed after the plan is baked (by a subsequent call to any one of
+	 *  the functions that has the prefix "clfftSetPlan"), it is not considered an error.  Instead, the plan reverts back to
+	 *  the unbaked state, discarding the benefits of the baking operation.
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[in] numQueues Number of command queues in commQueueFFT; 0 is a valid value, in which case the client does not want
+	 * 	the runtime to run load experiments and only pre-calculate state information
+	 *  @param[in] commQueueFFT An array of cl_command_queues created by the client; the command queues must be a proper subset of
+	 * 	the devices included in the plan context
+	 *  @param[in] pfn_notify A function pointer to a notification routine. The notification routine is a callback function that
+	 *  an application can register and is called when the program executable is built (successfully or unsuccessfully).
+	 *  Currently, this parameter MUST be NULL or nullptr.
+	 *  @param[in] user_data Passed as an argument when pfn_notify is called.
+	 *  Currently, this parameter MUST be NULL or nullptr.
+	 *  @return Enum describing error condition; superset of OpenCL error codes
+	 */
+	CLFFTAPI clfftStatus	clfftBakePlan( clfftPlanHandle plHandle, cl_uint numQueues, cl_command_queue* commQueueFFT,
+							void (CL_CALLBACK *pfn_notify)(clfftPlanHandle plHandle, void *user_data), void* user_data );
+
+	/*! @brief Release the resources of a plan.
+	 *  @details A plan may include resources, such as kernels, programs, and buffers that consume memory.  When a plan
+	 *  is no more needed, the client must release the plan.
+	 *  @param[in,out] plHandle Handle to a previously created plan
+	 *  @return Enum describing error condition; superset of OpenCL error codes
+	 */
+	CLFFTAPI clfftStatus	clfftDestroyPlan( clfftPlanHandle* plHandle );
+
+	/*! @brief Retrieve the OpenCL context of a previously created plan.
+	 *  @details The user must pass a reference to a cl_context variable, which is modified to point to a
+	 *  context set in the specified plan.
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[out] context Reference to the user allocated cl_context, which points to context set in the plan
+	 *  @return Enum describing error condition; superset of OpenCL error codes
+	 */
+	CLFFTAPI clfftStatus	clfftGetPlanContext( const clfftPlanHandle plHandle, cl_context* context );
+
+	/*! @brief Retrieve the floating point precision of the FFT data
+	 *  @details The user must pass a reference to a clfftPrecision variable, which is set to the
+	 *  precision of the FFT complex data in the plan.
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[out] precision Reference to the user clfftPrecision enum
+	 *  @return Enum describing error condition; superset of OpenCL error codes
+	 */
+	CLFFTAPI clfftStatus	clfftGetPlanPrecision( const clfftPlanHandle plHandle, clfftPrecision* precision );
+
+	/*! @brief Set the floating point precision of the FFT data
+	 *  @details Sets the floating point precision of the FFT complex data in the plan.
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[in] precision Reference to the user clfftPrecision enum
+	 *  @return Enum describing error condition; superset of OpenCL error codes
+	 */
+	CLFFTAPI clfftStatus	clfftSetPlanPrecision( clfftPlanHandle plHandle, clfftPrecision precision );
+
+	/*! @brief Retrieve the scaling factor that is applied to the FFT data
+	 *  @details The user must pass a reference to a cl_float variable, which is set to the
+	 *  floating point scaling factor that is multiplied across the FFT data.
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[in] dir Direction of the applied scaling factor
+	 *  @param[out] scale Reference to the user cl_float variable
+	 *  @return Enum describing error condition; superset of OpenCL error codes
+	 */
+	CLFFTAPI clfftStatus	clfftGetPlanScale( const clfftPlanHandle plHandle, clfftDirection dir, cl_float* scale );
+
+	/*! @brief Set the scaling factor that is applied to the FFT data
+	 *  @details Sets the floating point scaling factor that is
+	 *  multiplied across the FFT data.
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[in] dir Direction of the applied scaling factor
+	 *  @param[in] scale Reference to the user cl_float variable
+	 *  @return Enum describing error condition; superset of OpenCL error codes
+	 */
+	CLFFTAPI clfftStatus	clfftSetPlanScale( clfftPlanHandle plHandle, clfftDirection dir, cl_float scale );
+
+	/*! @brief Retrieve the number of discrete arrays that the plan can concurrently handle
+	 *  @details The user must pass a reference to a cl_uint variable, which is set to the
+	 *  number of discrete arrays (1D or 2D) that is batched together for the plan
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[out] batchSize Number of discrete FFTs performed
+	 *  @return Enum describing error condition; superset of OpenCL error codes
+	 */
+	CLFFTAPI clfftStatus	clfftGetPlanBatchSize( const clfftPlanHandle plHandle, size_t* batchSize );
+
+	/*! @brief Set the number of discrete arrays that the plan can concurrently handle
+	 *  @details Sets the plan property which sets the number of discrete arrays (1D or 2D)
+	 *  that is batched together for the plan
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[in] batchSize Number of discrete FFTs performed
+	 *  @return Enum describing error condition; superset of OpenCL error codes
+	 */
+	CLFFTAPI clfftStatus	clfftSetPlanBatchSize( clfftPlanHandle plHandle, size_t batchSize );
+
+	/*! @brief Retrieve the dimensionality of the data that is transformed
+	 *  @details Queries a plan object and retrieves the value of the dimensionality that the plan is set for.  A size is returned to
+	 *  help the client allocate sufficient storage to hold the dimensions in a further call to clfftGetPlanLength
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[out] dim The dimensionality of the FFT to be transformed
+	 *  @param[out] size Value to allocate an array to hold the FFT dimensions.
+	 *  @return Enum describing error condition; superset of OpenCL error codes
+	 */
+	CLFFTAPI clfftStatus	clfftGetPlanDim( const clfftPlanHandle plHandle, clfftDim* dim, cl_uint* size );
+
+	/*! @brief Set the dimensionality of the data that is transformed
+	 *  @details Set the dimensionality of the data that is transformed by the plan
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[in] dim The dimensionality of the FFT to be transformed
+	 *  @return Enum describing error condition; superset of OpenCL error codes
+	 */
+	CLFFTAPI clfftStatus	clfftSetPlanDim( clfftPlanHandle plHandle, const clfftDim dim );
+
+	/*! @brief Retrieve the length of each dimension of the FFT
+	 *  @details The user must pass a reference to a size_t array, which is set to the
+	 *  length of each discrete dimension of the FFT
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[in] dim Dimension of the FFT; describes how many elements are in the clLengths array
+	 *  @param[out] clLengths An array of length of size 'dim';  each array value describes the length of each dimension
+	 *  @return Enum describing error condition; superset of OpenCL error codes
+	 */
+	CLFFTAPI clfftStatus	clfftGetPlanLength( const clfftPlanHandle plHandle, const clfftDim dim, size_t* clLengths );
+
+	/*! @brief Set the length of each dimension of the FFT
+	 *  @details Sets the plan property which is the length of each discrete dimension of the FFT
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[in] dim The dimension of the FFT; describes how many elements are in the clLengths array
+	 *  @param[in] clLengths An array of length of size 'dim';  each array value describes the length of each dimension
+	 *  @return Enum describing error condition; superset of OpenCL error codes
+	 */
+	CLFFTAPI clfftStatus	clfftSetPlanLength( clfftPlanHandle plHandle, const clfftDim dim, const size_t* clLengths );
+
+	/*! @brief Retrieve the distance between consecutive elements of input buffers in each dimension.
+	 *  @details Depending on how the dimension is set in the plan (for 2D or 3D FFT), strideY or strideZ can be safely
+	 *  ignored
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[in] dim The dimension of the stride parameters; provides the number of elements in the array
+	 *  @param[out] clStrides An array of strides, of size 'dim'.
+	 */
+	CLFFTAPI clfftStatus	clfftGetPlanInStride( const clfftPlanHandle plHandle, const clfftDim dim, size_t* clStrides );
+
+	/*! @brief Set the distance between consecutive elements of input buffers in each dimension.
+	 *  @details Set the plan properties which is the distance between elements in all dimensions of the input buffer
+	 *  (units are in terms of clfftPrecision)
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[in] dim The dimension of the stride parameters; provides the number of elements in the clStrides array
+	 *  @param[in] clStrides An array of strides of size 'dim'. Usually, strideX=1 so that successive elements in the first dimension are stored contiguously.
+	 * 	Typically, strideY=LenX and strideZ=LenX*LenY with the successive elements in the second and third dimensions stored in packed format.
+	 *  See  @ref DistanceStridesandPitches for details.
+	 */
+	CLFFTAPI clfftStatus	clfftSetPlanInStride( clfftPlanHandle plHandle, const clfftDim dim, size_t* clStrides );
+
+	/*! @brief Retrieve the distance between consecutive elements of output buffers in each dimension.
+	 *  @details Depending on how the dimension is set in the plan (for 2D or 3D FFT), strideY or strideZ can be safely
+	 *  ignored
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[in] dim The dimension of the stride parameters; provides the number of elements in the clStrides array
+	 *  @param[out] clStrides An array of strides, of size 'dim'.
+	 */
+	CLFFTAPI clfftStatus	clfftGetPlanOutStride( const clfftPlanHandle plHandle, const clfftDim dim, size_t* clStrides );
+
+	/*! @brief Set the distance between consecutive elements of output buffers in a dimension.
+	 *  @details Sets the plan properties which is the distance between elements in all dimensions of the output buffer
+	 *  (units are in terms of clfftPrecision)
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[in] dim The dimension of the stride parameters; provides the number of elements in the clStrides array
+	 *  @param[in] clStrides An array of strides of size 'dim'.  Usually, strideX=1 so that successive elements in the first dimension are stored contiguously.
+	 * 	Typically, strideY=LenX and strideZ=LenX*LenY cause the successive elements in the second and third dimensions be stored in packed format.
+	 *  @sa clfftSetPlanInStride
+	 */
+	CLFFTAPI clfftStatus	clfftSetPlanOutStride( clfftPlanHandle plHandle, const clfftDim dim, size_t* clStrides );
+
+	/*! @brief Retrieve the distance between array objects
+	 *  @details Pitch is the distance between each discrete array object in an FFT array. This is only used
+	 *  for 'array' dimensions in clfftDim; see clfftSetPlanDimension (units are in terms of clfftPrecision)
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[out] iDist The distance between the beginning elements of the discrete array objects in input buffer.
+	 *  For contiguous arrays in memory, iDist=(strideX*strideY*strideZ)
+	 *  @param[out] oDist The distance between the beginning elements of the discrete array objects in output buffer.
+	 *  For contiguous arrays in memory, oDist=(strideX*strideY*strideZ)
+	 */
+	CLFFTAPI clfftStatus	clfftGetPlanDistance( const clfftPlanHandle plHandle, size_t* iDist, size_t* oDist );
+
+	/*! @brief Set the distance between array objects
+	 *  @details Pitch is the distance between each discrete array object in an FFT array. This is only used
+	 *  for 'array' dimensions in clfftDim; see clfftSetPlanDimension (units are in terms of clfftPrecision)
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[out] iDist The distance between the beginning elements of the discrete array objects in input buffer.
+	 *  For contiguous arrays in memory, iDist=(strideX*strideY*strideZ)
+	 *  @param[out] oDist The distance between the beginning elements of the discrete array objects in output buffer.
+	 *  For contiguous arrays in memory, oDist=(strideX*strideY*strideZ)
+	 */
+	CLFFTAPI clfftStatus	clfftSetPlanDistance( clfftPlanHandle plHandle, size_t iDist, size_t oDist );
+
+	/*! @brief Retrieve the expected layout of the input and output buffers
+	 *  @details Input and output buffers can be filled with either Hermitian, complex, or real numbers.  Complex numbers are stored
+	 *  in various layouts; this function retrieves the layouts used by input and output
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[out] iLayout Indicates how the input buffers are laid out in memory
+	 *  @param[out] oLayout Indicates how the output buffers are laid out in memory
+	 */
+	CLFFTAPI clfftStatus	clfftGetLayout( const clfftPlanHandle plHandle, clfftLayout* iLayout, clfftLayout* oLayout );
+
+	/*! @brief Set the expected layout of the input and output buffers
+	 *  @details Input and output buffers can be filled with either Hermitian, complex, or real numbers.  Complex numbers can be stored
+	 *  in various layouts; this function informs the library what layouts to use for input and output
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[in] iLayout Indicates how the input buffers are laid out in memory
+	 *  @param[in] oLayout Indicates how the output buffers are laid out in memory
+	 */
+	CLFFTAPI clfftStatus	clfftSetLayout( clfftPlanHandle plHandle, clfftLayout iLayout, clfftLayout oLayout );
+
+	/*! @brief Retrieve whether the input buffers are to be overwritten with results
+	 *  @details If the setting performs an in-place transform, the input buffers are overwritten with the results of the
+	 *  transform.  If the setting performs an out-of-place transforms, the library looks for separate output buffers
+	 *  on the Enqueue call.
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[out] placeness Informs the library to either overwrite the input buffers with results or to write them in separate output buffers
+	 */
+	CLFFTAPI clfftStatus	clfftGetResultLocation( const clfftPlanHandle plHandle, clfftResultLocation* placeness );
+
+	/*! @brief Set whether the input buffers are to be overwritten with results
+	 *  @details If the setting performs an in-place transform, the input buffers are overwritten with the results of the
+	 *  transform.  If the setting performs an out-of-place transforms, the library looks for separate output buffers
+	 *  on the Enqueue call.
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[in] placeness Informs the library to either overwrite the input buffers with results or to write them in separate output buffers
+	 */
+	CLFFTAPI clfftStatus	clfftSetResultLocation( clfftPlanHandle plHandle, clfftResultLocation placeness );
+
+	/*! @brief Retrieve the final transpose setting of a multi-dimensional FFT
+	 *  @details A multi-dimensional FFT transposes the data several times during calculation. If the client
+	 *  does not care about the final transpose, to put data back in proper dimension, the final transpose can be skipped
+	 *  to improve speed
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[out] transposed Specifies whether the final transpose can be skipped
+	 */
+	CLFFTAPI clfftStatus	clfftGetPlanTransposeResult( const clfftPlanHandle plHandle, clfftResultTransposed * transposed );
+
+	/*! @brief Set the final transpose setting of a multi-dimensional FFT
+	 *  @details A multi-dimensional FFT transposes the data several times during calculation.  If the client
+	 *  does not care about the final transpose, to put data back in proper dimension, the final transpose can be skipped
+	 *  to improve speed
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[in] transposed Specifies whether the final transpose can be skipped
+	 */
+	CLFFTAPI clfftStatus	clfftSetPlanTransposeResult( clfftPlanHandle plHandle, clfftResultTransposed transposed );
+
+
+	/*! @brief Get buffer size (in bytes), which may be needed internally for an intermediate buffer
+	 *  @details Very large FFT transforms may need multiple passes, and the operation needs a temporary buffer to hold
+	 *  intermediate results. This function is only valid after the plan is baked, otherwise, an invalid operation error
+	 *  is returned. If the returned buffersize is 0, the runtime needs no temporary buffer.
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[out] buffersize Size in bytes for intermediate buffer
+	 */
+	CLFFTAPI clfftStatus clfftGetTmpBufSize( const clfftPlanHandle plHandle, size_t* buffersize );
+
+	/*! @brief Register the callback parameters
+	 *  @details Client can provide a callback function to do custom processing while reading input data and/or
+	 *  writing output data. The callback function is provided as a string.
+	 *  clFFT library incorporates the callback function string into the main FFT kernel. This function is used
+	 *  by client to set the necessary parameters for callback
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[in] funcName Callback function name
+	 *  @param[in] funcString Callback function in string form
+	 *  @param[in] localMemSize Optional - Size (bytes) of the local memory used by callback function; pass 0 if no local memory is used
+	 *  @param[in] callbackType Type of callback - Pre-Callback or Post-Callback
+	 *  @param[in] userdata Supplementary data if any used by callback function
+	 *  @param[in] numUserdataBuffers Number of userdata buffers
+	 */
+	CLFFTAPI clfftStatus clfftSetPlanCallback(clfftPlanHandle plHandle, const char* funcName, const char* funcString,
+										int localMemSize, clfftCallbackType callbackType, cl_mem *userdata, int numUserdataBuffers);
+
+
+	/*! @brief Enqueue an FFT transform operation, and return immediately (non-blocking)
+	 *  @details This transform API function computes the FFT transform. It is non-blocking as it
+	 *  only enqueues the OpenCL kernels for execution. The synchronization step must be managed by the user.
+	 *  @param[in] plHandle Handle to a previously created plan
+	 *  @param[in] dir Forward or backward transform
+	 *  @param[in] numQueuesAndEvents Number of command queues in commQueues; number of expected events to be returned in outEvents
+	 *  @param[in] commQueues An array of cl_command_queues created by the client; the command queues must be a proper subset of
+	 * 	the devices included in the OpenCL context associated with the plan
+	 *  @param[in] numWaitEvents Specify the number of elements in the eventWaitList array
+	 *  @param[in] waitEvents Events for which the transform waits to complete before executing on the device
+	 *  @param[out] outEvents The runtime fills this array with events corresponding one to one with the input command queues passed
+	 *	in commQueues.  This parameter can have the value NULL or nullptr. When the value is NULL, the client is not interested in receiving notifications
+	 *	when transforms are finished, otherwise, (if not NULL) the client is responsible for allocating this array with at least
+	 *	as many elements as specified in numQueuesAndEvents.
+	 *  @param[in] inputBuffers An array of cl_mem objects that contain data for processing by the FFT runtime. If the transform
+	 *  is in-place, the FFT results overwrite the input buffers
+	 *  @param[out] outputBuffers An array of cl_mem objects that store the results of out-of-place transforms. If the transform
+	 *  is in-place, this parameter may be NULL or nullptr and is completely ignored
+	 *  @param[in] tmpBuffer A cl_mem object that is reserved as a temporary buffer for FFT processing. If clTmpBuffers is NULL or nullptr,
+	 *  and the library needs temporary storage, an internal temporary buffer is created on the fly managed by the library.
+	 *  @return Enum describing error condition; superset of OpenCL error codes
+	 */
+	CLFFTAPI clfftStatus	clfftEnqueueTransform(
+												clfftPlanHandle plHandle,
+												clfftDirection dir,
+												cl_uint numQueuesAndEvents,
+												cl_command_queue* commQueues,
+												cl_uint numWaitEvents,
+												const cl_event* waitEvents,
+												cl_event* outEvents,
+												cl_mem* inputBuffers,
+												cl_mem* outputBuffers,
+												cl_mem tmpBuffer
+												);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Naru5 clFFT.old/src/library/accessors.cpp clFFT/src/library/accessors.cpp
--- clFFT.old/src/library/accessors.cpp	2020-11-04 16:35:17.422391075 +0000
+++ clFFT/src/library/accessors.cpp	2020-11-04 16:48:27.206337650 +0000
@@ -50,10 +50,62 @@
 	fftPlan->baked		= false;
 	fftPlan->batchsize  = batchsize;
 	return CLFFT_SUCCESS;
 }
 
+clfftStatus clfftGetPlanOffsetIn( const clfftPlanHandle plHandle, size_t* offsetIn )
+{
+	FFTRepo& fftRepo	= FFTRepo::getInstance( );
+	FFTPlan* fftPlan	= NULL;
+	lockRAII* planLock	= NULL;
+
+	OPENCL_V( fftRepo.getPlan( plHandle, fftPlan, planLock ), _T( "fftRepo.getPlan failed" ) );
+	scopedLock sLock( *planLock, _T( "clfftGetPlanOffsetIn" ) );
+
+	*offsetIn   = fftPlan->offsetIn;
+	return CLFFT_SUCCESS;
+}
+
+clfftStatus clfftSetPlanOffsetIn( clfftPlanHandle plHandle, size_t offsetIn )
+{
+	FFTRepo& fftRepo	= FFTRepo::getInstance( );
+	FFTPlan* fftPlan	= NULL;
+	lockRAII* planLock	= NULL;
+
+	OPENCL_V( fftRepo.getPlan( plHandle, fftPlan, planLock ), _T( "fftRepo.getPlan failed" ) );
+	scopedLock sLock( *planLock, _T( "clfftSetPlanOffsetIn" ) );
+
+	fftPlan->offsetIn  = offsetIn;
+	return CLFFT_SUCCESS;
+}
+
+clfftStatus clfftGetPlanOffsetOut( const clfftPlanHandle plHandle, size_t* offsetOut )
+{
+	FFTRepo& fftRepo	= FFTRepo::getInstance( );
+	FFTPlan* fftPlan	= NULL;
+	lockRAII* planLock	= NULL;
+
+	OPENCL_V( fftRepo.getPlan( plHandle, fftPlan, planLock ), _T( "fftRepo.getPlan failed" ) );
+	scopedLock sLock( *planLock, _T( "clfftGetPlanOffsetIn" ) );
+
+	*offsetOut   = fftPlan->offsetOut;
+	return CLFFT_SUCCESS;
+}
+
+clfftStatus clfftSetPlanOffsetOut( clfftPlanHandle plHandle, size_t offsetOut )
+{
+	FFTRepo& fftRepo	= FFTRepo::getInstance( );
+	FFTPlan* fftPlan	= NULL;
+	lockRAII* planLock	= NULL;
+
+	OPENCL_V( fftRepo.getPlan( plHandle, fftPlan, planLock ), _T( "fftRepo.getPlan failed" ) );
+	scopedLock sLock( *planLock, _T( "clfftSetPlanOffsetIn" ) );
+
+	fftPlan->offsetOut  = offsetOut;
+	return CLFFT_SUCCESS;
+}
+
 clfftStatus clfftGetPlanContext( const clfftPlanHandle plHandle, cl_context* context )
 {
 	FFTRepo& fftRepo	= FFTRepo::getInstance( );
 	FFTPlan* fftPlan	= NULL;
 	lockRAII* planLock	= NULL;
@@ -831,6 +883,6 @@
 	default:
 		ARG_CHECK (false);
 	}
 
 	return	CLFFT_SUCCESS;
-}
\ No newline at end of file
+}
diff -Naru5 clFFT.old/src/library/enqueue.cpp clFFT/src/library/enqueue.cpp
--- clFFT.old/src/library/enqueue.cpp	2020-11-04 16:35:17.422391075 +0000
+++ clFFT/src/library/enqueue.cpp	2020-11-04 16:48:27.206337650 +0000
@@ -28,477 +28,477 @@
 #define FFT_CACHE_DEBUG 0
 
 
 
 FFTCopyAction::FFTCopyAction(clfftPlanHandle plHandle, FFTPlan * plan, cl_command_queue queue, clfftStatus & err)
-    : FFTAction(plan, err)
+: FFTAction(plan, err)
 {
-    if (err != CLFFT_SUCCESS)
-    {
-        // FFTAction() failed, exit constructor
-        return;
-    }
+	if (err != CLFFT_SUCCESS)
+	{
+		// FFTAction() failed, exit constructor
+		return;
+	}
 
-    err = CLFFT_SUCCESS;
+	err = CLFFT_SUCCESS;
 }
 
 FFTTransposeGCNAction::FFTTransposeGCNAction(clfftPlanHandle plHandle, FFTPlan * plan, cl_command_queue queue, clfftStatus & err)
-    : FFTAction(plan, err)
+: FFTAction(plan, err)
 {
-    if (err != CLFFT_SUCCESS)
-    {
-        // FFTAction() failed, exit constructor
-        return;
-    }
+	if (err != CLFFT_SUCCESS)
+	{
+		// FFTAction() failed, exit constructor
+		return;
+	}
 
-    err = CLFFT_SUCCESS;
+	err = CLFFT_SUCCESS;
 }
 
 FFTTransposeSquareAction::FFTTransposeSquareAction(clfftPlanHandle plHandle, FFTPlan * plan, cl_command_queue queue, clfftStatus & err)
-    : FFTAction(plan, err)
+: FFTAction(plan, err)
 {
-    if (err != CLFFT_SUCCESS)
-    {
-        // FFTAction() failed, exit constructor
-        return;
-    }
+	if (err != CLFFT_SUCCESS)
+	{
+		// FFTAction() failed, exit constructor
+		return;
+	}
 
-    err = CLFFT_SUCCESS;
+	err = CLFFT_SUCCESS;
 }
 
 FFTTransposeNonSquareAction::FFTTransposeNonSquareAction(clfftPlanHandle plHandle, FFTPlan * plan, cl_command_queue queue, clfftStatus & err)
-    : FFTAction(plan, err)
+: FFTAction(plan, err)
 {
-    if (err != CLFFT_SUCCESS)
-    {
-        // FFTAction() failed, exit constructor
-        return;
-    }
+	if (err != CLFFT_SUCCESS)
+	{
+		// FFTAction() failed, exit constructor
+		return;
+	}
 
-    err = CLFFT_SUCCESS;
+	err = CLFFT_SUCCESS;
 }
 
 FFTStockhamAction::FFTStockhamAction(clfftPlanHandle plHandle, FFTPlan * plan, cl_command_queue queue, clfftStatus & err)
-    : FFTAction(plan, err)
+: FFTAction(plan, err)
 {
-    if (err != CLFFT_SUCCESS)
-    {
-        // FFTAction() failed, exit constructor
-        return;
-    }
+	if (err != CLFFT_SUCCESS)
+	{
+		// FFTAction() failed, exit constructor
+		return;
+	}
 
-    err = CLFFT_SUCCESS;
+	err = CLFFT_SUCCESS;
 }
 
 
 
 FFTAction::FFTAction(FFTPlan * fftPlan, clfftStatus & err)
-    : plan(fftPlan)
+: plan(fftPlan)
 {
-    err = CLFFT_SUCCESS;
+	err = CLFFT_SUCCESS;
 }
 
 clfftStatus FFTAction::selectBufferArguments(FFTPlan * fftPlan,
-                                             cl_mem* clInputBuffers,
-                                             cl_mem* clOutputBuffers,
-                                             std::vector< cl_mem > &inputBuff,
-                                             std::vector< cl_mem > &outputBuff)
+		cl_mem* clInputBuffers,
+		cl_mem* clOutputBuffers,
+		std::vector< cl_mem > &inputBuff,
+		std::vector< cl_mem > &outputBuff)
 {
-    
-    // 1d with normal length will fall into the below category
-    // add: 2d transpose kernel will fall into here too.
-    inputBuff.reserve( 2 );
-    outputBuff.reserve( 2 );
-
-    //	Decode the relevant properties from the plan paramter to figure out how many input/output buffers we have
-    switch( fftPlan->inputLayout )
-    {
-    case CLFFT_COMPLEX_INTERLEAVED:
-    {
-        switch( fftPlan->outputLayout )
-        {
-        case CLFFT_COMPLEX_INTERLEAVED:
-        {
-            if( fftPlan->placeness == CLFFT_INPLACE )
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-            }
-            else
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-                outputBuff.push_back( clOutputBuffers[ 0 ] );
-            }
-
-            break;
-        }
-        case CLFFT_COMPLEX_PLANAR:
-        {
-            if( fftPlan->placeness == CLFFT_INPLACE )
-            {
-                //	Invalid to be an inplace transform, and go from 1 to 2 buffers
-                return CLFFT_INVALID_ARG_VALUE;
-            }
-            else
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-
-                outputBuff.push_back( clOutputBuffers[ 0 ] );
-                outputBuff.push_back( clOutputBuffers[ 1 ] );
-            }
-
-            break;
-        }
-        case CLFFT_HERMITIAN_INTERLEAVED:
-        {
-            if( fftPlan->placeness == CLFFT_INPLACE )
-            {
-                return CLFFT_INVALID_ARG_VALUE;
-            }
-            else
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-                outputBuff.push_back( clOutputBuffers[ 0 ] );
-            }
-
-            break;
-        }
-        case CLFFT_HERMITIAN_PLANAR:
-        {
-            if( fftPlan->placeness == CLFFT_INPLACE )
-            {
-                return CLFFT_INVALID_ARG_VALUE;
-            }
-            else
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-
-                outputBuff.push_back( clOutputBuffers[ 0 ] );
-                outputBuff.push_back( clOutputBuffers[ 1 ] );
-            }
-
-            break;
-        }
-        case CLFFT_REAL:
-        {
-            if( fftPlan->placeness == CLFFT_INPLACE )
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-            }
-            else
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-                outputBuff.push_back( clOutputBuffers[ 0 ] );
-            }
-
-            break;
-        }
-        default:
-        {
-            //	Don't recognize output layout
-            return CLFFT_INVALID_ARG_VALUE;
-        }
-        }
-
-        break;
-    }
-    case CLFFT_COMPLEX_PLANAR:
-    {
-        switch( fftPlan->outputLayout )
-        {
-        case CLFFT_COMPLEX_INTERLEAVED:
-        {
-            if( fftPlan->placeness == CLFFT_INPLACE )
-            {
-                return CLFFT_INVALID_ARG_VALUE;
-            }
-            else
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-                inputBuff.push_back( clInputBuffers[ 1 ] );
-
-                outputBuff.push_back( clOutputBuffers[ 0 ] );
-            }
-
-            break;
-        }
-        case CLFFT_COMPLEX_PLANAR:
-        {
-            if( fftPlan->placeness == CLFFT_INPLACE )
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-                inputBuff.push_back( clInputBuffers[ 1 ] );
-            }
-            else
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-                inputBuff.push_back( clInputBuffers[ 1 ] );
-
-                outputBuff.push_back( clOutputBuffers[ 0 ] );
-                outputBuff.push_back( clOutputBuffers[ 1 ] );
-            }
-
-            break;
-        }
-        case CLFFT_HERMITIAN_INTERLEAVED:
-        {
-            if( fftPlan->placeness == CLFFT_INPLACE )
-            {
-                return CLFFT_INVALID_ARG_VALUE;
-            }
-            else
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-                inputBuff.push_back( clInputBuffers[ 1 ] );
-
-                outputBuff.push_back( clOutputBuffers[ 0 ] );
-            }
-
-            break;
-        }
-        case CLFFT_HERMITIAN_PLANAR:
-        {
-            if( fftPlan->placeness == CLFFT_INPLACE )
-            {
-                return CLFFT_INVALID_ARG_VALUE;
-            }
-            else
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-                inputBuff.push_back( clInputBuffers[ 1 ] );
-
-                outputBuff.push_back( clOutputBuffers[ 0 ] );
-                outputBuff.push_back( clOutputBuffers[ 1 ] );
-            }
-
-            break;
-        }
-        case CLFFT_REAL:
-        {
-            if( fftPlan->placeness == CLFFT_INPLACE )
-            {
-                return CLFFT_INVALID_ARG_VALUE;
-            }
-            else
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-                inputBuff.push_back( clInputBuffers[ 1 ] );
-
-                outputBuff.push_back( clOutputBuffers[ 0 ] );
-            }
-
-            break;
-        }
-        default:
-        {
-            //	Don't recognize output layout
-            return CLFFT_INVALID_ARG_VALUE;
-        }
-        }
-
-        break;
-    }
-    case CLFFT_HERMITIAN_INTERLEAVED:
-    {
-        switch( fftPlan->outputLayout )
-        {
-        case CLFFT_COMPLEX_INTERLEAVED:
-        {
-            if( fftPlan->placeness == CLFFT_INPLACE )
-            {
-                return CLFFT_INVALID_ARG_VALUE;
-            }
-            else
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-                outputBuff.push_back( clOutputBuffers[ 0 ] );
-            }
-
-            break;
-        }
-        case CLFFT_COMPLEX_PLANAR:
-        {
-            if( fftPlan->placeness == CLFFT_INPLACE )
-            {
-                return CLFFT_INVALID_ARG_VALUE;
-            }
-            else
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-
-                outputBuff.push_back( clOutputBuffers[ 0 ] );
-                outputBuff.push_back( clOutputBuffers[ 1 ] );
-            }
-
-            break;
-        }
-        case CLFFT_HERMITIAN_INTERLEAVED:
-        {
-            return CLFFT_INVALID_ARG_VALUE;
-        }
-        case CLFFT_HERMITIAN_PLANAR:
-        {
-            return CLFFT_INVALID_ARG_VALUE;
-        }
-        case CLFFT_REAL:
-        {
-            if( fftPlan->placeness == CLFFT_INPLACE )
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-            }
-            else
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-                outputBuff.push_back( clOutputBuffers[ 0 ] );
-            }
-
-            break;
-        }
-        default:
-        {
-            //	Don't recognize output layout
-            return CLFFT_INVALID_ARG_VALUE;
-        }
-        }
-
-        break;
-    }
-    case CLFFT_HERMITIAN_PLANAR:
-    {
-        switch( fftPlan->outputLayout )
-        {
-        case CLFFT_COMPLEX_INTERLEAVED:
-        {
-            if( fftPlan->placeness == CLFFT_INPLACE )
-            {
-                return CLFFT_INVALID_ARG_VALUE;
-            }
-            else
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-                inputBuff.push_back( clInputBuffers[ 1 ] );
-
-                outputBuff.push_back( clOutputBuffers[ 0 ] );
-            }
-
-            break;
-        }
-        case CLFFT_COMPLEX_PLANAR:
-        {
-            if( fftPlan->placeness == CLFFT_INPLACE )
-            {
-                return CLFFT_INVALID_ARG_VALUE;
-            }
-            else
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-                inputBuff.push_back( clInputBuffers[ 1 ] );
-
-                outputBuff.push_back( clOutputBuffers[ 0 ] );
-                outputBuff.push_back( clOutputBuffers[ 1 ] );
-            }
-
-            break;
-        }
-        case CLFFT_HERMITIAN_INTERLEAVED:
-        {
-            return CLFFT_INVALID_ARG_VALUE;
-        }
-        case CLFFT_HERMITIAN_PLANAR:
-        {
-            return CLFFT_INVALID_ARG_VALUE;
-        }
-        case CLFFT_REAL:
-        {
-            if( fftPlan->placeness == CLFFT_INPLACE )
-            {
-                return CLFFT_INVALID_ARG_VALUE;
-            }
-            else
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-                inputBuff.push_back( clInputBuffers[ 1 ] );
-
-                outputBuff.push_back( clOutputBuffers[ 0 ] );
-            }
-
-            break;
-        }
-        default:
-        {
-            //	Don't recognize output layout
-            return CLFFT_INVALID_ARG_VALUE;
-        }
-        }
-
-        break;
-    }
-    case CLFFT_REAL:
-    {
-        switch( fftPlan->outputLayout )
-        {
-        case CLFFT_COMPLEX_INTERLEAVED:
-        {
-            if( fftPlan->placeness == CLFFT_INPLACE )
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-            }
-            else
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-                outputBuff.push_back( clOutputBuffers[ 0 ] );
-            }
-
-            break;
-        }
-        case CLFFT_COMPLEX_PLANAR:
-        {
-            if( fftPlan->placeness == CLFFT_INPLACE )
-            {
-                return CLFFT_INVALID_ARG_VALUE;
-            }
-            else
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-
-                outputBuff.push_back( clOutputBuffers[ 0 ] );
-                outputBuff.push_back( clOutputBuffers[ 1 ] );
-            }
-
-            break;
-        }
-        case CLFFT_HERMITIAN_INTERLEAVED:
-        {
-            if( fftPlan->placeness == CLFFT_INPLACE )
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-            }
-            else
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-                outputBuff.push_back( clOutputBuffers[ 0 ] );
-            }
-
-            break;
-        }
-        case CLFFT_HERMITIAN_PLANAR:
-        {
-            if( fftPlan->placeness == CLFFT_INPLACE )
-            {
-                return CLFFT_INVALID_ARG_VALUE;
-            }
-            else
-            {
-                inputBuff.push_back( clInputBuffers[ 0 ] );
-
-                outputBuff.push_back( clOutputBuffers[ 0 ] );
-                outputBuff.push_back( clOutputBuffers[ 1 ] );
-            }
-
-            break;
-        }
-        default:
-        {
+
+	// 1d with normal length will fall into the below category
+	// add: 2d transpose kernel will fall into here too.
+	inputBuff.reserve( 2 );
+	outputBuff.reserve( 2 );
+
+	//	Decode the relevant properties from the plan paramter to figure out how many input/output buffers we have
+	switch( fftPlan->inputLayout )
+	{
+	case CLFFT_COMPLEX_INTERLEAVED:
+	{
+		switch( fftPlan->outputLayout )
+		{
+		case CLFFT_COMPLEX_INTERLEAVED:
+		{
+			if( fftPlan->placeness == CLFFT_INPLACE )
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+			}
+			else
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+				outputBuff.push_back( clOutputBuffers[ 0 ] );
+			}
+
+			break;
+		}
+		case CLFFT_COMPLEX_PLANAR:
+		{
+			if( fftPlan->placeness == CLFFT_INPLACE )
+			{
+				//	Invalid to be an inplace transform, and go from 1 to 2 buffers
+				return CLFFT_INVALID_ARG_VALUE;
+			}
+			else
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+
+				outputBuff.push_back( clOutputBuffers[ 0 ] );
+				outputBuff.push_back( clOutputBuffers[ 1 ] );
+			}
+
+			break;
+		}
+		case CLFFT_HERMITIAN_INTERLEAVED:
+		{
+			if( fftPlan->placeness == CLFFT_INPLACE )
+			{
+				return CLFFT_INVALID_ARG_VALUE;
+			}
+			else
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+				outputBuff.push_back( clOutputBuffers[ 0 ] );
+			}
+
+			break;
+		}
+		case CLFFT_HERMITIAN_PLANAR:
+		{
+			if( fftPlan->placeness == CLFFT_INPLACE )
+			{
+				return CLFFT_INVALID_ARG_VALUE;
+			}
+			else
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+
+				outputBuff.push_back( clOutputBuffers[ 0 ] );
+				outputBuff.push_back( clOutputBuffers[ 1 ] );
+			}
+
+			break;
+		}
+		case CLFFT_REAL:
+		{
+			if( fftPlan->placeness == CLFFT_INPLACE )
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+			}
+			else
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+				outputBuff.push_back( clOutputBuffers[ 0 ] );
+			}
+
+			break;
+		}
+		default:
+		{
+			//	Don't recognize output layout
+			return CLFFT_INVALID_ARG_VALUE;
+		}
+		}
+
+		break;
+	}
+	case CLFFT_COMPLEX_PLANAR:
+	{
+		switch( fftPlan->outputLayout )
+		{
+		case CLFFT_COMPLEX_INTERLEAVED:
+		{
+			if( fftPlan->placeness == CLFFT_INPLACE )
+			{
+				return CLFFT_INVALID_ARG_VALUE;
+			}
+			else
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+				inputBuff.push_back( clInputBuffers[ 1 ] );
+
+				outputBuff.push_back( clOutputBuffers[ 0 ] );
+			}
+
+			break;
+		}
+		case CLFFT_COMPLEX_PLANAR:
+		{
+			if( fftPlan->placeness == CLFFT_INPLACE )
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+				inputBuff.push_back( clInputBuffers[ 1 ] );
+			}
+			else
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+				inputBuff.push_back( clInputBuffers[ 1 ] );
+
+				outputBuff.push_back( clOutputBuffers[ 0 ] );
+				outputBuff.push_back( clOutputBuffers[ 1 ] );
+			}
+
+			break;
+		}
+		case CLFFT_HERMITIAN_INTERLEAVED:
+		{
+			if( fftPlan->placeness == CLFFT_INPLACE )
+			{
+				return CLFFT_INVALID_ARG_VALUE;
+			}
+			else
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+				inputBuff.push_back( clInputBuffers[ 1 ] );
+
+				outputBuff.push_back( clOutputBuffers[ 0 ] );
+			}
+
+			break;
+		}
+		case CLFFT_HERMITIAN_PLANAR:
+		{
+			if( fftPlan->placeness == CLFFT_INPLACE )
+			{
+				return CLFFT_INVALID_ARG_VALUE;
+			}
+			else
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+				inputBuff.push_back( clInputBuffers[ 1 ] );
+
+				outputBuff.push_back( clOutputBuffers[ 0 ] );
+				outputBuff.push_back( clOutputBuffers[ 1 ] );
+			}
+
+			break;
+		}
+		case CLFFT_REAL:
+		{
+			if( fftPlan->placeness == CLFFT_INPLACE )
+			{
+				return CLFFT_INVALID_ARG_VALUE;
+			}
+			else
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+				inputBuff.push_back( clInputBuffers[ 1 ] );
+
+				outputBuff.push_back( clOutputBuffers[ 0 ] );
+			}
+
+			break;
+		}
+		default:
+		{
+			//	Don't recognize output layout
+			return CLFFT_INVALID_ARG_VALUE;
+		}
+		}
+
+		break;
+	}
+	case CLFFT_HERMITIAN_INTERLEAVED:
+	{
+		switch( fftPlan->outputLayout )
+		{
+		case CLFFT_COMPLEX_INTERLEAVED:
+		{
+			if( fftPlan->placeness == CLFFT_INPLACE )
+			{
+				return CLFFT_INVALID_ARG_VALUE;
+			}
+			else
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+				outputBuff.push_back( clOutputBuffers[ 0 ] );
+			}
+
+			break;
+		}
+		case CLFFT_COMPLEX_PLANAR:
+		{
+			if( fftPlan->placeness == CLFFT_INPLACE )
+			{
+				return CLFFT_INVALID_ARG_VALUE;
+			}
+			else
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+
+				outputBuff.push_back( clOutputBuffers[ 0 ] );
+				outputBuff.push_back( clOutputBuffers[ 1 ] );
+			}
+
+			break;
+		}
+		case CLFFT_HERMITIAN_INTERLEAVED:
+		{
+			return CLFFT_INVALID_ARG_VALUE;
+		}
+		case CLFFT_HERMITIAN_PLANAR:
+		{
+			return CLFFT_INVALID_ARG_VALUE;
+		}
+		case CLFFT_REAL:
+		{
+			if( fftPlan->placeness == CLFFT_INPLACE )
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+			}
+			else
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+				outputBuff.push_back( clOutputBuffers[ 0 ] );
+			}
+
+			break;
+		}
+		default:
+		{
+			//	Don't recognize output layout
+			return CLFFT_INVALID_ARG_VALUE;
+		}
+		}
+
+		break;
+	}
+	case CLFFT_HERMITIAN_PLANAR:
+	{
+		switch( fftPlan->outputLayout )
+		{
+		case CLFFT_COMPLEX_INTERLEAVED:
+		{
+			if( fftPlan->placeness == CLFFT_INPLACE )
+			{
+				return CLFFT_INVALID_ARG_VALUE;
+			}
+			else
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+				inputBuff.push_back( clInputBuffers[ 1 ] );
+
+				outputBuff.push_back( clOutputBuffers[ 0 ] );
+			}
+
+			break;
+		}
+		case CLFFT_COMPLEX_PLANAR:
+		{
+			if( fftPlan->placeness == CLFFT_INPLACE )
+			{
+				return CLFFT_INVALID_ARG_VALUE;
+			}
+			else
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+				inputBuff.push_back( clInputBuffers[ 1 ] );
+
+				outputBuff.push_back( clOutputBuffers[ 0 ] );
+				outputBuff.push_back( clOutputBuffers[ 1 ] );
+			}
+
+			break;
+		}
+		case CLFFT_HERMITIAN_INTERLEAVED:
+		{
+			return CLFFT_INVALID_ARG_VALUE;
+		}
+		case CLFFT_HERMITIAN_PLANAR:
+		{
+			return CLFFT_INVALID_ARG_VALUE;
+		}
+		case CLFFT_REAL:
+		{
+			if( fftPlan->placeness == CLFFT_INPLACE )
+			{
+				return CLFFT_INVALID_ARG_VALUE;
+			}
+			else
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+				inputBuff.push_back( clInputBuffers[ 1 ] );
+
+				outputBuff.push_back( clOutputBuffers[ 0 ] );
+			}
+
+			break;
+		}
+		default:
+		{
+			//	Don't recognize output layout
+			return CLFFT_INVALID_ARG_VALUE;
+		}
+		}
+
+		break;
+	}
+	case CLFFT_REAL:
+	{
+		switch( fftPlan->outputLayout )
+		{
+		case CLFFT_COMPLEX_INTERLEAVED:
+		{
+			if( fftPlan->placeness == CLFFT_INPLACE )
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+			}
+			else
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+				outputBuff.push_back( clOutputBuffers[ 0 ] );
+			}
+
+			break;
+		}
+		case CLFFT_COMPLEX_PLANAR:
+		{
+			if( fftPlan->placeness == CLFFT_INPLACE )
+			{
+				return CLFFT_INVALID_ARG_VALUE;
+			}
+			else
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+
+				outputBuff.push_back( clOutputBuffers[ 0 ] );
+				outputBuff.push_back( clOutputBuffers[ 1 ] );
+			}
+
+			break;
+		}
+		case CLFFT_HERMITIAN_INTERLEAVED:
+		{
+			if( fftPlan->placeness == CLFFT_INPLACE )
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+			}
+			else
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+				outputBuff.push_back( clOutputBuffers[ 0 ] );
+			}
+
+			break;
+		}
+		case CLFFT_HERMITIAN_PLANAR:
+		{
+			if( fftPlan->placeness == CLFFT_INPLACE )
+			{
+				return CLFFT_INVALID_ARG_VALUE;
+			}
+			else
+			{
+				inputBuff.push_back( clInputBuffers[ 0 ] );
+
+				outputBuff.push_back( clOutputBuffers[ 0 ] );
+				outputBuff.push_back( clOutputBuffers[ 1 ] );
+			}
+
+			break;
+		}
+		default:
+		{
 			if(fftPlan->transflag)
 			{
 				if( fftPlan->placeness == CLFFT_INPLACE )
 				{
 					return CLFFT_INVALID_ARG_VALUE;
@@ -512,109 +512,109 @@
 			else
 			{
 				//	Don't recognize output layout
 				return CLFFT_INVALID_ARG_VALUE;
 			}
-        }
-        }
+		}
+		}
 
-        break;
-    }
-    default:
-    {
-        //	Don't recognize output layout
-        return CLFFT_INVALID_ARG_VALUE;
-    }
-    }
+		break;
+	}
+	default:
+	{
+		//	Don't recognize output layout
+		return CLFFT_INVALID_ARG_VALUE;
+	}
+	}
 
-    return CLFFT_SUCCESS;
+	return CLFFT_SUCCESS;
 }
 
 
 clfftStatus FFTAction::enqueue(clfftPlanHandle plHandle,
-                               clfftDirection dir,
-                               cl_uint numQueuesAndEvents,
-                               cl_command_queue* commQueues,
-                               cl_uint numWaitEvents,
-                               const cl_event* waitEvents,
-                               cl_event* outEvents,
-                               cl_mem* clInputBuffers,
-                               cl_mem* clOutputBuffers)
+		clfftDirection dir,
+		cl_uint numQueuesAndEvents,
+		cl_command_queue* commQueues,
+		cl_uint numWaitEvents,
+		const cl_event* waitEvents,
+		cl_event* outEvents,
+		cl_mem* clInputBuffers,
+		cl_mem* clOutputBuffers)
 {
-    FFTRepo & fftRepo = FFTRepo::getInstance();
+	FFTRepo & fftRepo = FFTRepo::getInstance();
+
+	std::vector< cl_mem > inputBuff;
+	std::vector< cl_mem > outputBuff;
 
-    std::vector< cl_mem > inputBuff;
-    std::vector< cl_mem > outputBuff;
 
+	clfftStatus status = selectBufferArguments(this->plan,
+			clInputBuffers, clOutputBuffers,
+			inputBuff, outputBuff);
 
-    clfftStatus status = selectBufferArguments(this->plan,
-                                               clInputBuffers, clOutputBuffers,
-                                               inputBuff, outputBuff);
+	if (status != CLFFT_SUCCESS)
+	{
+		return status;
+	}
 
-    if (status != CLFFT_SUCCESS)
-    {
-        return status;
-    }
-    
-    //	TODO:  In the case of length == 1, FFT is a trivial NOP, but we still need to apply the forward and backwards tranforms
-    //	TODO:  Are map lookups expensive to call here?  We can cache a pointer to the cl_program/cl_kernel in the plan
+	//	TODO:  In the case of length == 1, FFT is a trivial NOP, but we still need to apply the forward and backwards tranforms
+	//	TODO:  Are map lookups expensive to call here?  We can cache a pointer to the cl_program/cl_kernel in the plan
 
-    //	Translate the user plan into the structure that we use to map plans to clPrograms
+	//	Translate the user plan into the structure that we use to map plans to clPrograms
 
-    cl_program	prog;
-    cl_kernel	kern;
+	cl_program	prog;
+	cl_kernel	kern;
 	lockRAII* kernelLock;
-    OPENCL_V( fftRepo.getclProgram( this->getGenerator(), this->getSignatureData(), prog, this->plan->bakeDevice, this->plan->context ), _T( "fftRepo.getclProgram failed" ) );
-    OPENCL_V( fftRepo.getclKernel( prog, dir, kern, kernelLock), _T( "fftRepo.getclKernels failed" ) );
+	OPENCL_V( fftRepo.getclProgram( this->getGenerator(), this->getSignatureData(), prog, this->plan->bakeDevice, this->plan->context ), _T( "fftRepo.getclProgram failed" ) );
+	OPENCL_V( fftRepo.getclKernel( prog, dir, kern, kernelLock), _T( "fftRepo.getclKernels failed" ) );
 
 	scopedLock sLock(*kernelLock, _T("FFTAction::enqueue"));
 
-    cl_uint uarg = 0;
-    if (!this->plan->transflag && !(this->plan->gen == Copy))
-    {
-        //	::clSetKernelArg() is not thread safe, according to the openCL spec for the same cl_kernel object
-        //	TODO:  Need to verify that two different plans (which would get through our lock above) with exactly the same
-        //	parameters would NOT share the same cl_kernel objects
-
-        /* constant buffer */
-        OPENCL_V( clSetKernelArg( kern, uarg++, sizeof( cl_mem ), (void*)&this->plan->const_buffer ), _T( "clSetKernelArg failed" ) );
-    }
-
-    //	Input buffer(s)
-    //	Input may be 1 buffer  (CLFFT_COMPLEX_INTERLEAVED)
-    //	          or 2 buffers (CLFFT_COMPLEX_PLANAR)
-
-    for (size_t i = 0; i < inputBuff.size(); ++i)
-    {
-        OPENCL_V( clSetKernelArg( kern, uarg++, sizeof( cl_mem ), (void*)&inputBuff[i] ), _T( "clSetKernelArg failed" ) );
-    }
-    //	Output buffer(s)
-    //	Output may be 0 buffers (CLFFT_INPLACE)
-    //	           or 1 buffer  (CLFFT_COMPLEX_INTERLEAVED)
-    //	           or 2 buffers (CLFFT_COMPLEX_PLANAR)
-    for (size_t o = 0; o < outputBuff.size(); ++o)
-    {
-        OPENCL_V( clSetKernelArg( kern, uarg++, sizeof( cl_mem ), (void*)&outputBuff[o] ), _T( "clSetKernelArg failed" ) );
-    }
+	cl_uint uarg = 0;
+	if (!this->plan->transflag && !(this->plan->gen == Copy))
+	{
+		//	::clSetKernelArg() is not thread safe, according to the openCL spec for the same cl_kernel object
+		//	TODO:  Need to verify that two different plans (which would get through our lock above) with exactly the same
+		//	parameters would NOT share the same cl_kernel objects
+
+		/* constant buffer */
+		OPENCL_V( clSetKernelArg( kern, uarg++, sizeof( cl_mem ), (void*)&this->plan->const_buffer ), _T( "clSetKernelArg failed" ) );
+	}
+
+	//	Input buffer(s)
+	//	Input may be 1 buffer  (CLFFT_COMPLEX_INTERLEAVED)
+	//	          or 2 buffers (CLFFT_COMPLEX_PLANAR)
+
+	for (size_t i = 0; i < inputBuff.size(); ++i)
+	{
+		OPENCL_V( clSetKernelArg( kern, uarg++, sizeof( cl_mem ), (void*)&inputBuff[i] ), _T( "clSetKernelArg failed" ) );
+	}
+	//	Output buffer(s)
+	//	Output may be 0 buffers (CLFFT_INPLACE)
+	//	           or 1 buffer  (CLFFT_COMPLEX_INTERLEAVED)
+	//	           or 2 buffers (CLFFT_COMPLEX_PLANAR)
+	for (size_t o = 0; o < outputBuff.size(); ++o)
+	{
+		OPENCL_V( clSetKernelArg( kern, uarg++, sizeof( cl_mem ), (void*)&outputBuff[o] ), _T( "clSetKernelArg failed" ) );
+	}
 
 	//If callback function is set for the plan, pass the appropriate aruments
 	if (this->plan->hasPreCallback || this->plan->hasPostCallback)
 	{
-	if (this->plan->hasPreCallback)
-	{
-		OPENCL_V( clSetKernelArg( kern, uarg++, sizeof( cl_mem ), (void*)&this->plan->precallUserData ), _T( "clSetKernelArg failed" ) );
+		if (this->plan->hasPreCallback)
+		{
+			OPENCL_V( clSetKernelArg( kern, uarg++, sizeof( cl_mem ), (void*)&this->plan->precallUserData ), _T( "clSetKernelArg failed" ) );
 		}
 
 		//If post-callback function is set for the plan, pass the appropriate aruments
 		if (this->plan->hasPostCallback)
 		{
 			OPENCL_V( clSetKernelArg( kern, uarg++, sizeof( cl_mem ), (void*)&this->plan->postcallUserData ), _T( "clSetKernelArg failed" ) );
 		}
 
 		//Pass LDS size arument if set
 		if ((this->plan->hasPreCallback && this->plan->preCallback.localMemSize > 0) || 
-			(this->plan->hasPostCallback && this->plan->postCallbackParam.localMemSize > 0))
+				(this->plan->hasPostCallback && this->plan->postCallbackParam.localMemSize > 0))
 		{
 			int localmemSize = 0;
 			if (this->plan->hasPreCallback && this->plan->preCallback.localMemSize > 0)
 				localmemSize = this->plan->preCallback.localMemSize;
 			if (this->plan->hasPostCallback && this->plan->postCallbackParam.localMemSize > 0)
@@ -622,75 +622,77 @@
 
 			OPENCL_V( clSetKernelArg( kern, uarg++, localmemSize, NULL ), _T( "clSetKernelArg failed" ) );
 		}
 	}
 
-    std::vector< size_t > gWorkSize;
-    std::vector< size_t > lWorkSize;
-    clfftStatus result = this->getWorkSizes (gWorkSize, lWorkSize);
+	OPENCL_V( clSetKernelArg( kern, uarg++, sizeof(int), (void*)&this->plan->offsetIn ), _T( "clSetKernelArg failed" ) );
+	OPENCL_V( clSetKernelArg( kern, uarg++, sizeof(int), (void*)&this->plan->offsetOut ), _T( "clSetKernelArg failed" ) );
+
+	std::vector< size_t > gWorkSize;
+	std::vector< size_t > lWorkSize;
+	clfftStatus result = this->getWorkSizes (gWorkSize, lWorkSize);
 	//std::cout << "work sizes are " << gWorkSize[0] << ", " << lWorkSize[0] << std::endl;
 	/*
 	std::cout << "work sizes are ";
 	for (auto itor = gWorkSize.begin(); itor != gWorkSize.end(); itor++)
 		std::cout << *itor << " ";
 	std::cout << ", ";
 	for (auto itor = lWorkSize.begin(); itor != lWorkSize.end(); itor++)
 		std::cout << *itor << " ";
 	std::cout << std::endl;
-	*/
-    // TODO:  if getWorkSizes returns CLFFT_INVALID_GLOBAL_WORK_SIZE, that means
-    // that this multidimensional input data array is too large to be transformed
-    // with a single call to clEnqueueNDRangeKernel.  For now, we will just return
-    // the error code back up the call stack.
-    // The *correct* course of action would be to split the work into mutliple
-    // calls to clEnqueueNDRangeKernel.
-    if (CLFFT_INVALID_GLOBAL_WORK_SIZE == result)
-    {
-        OPENCL_V( result, _T("Work size too large for clEnqueNDRangeKernel()"));
-    }
-    else
-    {
-        OPENCL_V( result, _T("FFTAction::getWorkSizes failed"));
-    }
-    BUG_CHECK (gWorkSize.size() == lWorkSize.size());
-
-
-    cl_int call_status = clEnqueueNDRangeKernel( *commQueues, kern, static_cast< cl_uint >( gWorkSize.size( ) ),
-                                            NULL, &gWorkSize[ 0 ],  &lWorkSize[ 0 ], numWaitEvents, waitEvents, outEvents );
-    OPENCL_V( call_status, _T( "clEnqueueNDRangeKernel failed" ) );
-
-    if( fftRepo.pStatTimer )
-    {
-        fftRepo.pStatTimer->AddSample( plHandle, this->plan, kern, numQueuesAndEvents, outEvents, gWorkSize, lWorkSize );
-    }
+	 */
+	// TODO:  if getWorkSizes returns CLFFT_INVALID_GLOBAL_WORK_SIZE, that means
+	// that this multidimensional input data array is too large to be transformed
+	// with a single call to clEnqueueNDRangeKernel.  For now, we will just return
+	// the error code back up the call stack.
+	// The *correct* course of action would be to split the work into mutliple
+	// calls to clEnqueueNDRangeKernel.
+	if (CLFFT_INVALID_GLOBAL_WORK_SIZE == result)
+	{
+		OPENCL_V( result, _T("Work size too large for clEnqueNDRangeKernel()"));
+	}
+	else
+	{
+		OPENCL_V( result, _T("FFTAction::getWorkSizes failed"));
+	}
+	BUG_CHECK (gWorkSize.size() == lWorkSize.size());
+
+	cl_int call_status = clEnqueueNDRangeKernel( *commQueues, kern, static_cast< cl_uint >( gWorkSize.size( ) ),
+			NULL, &gWorkSize[ 0 ],  &lWorkSize[ 0 ], numWaitEvents, waitEvents, outEvents );
+	OPENCL_V( call_status, _T( "clEnqueueNDRangeKernel failed" ) );
+
+	if( fftRepo.pStatTimer )
+	{
+		fftRepo.pStatTimer->AddSample( plHandle, this->plan, kern, numQueuesAndEvents, outEvents, gWorkSize, lWorkSize );
+	}
 
-    return CLFFT_SUCCESS;
+	return CLFFT_SUCCESS;
 }
 
 
 
 //	Read the kernels that this plan uses from file, and store into the plan
 clfftStatus FFTAction::writeKernel( const clfftPlanHandle plHandle, const clfftGenerators gen, const FFTKernelSignatureHeader* data, const cl_context& context, const cl_device_id &device )
 {
-    FFTRepo& fftRepo	= FFTRepo::getInstance( );
+	FFTRepo& fftRepo	= FFTRepo::getInstance( );
 
-    std::string kernelPath = getKernelName(gen, plHandle, true);
+	std::string kernelPath = getKernelName(gen, plHandle, true);
 
-    //	Logic to write string contents out to file
-    tofstreamRAII< std::ofstream, std::string > kernelFile( kernelPath.c_str( ) );
-    if( !kernelFile.get( ) )
-    {
-        std::cerr << "Failed to open kernel file for writing: " << kernelPath.c_str( ) << std::endl;
-        return CLFFT_FILE_CREATE_FAILURE;
-    }
+	//	Logic to write string contents out to file
+	tofstreamRAII< std::ofstream, std::string > kernelFile( kernelPath.c_str( ) );
+	if( !kernelFile.get( ) )
+	{
+		std::cerr << "Failed to open kernel file for writing: " << kernelPath.c_str( ) << std::endl;
+		return CLFFT_FILE_CREATE_FAILURE;
+	}
 
-    std::string kernel;
-    OPENCL_V( fftRepo.getProgramCode( gen, data, kernel, device, context ), _T( "fftRepo.getProgramCode failed." ) );
+	std::string kernel;
+	OPENCL_V( fftRepo.getProgramCode( gen, data, kernel, device, context ), _T( "fftRepo.getProgramCode failed." ) );
 
-    kernelFile.get( ) << kernel << std::endl;
+	kernelFile.get( ) << kernel << std::endl;
 
-    return	CLFFT_SUCCESS;
+	return	CLFFT_SUCCESS;
 }
 
 
 // **************** TODO TODO TODO ***********************
 // Making compileKernels function take in command queue parameter so we can build for 1 particular device only;
@@ -698,133 +700,133 @@
 // make changes appropriately before enabling persistent plans and then remove this comment
 
 //	Compile the kernels that this plan uses, and store into the plan
 clfftStatus FFTAction::compileKernels( const cl_command_queue commQueueFFT, const clfftPlanHandle plHandle, FFTPlan* fftPlan )
 {
-    cl_int status = 0;
-    size_t deviceListSize = 0;
+	cl_int status = 0;
+	size_t deviceListSize = 0;
 
-    FFTRepo& fftRepo	= FFTRepo::getInstance( );
+	FFTRepo& fftRepo	= FFTRepo::getInstance( );
 
-    // create a cl program executable for the device associated with command queue
-    // Get the device
-    cl_device_id &q_device = fftPlan->bakeDevice;
+	// create a cl program executable for the device associated with command queue
+	// Get the device
+	cl_device_id &q_device = fftPlan->bakeDevice;
 
-    cl_program program;
-    if( fftRepo.getclProgram( this->getGenerator(), this->getSignatureData(), program, q_device, fftPlan->context ) == CLFFT_INVALID_PROGRAM )
-    {
-        FFTBinaryLookup lookup (this->getGenerator(), plHandle, fftPlan->context, q_device);
+	cl_program program;
+	if( fftRepo.getclProgram( this->getGenerator(), this->getSignatureData(), program, q_device, fftPlan->context ) == CLFFT_INVALID_PROGRAM )
+	{
+		FFTBinaryLookup lookup (this->getGenerator(), plHandle, fftPlan->context, q_device);
 
-        lookup.variantRaw(this->getSignatureData(), this->getSignatureData()->datasize);
+		lookup.variantRaw(this->getSignatureData(), this->getSignatureData()->datasize);
 
-        if (lookup.found())
-        {
+		if (lookup.found())
+		{
 #if FFT_CACHE_DEBUG
-            // debug message in debug mode to ensure that the cache is used
-            fprintf(stderr, "Kernel loaded from cache\n");
+			// debug message in debug mode to ensure that the cache is used
+			fprintf(stderr, "Kernel loaded from cache\n");
 #endif
 
-            program = lookup.getProgram();
-        }
-        else
-        {
+			program = lookup.getProgram();
+		}
+		else
+		{
 #if FFT_CACHE_DEBUG
-            fprintf(stderr, "Kernel built from source\n");
+			fprintf(stderr, "Kernel built from source\n");
 #endif
 
-            //	If the user wishes us to write the kernels out to disk, we do so
-            if( fftRepo.setupData.debugFlags & CLFFT_DUMP_PROGRAMS )
-            {
-				OPENCL_V( writeKernel( plHandle, this->getGenerator(), this->getSignatureData(), fftPlan->context, fftPlan->bakeDevice ), _T( "writeKernel failed." ) );
-            }
-
-            std::string programCode;
-            OPENCL_V( fftRepo.getProgramCode( this->getGenerator(), this->getSignatureData(), programCode, q_device, fftPlan->context  ), _T( "fftRepo.getProgramCode failed." ) );
-
-            const char* source = programCode.c_str();
-            program = clCreateProgramWithSource( fftPlan->context, 1, &source, NULL, &status );
-            OPENCL_V( status, _T( "clCreateProgramWithSource failed." ) );
+			//	If the user wishes us to write the kernels out to disk, we do so
+			//if( fftRepo.setupData.debugFlags & CLFFT_DUMP_PROGRAMS )
+			//{
+			OPENCL_V( writeKernel( plHandle, this->getGenerator(), this->getSignatureData(), fftPlan->context, fftPlan->bakeDevice ), _T( "writeKernel failed." ) );
+			//}
+
+			std::string programCode;
+			OPENCL_V( fftRepo.getProgramCode( this->getGenerator(), this->getSignatureData(), programCode, q_device, fftPlan->context  ), _T( "fftRepo.getProgramCode failed." ) );
+
+			const char* source = programCode.c_str();
+			program = clCreateProgramWithSource( fftPlan->context, 1, &source, NULL, &status );
+			OPENCL_V( status, _T( "clCreateProgramWithSource failed." ) );
 
-            // create a cl program executable for the device associated with command queue
+			// create a cl program executable for the device associated with command queue
 
 #if defined(DEBUGGING)
-            status = clBuildProgram( program, 1, &q_device, "-g -cl-opt-disable", NULL, NULL); // good for debugging kernels
+			status = clBuildProgram( program, 1, &q_device, "-g -cl-opt-disable", NULL, NULL); // good for debugging kernels
 
-// if you have trouble creating smbols that GDB can pick up to set a breakpoint after kernels are loaded into memory
-// this can be used to stop execution to allow you to set a breakpoint in a kernel after kernel symbols are in memory.
+			// if you have trouble creating smbols that GDB can pick up to set a breakpoint after kernels are loaded into memory
+			// this can be used to stop execution to allow you to set a breakpoint in a kernel after kernel symbols are in memory.
 #ifdef DEBUG_BREAK_GDB
-            __debugbreak();
+			__debugbreak();
 #endif
 #else
-            status = clBuildProgram( program, 1, &q_device, "", NULL, NULL);
+			status = clBuildProgram( program, 1, &q_device, "", NULL, NULL);
 #endif
-            if( status != CL_SUCCESS )
-            {
-                if( status == CL_BUILD_PROGRAM_FAILURE )
-                {
-                    size_t buildLogSize = 0;
-                    OPENCL_V( clGetProgramBuildInfo( program, q_device, CL_PROGRAM_BUILD_LOG, 0, NULL, &buildLogSize ),
-                              _T( "clGetProgramBuildInfo failed" ) );
-
-                    std::vector< char > buildLog( buildLogSize );
-                    ::memset( &buildLog[ 0 ], 0x0, buildLogSize );
-
-                    OPENCL_V( clGetProgramBuildInfo( program, q_device, CL_PROGRAM_BUILD_LOG, buildLogSize, &buildLog[ 0 ], NULL ),
-                              _T( "clGetProgramBuildInfo failed" ) );
-
-                    std::cerr << "\n\t\t\tBUILD LOG\n";
-                    std::cerr << "************************************************\n";
-                    std::cerr << &buildLog[ 0 ] << std::endl;
-                    std::cerr << "************************************************\n";
-                }
-
-                OPENCL_V( status, _T( "clBuildProgram failed" ) );
-            }
-
-            lookup.setProgram(program, source);
-            lookup.populateCache();
-        }
-
-        fftRepo.setclProgram( this->getGenerator(), this->getSignatureData(), program, q_device, fftPlan->context );
-
-
-        // For real transforms we compile either forward or backward kernel
-        bool buildFwdKernel = buildForwardKernel();
-        bool buildBwdKernel = buildBackwardKernel();
-
-        // get a kernel object handle for a kernel with the given name
-        cl_kernel kernel;
-        if( buildFwdKernel )
-        {
+			if( status != CL_SUCCESS )
+			{
+				if( status == CL_BUILD_PROGRAM_FAILURE )
+				{
+					size_t buildLogSize = 0;
+					OPENCL_V( clGetProgramBuildInfo( program, q_device, CL_PROGRAM_BUILD_LOG, 0, NULL, &buildLogSize ),
+							_T( "clGetProgramBuildInfo failed" ) );
+
+					std::vector< char > buildLog( buildLogSize );
+					::memset( &buildLog[ 0 ], 0x0, buildLogSize );
+
+					OPENCL_V( clGetProgramBuildInfo( program, q_device, CL_PROGRAM_BUILD_LOG, buildLogSize, &buildLog[ 0 ], NULL ),
+							_T( "clGetProgramBuildInfo failed" ) );
+
+					std::cerr << "\n\t\t\tBUILD LOG\n";
+					std::cerr << "************************************************\n";
+					std::cerr << &buildLog[ 0 ] << std::endl;
+					std::cerr << "************************************************\n";
+				}
+
+				OPENCL_V( status, _T( "clBuildProgram failed" ) );
+			}
+
+			lookup.setProgram(program, source);
+			lookup.populateCache();
+		}
+
+		fftRepo.setclProgram( this->getGenerator(), this->getSignatureData(), program, q_device, fftPlan->context );
+
+
+		// For real transforms we compile either forward or backward kernel
+		bool buildFwdKernel = buildForwardKernel();
+		bool buildBwdKernel = buildBackwardKernel();
+
+		// get a kernel object handle for a kernel with the given name
+		cl_kernel kernel;
+		if( buildFwdKernel )
+		{
 			lockRAII *kernelLock;
-            if( fftRepo.getclKernel( program, CLFFT_FORWARD, kernel, kernelLock) == CLFFT_INVALID_KERNEL )
-            {
-                std::string entryPoint;
-                OPENCL_V( fftRepo.getProgramEntryPoint( this->getGenerator(), this->getSignatureData(), CLFFT_FORWARD, entryPoint, q_device, fftPlan->context ), _T( "fftRepo.getProgramEntryPoint failed." ) );
-
-                kernel = clCreateKernel( program, entryPoint.c_str( ), &status );
-                OPENCL_V( status, _T( "clCreateKernel failed" ) );
-
-                fftRepo.setclKernel( program, CLFFT_FORWARD, kernel );
-            }
-        }
+			if( fftRepo.getclKernel( program, CLFFT_FORWARD, kernel, kernelLock) == CLFFT_INVALID_KERNEL )
+			{
+				std::string entryPoint;
+				OPENCL_V( fftRepo.getProgramEntryPoint( this->getGenerator(), this->getSignatureData(), CLFFT_FORWARD, entryPoint, q_device, fftPlan->context ), _T( "fftRepo.getProgramEntryPoint failed." ) );
+
+				kernel = clCreateKernel( program, entryPoint.c_str( ), &status );
+				OPENCL_V( status, _T( "clCreateKernel failed" ) );
+
+				fftRepo.setclKernel( program, CLFFT_FORWARD, kernel );
+			}
+		}
 
-        if( buildBwdKernel )
-        {
+		if( buildBwdKernel )
+		{
 			lockRAII *kernelLock;
-            if( fftRepo.getclKernel( program, CLFFT_BACKWARD, kernel, kernelLock ) == CLFFT_INVALID_KERNEL )
-            {
-                std::string entryPoint;
-                OPENCL_V( fftRepo.getProgramEntryPoint( this->getGenerator(), this->getSignatureData(), CLFFT_BACKWARD, entryPoint, q_device, fftPlan->context ), _T( "fftRepo.getProgramEntryPoint failed." ) );
-
-                kernel = clCreateKernel( program, entryPoint.c_str( ), &status );
-                OPENCL_V( status, _T( "clCreateKernel failed" ) );
-
-                fftRepo.setclKernel( program, CLFFT_BACKWARD, kernel );
-            }
-        }
-    }
+			if( fftRepo.getclKernel( program, CLFFT_BACKWARD, kernel, kernelLock ) == CLFFT_INVALID_KERNEL )
+			{
+				std::string entryPoint;
+				OPENCL_V( fftRepo.getProgramEntryPoint( this->getGenerator(), this->getSignatureData(), CLFFT_BACKWARD, entryPoint, q_device, fftPlan->context ), _T( "fftRepo.getProgramEntryPoint failed." ) );
+
+				kernel = clCreateKernel( program, entryPoint.c_str( ), &status );
+				OPENCL_V( status, _T( "clCreateKernel failed" ) );
+
+				fftRepo.setclKernel( program, CLFFT_BACKWARD, kernel );
+			}
+		}
+	}
 
-    return	CLFFT_SUCCESS;
+	return	CLFFT_SUCCESS;
 }
 
 
diff -Naru5 clFFT.old/src/library/generator.stockham.cpp clFFT/src/library/generator.stockham.cpp
--- clFFT.old/src/library/generator.stockham.cpp	2020-11-04 16:35:17.425724470 +0000
+++ clFFT/src/library/generator.stockham.cpp	2020-11-04 16:48:27.209671041 +0000
@@ -2784,10 +2784,13 @@
     {
         size_t length;							// Length of FFT
         size_t workGroupSize;					// Work group size
 		size_t cnPerWI;							// complex numbers per work-item
 
+		size_t offsetIn;
+		size_t offsetOut;
+
 		size_t numTrans;						// Number of transforms per work-group
 		size_t workGroupSizePerTrans;			// Work group subdivision per transform
 		size_t numPasses;						// Number of FFT passes
         std::vector<size_t> radices;			// Base radix at each pass
         std::vector<Pass<PR> > passes;			// Array of pass objects
@@ -2919,10 +2922,15 @@
 				else				{	batch += "(batch*"; batch += SztToStr(numTrans);
 										batch += " + (me/"; batch += SztToStr(workGroupSizePerTrans); batch += "))"; }
 			}
 
 			str += "\t"; str += off; str += " = ";
+
+			str += " ";
+			str += input ? "offsetIn" : "offsetOut";
+			str += " + ";
+
 			std::string nextBatch = batch;
 			for(size_t i=(params.fft_DataDim - 1); i>1; i--)
 			{
 				size_t currentLength = 1;
 				for(int j=1; j<i; j++) currentLength *= params.fft_N[j];
@@ -2942,10 +2950,14 @@
         Kernel( const FFTKernelGenKeyParams &paramsVal) :
 			params(paramsVal), r2c2r(false)
 
         {
 			length = params.fft_N[0];
+
+			offsetIn = params.fft_offsetIn;
+			offsetIn = params.fft_offsetOut;
+
 			workGroupSize = params.fft_SIMD;
 			numTrans = (workGroupSize * params.fft_R) / length;
 
 			r2c = false;
 			c2r = false;
@@ -3473,15 +3485,16 @@
         clGetDeviceInfo(Dev_ID, CL_DEVICE_VENDOR, 0, NULL, &SizeParam_ret);
         char* nameVendor = new char[SizeParam_ret];
         clGetDeviceInfo(Dev_ID, CL_DEVICE_VENDOR, SizeParam_ret, nameVendor, NULL);
 
         //nv compiler doesn't support __constant kernel argument
+        // TODO : works with CUDA 10.0, so might not be true anymore
         if (strncmp(nameVendor, "NVIDIA",6)!=0)
           str += "__constant cb_t *cb __attribute__((max_constant_size(32))), ";
         else
           str += "__global cb_t *cb, ";
-
+       // str += "__constant cb_t *cb __attribute__((max_constant_size(32))), ";
         delete [] nameVendor;
 
 		//If plan has pre/post callback
 		callbackstr.clear();
 		bool hasCallback = params.fft_hasPreCallback || params.fft_hasPostCallback;
@@ -3500,11 +3513,10 @@
 			if (params.fft_preCallback.localMemSize > 0 || params.fft_postCallback.localMemSize > 0)
 			{
 				callbackstr += ", __local void* localmem";
 			}
 		}
-
 				// Function attributes
 				if(params.fft_placeness == CLFFT_INPLACE)
 				{
 					if(r2c2r)
 					{
@@ -3514,49 +3526,25 @@
 						}
 						else
 						{
 							str += "__global "; str += rType; str += " * restrict gb";
 						}
-
-						//If plan has callback
-						if (hasCallback)
-						{
-							str += callbackstr;
-						}
-
-						str += ")\n";
 					}
 					else
 					{
 						assert(inInterleaved == outInterleaved);
 						assert(params.fft_inStride[1] == params.fft_outStride[1]);
 						assert(params.fft_inStride[0] == params.fft_outStride[0]);
 
 						if(inInterleaved)
 						{
 							str += "__global "; str += r2Type; str += " * restrict gb";
-
-							//If plan has callback
-							if (hasCallback)
-							{
-								str += callbackstr;
-							}
-							
-							str += ")\n";
 						}
 						else
 						{
 							str += "__global "; str += rType; str += " * restrict gbRe, ";
 							str += "__global "; str += rType; str += " * restrict gbIm";
-
-							//If plan has callback
-							if (hasCallback)
-							{
-								str += callbackstr;
-							}
-
-							str += ")\n";
 						}
 					}
 				}
 				else
 				{
@@ -3587,18 +3575,10 @@
 						else
 						{
 							str += "__global "; str += rType; str += " * restrict gbOutRe, ";
 							str += "__global "; str += rType; str += " * restrict gbOutIm";
 						}
-
-						//If plan has callback
-						if (hasCallback)
-						{
-							str += callbackstr;
-						}
-
-						str += ")\n";
 					}
 					else
 					{
 						if(inInterleaved)
 						{
@@ -3617,21 +3597,21 @@
 						else
 						{
 							str += "__global "; str += rType; str += " * restrict gbOutRe, ";
 							str += "__global "; str += rType; str += " * restrict gbOutIm";
 						}
-
-						//If plan has callback
-						if (hasCallback)
-						{
-							str += callbackstr;
-						}
-
-						str += ")\n";
 					}
 				}
 
+				//If plan has callback
+				if (hasCallback)
+				{
+					str += callbackstr;
+				}
+				str += ", const int offsetIn, const int offsetOut ";
+				str += ")\n";
+
 				str += "{\n";
 
 				// Initialize
 				str += "\t";
 				str += "uint me = get_local_id(0);\n\t";
@@ -4487,10 +4467,12 @@
     //            clearing it again would destroy datasize and id!!
     this->signature.fft_precision    = this->plan->precision;
     this->signature.fft_placeness    = this->plan->placeness;
     this->signature.fft_inputLayout  = this->plan->inputLayout;
 	this->signature.fft_MaxWorkGroupSize = this->plan->envelope.limit_WorkGroupSize;
+	this->signature.fft_offsetIn  = this->plan->offsetIn;
+	this->signature.fft_offsetOut  = this->plan->offsetOut;
 
     ARG_CHECK(this->plan->length.size()    > 0);
 	ARG_CHECK(this->plan->inStride.size()  > 0);
     ARG_CHECK(this->plan->outStride.size() > 0);
 
diff -Naru5 clFFT.old/src/library/generator.stockham.cpp.orig clFFT/src/library/generator.stockham.cpp.orig
--- clFFT.old/src/library/generator.stockham.cpp.orig	1970-01-01 00:00:00.000000000 +0000
+++ clFFT/src/library/generator.stockham.cpp.orig	2020-11-04 16:48:27.209671041 +0000
@@ -0,0 +1,4757 @@
+/* ************************************************************************
+ * Copyright 2013 Advanced Micro Devices, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * ************************************************************************/
+
+
+#include "stdafx.h"
+#include <math.h>
+#include "generator.stockham.h"
+#include <list>
+#include "action.h"
+
+
+FFTGeneratedStockhamAction::FFTGeneratedStockhamAction(clfftPlanHandle plHandle, FFTPlan * plan, cl_command_queue queue, clfftStatus & err)
+    : FFTStockhamAction(plHandle, plan, queue, err)
+{
+    if (err != CLFFT_SUCCESS)
+    {
+        // FFTAction() failed, exit
+        fprintf(stderr, "FFTStockhamAction() failed!\n");
+        return;
+    }
+
+    // Initialize the FFTAction::FFTKernelGenKeyParams member
+    err = this->initParams();
+
+    if (err != CLFFT_SUCCESS)
+    {
+        fprintf(stderr, "FFTGeneratedStockhamAction::initParams() failed!\n");
+        return;
+    }
+	
+    FFTRepo &fftRepo = FFTRepo::getInstance();
+
+    err = this->generateKernel(fftRepo, queue);
+
+    if (err != CLFFT_SUCCESS)
+    {
+        fprintf(stderr, "FFTGeneratedStockhamAction::generateKernel failed\n");
+        return;
+    }
+
+	err = compileKernels( queue, plHandle, plan);
+
+    if (err != CLFFT_SUCCESS)
+    {
+        fprintf(stderr, "FFTGeneratedStockhamAction::compileKernels failed\n");
+        return;
+    }
+
+    err = CLFFT_SUCCESS;
+}
+
+bool FFTGeneratedStockhamAction::buildForwardKernel()
+{
+    clfftLayout inputLayout = this->getSignatureData()->fft_inputLayout;
+    clfftLayout outputLayout = this->getSignatureData()->fft_outputLayout;
+
+    bool r2c_transform = (inputLayout == CLFFT_REAL);
+    bool c2r_transform = (outputLayout == CLFFT_REAL);
+    bool real_transform = (r2c_transform || c2r_transform);
+
+    return (!real_transform) || r2c_transform;
+}
+
+bool FFTGeneratedStockhamAction::buildBackwardKernel()
+{
+    clfftLayout inputLayout = this->getSignatureData()->fft_inputLayout;
+    clfftLayout outputLayout = this->getSignatureData()->fft_outputLayout;
+
+    bool r2c_transform = (inputLayout == CLFFT_REAL);
+    bool c2r_transform = (outputLayout == CLFFT_REAL);
+    bool real_transform = (r2c_transform || c2r_transform);
+
+    return (!real_transform) || c2r_transform;
+}
+
+
+// FFT Stockham Autosort Method
+//
+//   Each pass does one digit reverse in essence. Hence by the time all passes are done, complete
+//   digit reversal is done and output FFT is in correct order. Intermediate FFTs are stored in natural order,
+//   which is not the case with basic Cooley-Tukey algorithm. Natural order in intermediate data makes it
+//   convenient for stitching together passes with different radices.
+//
+//  Basic FFT algorithm:
+//
+//        Pass loop
+//        {
+//            Outer loop
+//            {
+//                Inner loop
+//                {
+//                }
+//            }
+//        }
+//
+//  The sweeps of the outer and inner loop resemble matrix indexing, this matrix changes shape with every pass as noted below
+//
+//   FFT pass diagram (radix 2)
+//
+//                k            k+R                                    k
+//            * * * * * * * * * * * * * * * *                     * * * * * * * *
+//            *   |             |           *                     *   |         *
+//            *   |             |           *                     *   |         *
+//            *   |             |           * LS        -->       *   |         *
+//            *   |             |           *                     *   |         *
+//            *   |             |           *                     *   |         *
+//            * * * * * * * * * * * * * * * *                     *   |         *
+//                         RS                                     *   |         * L
+//                                                                *   |         *
+//                                                                *   |         *
+//                                                                *   |         *
+//                                                                *   |         *
+//                                                                *   |         *
+//                                                                *   |         *
+//                                                                *   |         *
+//                                                                * * * * * * * *
+//                                                                       R
+//
+//
+//    With every pass, the matrix doubles in height and halves in length
+//
+//
+//  N = 2^T = Length of FFT
+//  q = pass loop index
+//  k = outer loop index = (0 ... R-1)
+//  j = inner loop index = (0 ... LS-1)
+//
+//  Tables shows how values change as we go through the passes
+//
+//    q | LS   |  R   |  L  | RS
+//   ___|______|______|_____|___
+//    0 |  1   | N/2  |  2  | N
+//    1 |  2   | N/4  |  4  | N/2
+//    2 |  4   | N/8  |  8  | N/4
+//    . |  .   | .    |  .  | .
+//  T-1 |  N/2 | 1    |  N  | 2
+//
+//
+//   Data Read Order
+//     Radix 2: k*LS + j, (k+R)*LS + j
+//     Radix 3: k*LS + j, (k+R)*LS + j, (k+2R)*LS + j
+//     Radix 4: k*LS + j, (k+R)*LS + j, (k+2R)*LS + j, (k+3R)*LS + j
+//     Radix 5: k*LS + j, (k+R)*LS + j, (k+2R)*LS + j, (k+3R)*LS + j, (k+4R)*LS + j
+//
+//   Data Write Order
+//       Radix 2: k*L + j, k*L + j + LS
+//       Radix 3: k*L + j, k*L + j + LS, k*L + j + 2*LS
+//       Radix 4: k*L + j, k*L + j + LS, k*L + j + 2*LS, k*L + j + 3*LS
+//       Radix 5: k*L + j, k*L + j + LS, k*L + j + 2*LS, k*L + j + 3*LS, k*L + j + 4*LS
+//
+
+namespace StockhamGenerator
+{
+	// Experimnetal Start =========================================
+	// Kernel Generator Parameterization ==========================
+
+	// Uncomment this directive to activate parameter reads from file
+//#define PARMETERS_TO_BE_READ
+
+	// Parameters to read
+	struct ParamRead
+	{
+		size_t	workGroupSize;
+		size_t	numTransformsPerWg;
+		std::vector<size_t> radices;
+		bool	halfLds;
+	};
+
+	// File format
+
+	// WorkGroupSize:
+	// TransformsPerWorkGroup:
+	// Radices:
+	// LdsUse:
+
+	void ReadParameterFile(ParamRead &readParam)
+	{
+		const char *fileName = "parameters.txt";
+		std::ifstream file(fileName);
+
+		if(!file.is_open())
+		{
+			std::cout << "File: " << fileName << " could not be opened, exiting ...." << std::endl;
+			exit(-1);
+		}
+
+		std::string strWgs = "WorkGroupSize:";
+		std::string strNtw = "TransformsPerWorkGroup:";
+		std::string strRad = "Radices:";
+		std::string strLds = "LdsUse:";
+		std::string numbers = "0123456789";
+
+		std::string line;
+		while(std::getline(file, line))
+		{
+
+			size_t pos;
+
+			pos = line.find(strWgs);
+			if(pos != std::string::npos)
+			{
+				line.erase(pos, strWgs.length());
+				size_t numStart	= line.find_first_of(numbers);
+				size_t numEnd	= line.find_first_not_of(numbers, numStart);
+				std::string val = line.substr(numStart, numEnd-numStart);
+				readParam.workGroupSize = strtol(val.c_str(), NULL, 10);
+				continue;
+			}
+
+			pos = line.find(strNtw);
+			if(pos != std::string::npos)
+			{
+				line.erase(pos, strNtw.length());
+				size_t numStart	= line.find_first_of(numbers);
+				size_t numEnd	= line.find_first_not_of(numbers, numStart);
+				std::string val = line.substr(numStart, numEnd-numStart);
+				readParam.numTransformsPerWg = strtol(val.c_str(), NULL, 10);
+				continue;
+			}
+
+			pos = line.find(strRad);
+			if(pos != std::string::npos)
+			{
+				line.erase(pos, strRad.length());
+				while(std::string::npos != line.find_first_of(numbers))
+				{
+					size_t numStart	= line.find_first_of(numbers);
+					size_t numEnd	= line.find_first_not_of(numbers, numStart);
+					std::string val = line.substr(numStart, numEnd-numStart);
+					readParam.radices.push_back(strtol(val.c_str(), NULL, 10));
+					line.erase(0, numEnd);
+				}
+				continue;
+			}
+		}
+
+		//std::cout << std::endl;
+		//std::cout << "File Parameters" << std::endl;
+		//std::cout << strWgs << " " << readParam.workGroupSize << std::endl;
+		//std::cout << strNtw << " " << readParam.numTransformsPerWg << std::endl;
+		//std::cout << strRad << " "; for(size_t i=0; i<readParam.radices.size(); i++) std::cout << readParam.radices[i] << " "; std::cout << std::endl;
+		//std::cout << std::endl;
+	}
+
+	// Uncomment this directive to experiment with kernels read from file
+//#define KERNEL_INTERJECT
+
+	void ReadKernelFromFile(std::string &str)
+	{
+		const char *fileName = "fft_kernel.cl";
+		std::ifstream file(fileName);
+
+		if(!file.is_open())
+		{
+			std::cout << "File: " << fileName << " could not be opened, exiting ...." << std::endl;
+			exit(-1);
+		}
+
+		str.clear();
+
+		std::string line;
+		while(std::getline(file, line))
+		{
+			str += line;
+			str += '\n';
+		}
+	}
+
+	// Experimental End ===========================================
+
+#define RADIX_TABLE_COMMON 	{     2048,           256,             1,         4,     8, 8, 8, 4, 0, 0, 0, 0, 0, 0, 0, 0 },	\
+							{      512,            64,             1,         3,     8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0 },	\
+							{      256,            64,             1,         4,     4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0 },	\
+							{       64,            64,             4,         3,     4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0 },	\
+							{       32,            64,            16,         2,     8, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },	\
+							{       16,            64,            16,         2,     4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },	\
+							{        4,            64,            32,         2,     2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },	\
+							{        2,            64,            64,         1,     2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+
+
+
+    template <Precision PR>
+	class KernelCoreSpecs
+	{
+		struct SpecRecord
+		{
+			size_t length;
+			size_t workGroupSize;
+			size_t numTransforms;
+			size_t numPasses;
+			size_t radices[12]; // Setting upper limit of number of passes to 12
+		};
+
+		typedef typename std::map<size_t, SpecRecord> SpecTable;
+		SpecTable specTable;
+
+	public:
+		KernelCoreSpecs()
+		{
+			switch(PR)
+			{
+			case P_SINGLE:
+				{
+					SpecRecord specRecord[] = {
+
+					RADIX_TABLE_COMMON
+
+					//  Length, WorkGroupSize, NumTransforms, NumPasses,  Radices
+					{     4096,           256,             1,         4,     8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0 },
+					{     1024,           128,             1,         4,     8, 8, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0 },
+					{      128,            64,             4,         3,     8, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+					{        8,            64,            32,         2,     4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+
+					};
+
+					size_t tableLength = sizeof(specRecord)/sizeof(specRecord[0]);
+					for(size_t i=0; i<tableLength; i++) specTable[specRecord[i].length] = specRecord[i];
+
+				} break;
+
+			case P_DOUBLE:
+				{
+					SpecRecord specRecord[] = {
+
+					RADIX_TABLE_COMMON
+
+					//  Length, WorkGroupSize, NumTransforms, NumPasses,  Radices
+					{     1024,           128,             1,         4,     8, 8, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0 },
+					{      128,            64,             4,         3,     8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+					{        8,            64,            16,         3,     2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+
+					};
+
+					size_t tableLength = sizeof(specRecord)/sizeof(specRecord[0]);
+					for(size_t i=0; i<tableLength; i++) specTable[specRecord[i].length] = specRecord[i];
+				} break;
+
+			default:
+				assert(false);
+			}
+		}
+
+		void GetRadices(size_t length, size_t &numPasses, const size_t * &pRadices) const
+		{
+			pRadices = NULL;
+			numPasses = 0;
+
+			typename SpecTable::const_iterator it = specTable.find(length);
+			if(it != specTable.end())
+			{
+				pRadices = it->second.radices;
+				numPasses = it->second.numPasses;
+			}
+		}
+
+		void GetWGSAndNT(size_t length, size_t &workGroupSize, size_t &numTransforms) const
+		{
+			workGroupSize = 0;
+			numTransforms = 0;
+
+			typename SpecTable::const_iterator it = specTable.find(length);
+			if(it != specTable.end())
+			{
+				workGroupSize = it->second.workGroupSize;
+				numTransforms = it->second.numTransforms;
+			}
+		}
+	};
+
+
+
+	// Given the length of 1d fft, this function determines the appropriate work group size
+	// and the number of transforms per work group
+	// TODO for optimizations - experiment with different possibilities for work group sizes and num transforms for improving performance
+	void DetermineSizes(const size_t &MAX_WGS, const size_t &length, size_t &workGroupSize, size_t &numTrans, Precision &pr)
+	{
+		assert(MAX_WGS >= 64);
+
+		if(length == 1) // special case
+		{
+			workGroupSize = 64;
+			numTrans = 64;
+			return;
+		}
+
+		size_t baseRadix[] = {13,11,7,5,3,2}; // list only supported primes
+		size_t baseRadixSize = sizeof(baseRadix)/sizeof(baseRadix[0]);
+
+		size_t l = length;
+		std::map<size_t, size_t> primeFactorsExpanded;
+		for(size_t r=0; r<baseRadixSize; r++)
+		{
+			size_t rad = baseRadix[r];
+			size_t e = 1;
+			while(!(l%rad))
+			{
+				l /= rad;
+				e *= rad;
+			}
+
+			primeFactorsExpanded[rad] = e;
+		}
+
+		assert(l == 1); // Makes sure the number is composed of only supported primes
+
+		if		(primeFactorsExpanded[2] == length)	// Length is pure power of 2
+		{
+			if		(length >= 1024)	{ workGroupSize = (MAX_WGS >= 256) ? 256 : MAX_WGS; numTrans = 1; }
+			else if (length == 512)		{ workGroupSize = 64; numTrans = 1; }
+			else if	(length >= 16)		{ workGroupSize = 64;  numTrans = 256/length; }
+			else						{ workGroupSize = 64;  numTrans = 128/length; }
+		}
+		else if	(primeFactorsExpanded[3] == length) // Length is pure power of 3
+		{
+			workGroupSize = (MAX_WGS >= 256) ? 243 : 27;
+			numTrans = length >= 3*workGroupSize ? 1 : (3*workGroupSize)/length;
+		}
+		else if	(primeFactorsExpanded[5] == length) // Length is pure power of 5
+		{
+			workGroupSize = (MAX_WGS >= 128) ? 125 : 25;
+			numTrans = length >= 5*workGroupSize ? 1 : (5*workGroupSize)/length;
+		}
+		else if	(primeFactorsExpanded[7] == length) // Length is pure power of 7
+		{
+			workGroupSize = 49;
+			numTrans = length >= 7*workGroupSize ? 1 : (7*workGroupSize)/length;
+		}
+		else if (primeFactorsExpanded[11] == length) // Length is pure power of 11
+		{
+			workGroupSize = 121;
+			numTrans = length >= 11 * workGroupSize ? 1 : (11 * workGroupSize) / length;
+		}
+		else if (primeFactorsExpanded[13] == length) // Length is pure power of 13
+		{
+			workGroupSize = 169;
+			numTrans = length >= 13 * workGroupSize ? 1 : (13 * workGroupSize) / length;
+		}
+		else
+		{
+			size_t leastNumPerWI = 1; // least number of elements in one work item
+			size_t maxWorkGroupSize = MAX_WGS; // maximum work group size desired
+
+
+			if        (primeFactorsExpanded[2] * primeFactorsExpanded[3] == length) { 
+				if (length % 12 == 0) { 
+					leastNumPerWI = 12; maxWorkGroupSize = 128;
+				} else { 
+					leastNumPerWI =  6; maxWorkGroupSize = 256;
+				}
+			} else if (primeFactorsExpanded[2] * primeFactorsExpanded[5] == length) { 
+				if (length % 20 == 0) { 
+					leastNumPerWI = 20; maxWorkGroupSize = 64;
+				} else { 
+					leastNumPerWI = 10; maxWorkGroupSize = 128;
+				}
+			} else if (primeFactorsExpanded[2] * primeFactorsExpanded[7] == length) { 
+					leastNumPerWI = 14; maxWorkGroupSize = 64;
+			} else if (primeFactorsExpanded[3] * primeFactorsExpanded[5] == length) { 
+				    leastNumPerWI = 15; maxWorkGroupSize = 128;
+			} else if (primeFactorsExpanded[3] * primeFactorsExpanded[7] == length) { 
+				    leastNumPerWI = 21; maxWorkGroupSize = 128;
+			} else if (primeFactorsExpanded[5] * primeFactorsExpanded[7] == length) { 
+				    leastNumPerWI = 35; maxWorkGroupSize = 64;
+			} else if (primeFactorsExpanded[2] * primeFactorsExpanded[3] * primeFactorsExpanded[5] == length) { 
+				    leastNumPerWI = 30; maxWorkGroupSize = 64;
+			} else if (primeFactorsExpanded[2] * primeFactorsExpanded[3] * primeFactorsExpanded[7] == length) { 
+				    leastNumPerWI = 42; maxWorkGroupSize = 60;
+			} else if (primeFactorsExpanded[2] * primeFactorsExpanded[5] * primeFactorsExpanded[7] == length) { 
+				    leastNumPerWI = 70; maxWorkGroupSize = 36;
+			} else if (primeFactorsExpanded[3] * primeFactorsExpanded[5] * primeFactorsExpanded[7] == length) { 
+				    leastNumPerWI =105; maxWorkGroupSize = 24;
+			}
+			else if (primeFactorsExpanded[2] * primeFactorsExpanded[11] == length) {
+				leastNumPerWI = 22; maxWorkGroupSize = 128;
+			}
+			else if (primeFactorsExpanded[2] * primeFactorsExpanded[13] == length) {
+				leastNumPerWI = 26; maxWorkGroupSize = 128;
+			}
+			else {
+				    leastNumPerWI =210; maxWorkGroupSize = 12;
+			}
+			if (pr==P_DOUBLE)
+			{
+				//leastNumPerWI /= 2; 
+				maxWorkGroupSize /= 2;
+			}
+			
+
+			if (maxWorkGroupSize > MAX_WGS)
+				maxWorkGroupSize = MAX_WGS;
+			assert (leastNumPerWI > 0 && length % leastNumPerWI == 0);
+
+			for (size_t lnpi = leastNumPerWI; lnpi <= length; lnpi += leastNumPerWI) {
+				if (length % lnpi != 0) continue;
+
+				if (length / lnpi <= MAX_WGS) {
+					leastNumPerWI = lnpi;
+					break;
+				}
+			}
+
+			numTrans = maxWorkGroupSize / (length / leastNumPerWI);
+			numTrans = numTrans < 1 ? 1 : numTrans;
+			workGroupSize = numTrans * (length / leastNumPerWI);
+		}
+
+		assert(workGroupSize <= MAX_WGS);
+	}
+
+	// Twiddle factors table
+    class TwiddleTable
+    {
+        size_t N; // length
+		double *wc, *ws; // cosine, sine arrays
+
+	public:
+		TwiddleTable(size_t length) : N(length)
+		{
+			// Allocate memory for the tables
+			// We compute twiddle factors in double precision for both P_SINGLE and P_DOUBLE
+			wc = new double[N];
+			ws = new double[N];
+		}
+
+		~TwiddleTable()
+		{
+			// Free
+			delete[] wc;
+			delete[] ws;
+		}
+
+		template <Precision PR>
+		void GenerateTwiddleTable(const std::vector<size_t> &radices, std::string &twStr)
+		{
+			const double TWO_PI = -6.283185307179586476925286766559;
+
+			// Make sure the radices vector sums up to N
+			size_t sz = 1;
+			for(std::vector<size_t>::const_iterator i = radices.begin();
+				i != radices.end(); i++)
+			{
+				sz *= (*i);
+			}
+			assert(sz == N);
+
+			// Generate the table
+			size_t L = 1;
+			size_t nt = 0;
+			for(std::vector<size_t>::const_iterator i = radices.begin();
+				i != radices.end(); i++)
+			{
+				size_t radix = *i;
+
+				L *= radix;
+
+				// Twiddle factors
+				for(size_t k=0; k<(L/radix); k++)
+				{
+					double theta = TWO_PI * ((double)k)/((double)L);
+
+					for(size_t j=1; j<radix; j++)
+					{
+						double c = cos(((double)j) * theta);
+						double s = sin(((double)j) * theta);
+
+						//if (fabs(c) < 1.0E-12)	c = 0.0;
+						//if (fabs(s) < 1.0E-12)	s = 0.0;
+
+						wc[nt]   = c;
+						ws[nt++] = s;
+					}
+				}
+			}
+
+			std::string sfx = FloatSuffix<PR>();
+
+			// Stringize the table
+			std::stringstream ss;
+			ss.imbue(std::locale("C"));
+			ss.precision(34);
+			for(size_t i = 0; i < (N-1); i++)
+			{
+				ss << "("; ss << RegBaseType<PR>(2); ss << ")(";
+				ss << std::scientific << wc[i] << sfx << ", ";
+				ss << std::scientific << ws[i] << sfx << "),\n";
+			}
+			twStr += ss.str();
+		}
+    };
+
+
+
+    // A pass inside an FFT kernel
+    template <Precision PR>
+    class Pass
+    {
+		size_t position;					// Position in the kernel
+
+		size_t algL;						// 'L' value from fft algorithm
+		size_t algLS;						// 'LS' value
+		size_t algR;						// 'R' value
+
+		size_t length;						// Length of FFT
+        size_t radix;						// Base radix
+		size_t cnPerWI;						// Complex numbers per work-item
+
+		size_t workGroupSize;				// size of the workgroup = (length / cnPerWI)
+											// this number is essentially number of work-items needed to compute 1 transform
+											// this number will be different from the kernel class workGroupSize if there
+											// are multiple transforms per workgroup
+
+		size_t numButterfly;				// Number of basic FFT butterflies = (cnPerWI / radix)
+		size_t numB1, numB2, numB4;			// number of different types of butterflies
+
+		bool r2c;							// real to complex transform
+		bool c2r;							// complex to real transform
+		bool rcFull;
+		bool rcSimple;
+
+		bool realSpecial;
+
+		bool enableGrouping;				
+		bool linearRegs;					// scalar registers (non-vectorized registers) to be used
+		bool halfLds;						// only half the LDS of a complex length need to be used
+		Pass<PR> *nextPass;
+
+		//callback members
+		bool fft_doPreCallback;
+		clfftCallbackParam fft_preCallback;
+
+		bool fft_doPostCallback;
+		clfftCallbackParam fft_postCallback;
+
+		inline void RegBase(size_t regC, std::string &str) const
+		{
+			str += "B";
+			str += SztToStr(regC);
+		}
+
+		inline void RegBaseAndCount(size_t num, std::string &str) const
+		{
+			str += "C";
+			str += SztToStr(num);
+		}
+
+		inline void RegBaseAndCountAndPos(const std::string &RealImag, size_t radPos, std::string &str) const
+		{
+			str += RealImag;
+			str += SztToStr(radPos);
+		}
+
+		void RegIndex(size_t regC, size_t num, const std::string &RealImag, size_t radPos, std::string &str) const
+		{
+			RegBase(regC, str);
+			RegBaseAndCount(num, str);
+			RegBaseAndCountAndPos(RealImag, radPos, str);
+		}
+
+		void DeclareRegs(const std::string &regType, size_t regC, size_t numB, std::string &passStr) const
+		{
+			std::string regBase;
+			RegBase(regC, regBase);
+
+			if(linearRegs)
+			{
+				assert(regC == 1);
+				assert(numB == numButterfly);
+			}
+
+			for(size_t i=0; i<numB; i++)
+			{
+				passStr += "\n\t";
+				passStr += regType;
+				passStr += " ";
+
+				std::string regBaseCount = regBase;
+				RegBaseAndCount(i, regBaseCount);
+
+				for(size_t r=0; ; r++)
+				{
+					if(linearRegs)
+					{
+						std::string regIndex = "R";
+						RegBaseAndCountAndPos("", i*radix + r, regIndex);
+
+						passStr += regIndex;
+					}
+					else
+					{
+						std::string regRealIndex(regBaseCount), regImagIndex(regBaseCount);
+
+						RegBaseAndCountAndPos("R", r, regRealIndex); // real
+						RegBaseAndCountAndPos("I", r, regImagIndex); // imaginary
+
+						passStr += regRealIndex; passStr += ", ";
+						passStr += regImagIndex;
+					}
+
+					if(r == radix-1)
+					{
+						passStr += ";";
+						break;
+					}
+					else
+					{
+						passStr += ", ";
+					}
+				}
+			}
+		}
+
+		inline std::string IterRegArgs() const
+		{
+			std::string str = "";
+
+			if(linearRegs)
+			{
+				std::string regType = RegBaseType<PR>(2);
+
+				for(size_t i=0; i<cnPerWI; i++)
+				{
+					if(i != 0) str += ", ";
+					str += regType; str += " *R";
+					str += SztToStr(i);
+				}
+			}
+
+			return str;
+		}
+
+#define SR_READ			1
+#define SR_TWMUL		2
+#define SR_TWMUL_3STEP	3
+#define SR_WRITE		4
+
+#define SR_COMP_REAL 0 // real
+#define SR_COMP_IMAG 1 // imag
+#define SR_COMP_BOTH 2 // real & imag
+
+		// SweepRegs is to iterate through the registers to do the three basic operations:
+		// reading, twiddle multiplication, writing
+		void SweepRegs(	size_t flag, bool fwd, bool interleaved, size_t stride, size_t component,
+						double scale, bool frontTwiddle,
+						const std::string &bufferRe, const std::string &bufferIm, const std::string &offset,
+						size_t regC, size_t numB, size_t numPrev, std::string &passStr, bool isPrecallVector = false, bool oddt = false) const
+		{
+			assert( (flag == SR_READ )			||
+					(flag == SR_TWMUL)			||
+					(flag == SR_TWMUL_3STEP)	||
+					(flag == SR_WRITE) );
+
+			const std::string twTable = TwTableName();
+			const std::string tw3StepFunc = TwTableLargeFunc();
+
+			// component: 0 - real, 1 - imaginary, 2 - both
+			size_t cStart, cEnd;
+			switch(component)
+			{
+			case SR_COMP_REAL:	cStart = 0; cEnd = 1; break;
+			case SR_COMP_IMAG:	cStart = 1; cEnd = 2; break;
+			case SR_COMP_BOTH:	cStart = 0; cEnd = 2; break;
+			default:	assert(false);
+			}
+
+			// Read/Write logic:
+			// The double loop inside pass loop of FFT algorithm is mapped into the
+			// workGroupSize work items with each work item handling cnPerWI numbers
+
+			// Read logic:
+			// Reads for any pass appear the same with the stockham algorithm when mapped to
+			// the work items. The buffer is divided into (L/radix) sized blocks and the
+			// values are read in linear order inside each block.
+
+			// Vector reads are possible if we have unit strides
+			// since read pattern remains the same for all passes and they are contiguous
+			// Writes are not contiguous
+
+			// TODO : twiddle multiplies can be combined with read
+			// TODO : twiddle factors can be reordered in the table to do vector reads of them
+
+			// Write logic:
+			// outer loop index k and the inner loop index j map to 'me' as follows:
+			// In one work-item (1 'me'), there are 'numButterfly' fft butterflies. They
+			// are indexed as numButterfly*me + butterflyIndex, where butterflyIndex's range is
+			// 0 ... numButterfly-1. The total number of butterflies needed is covered over all
+			// the work-items. So essentially the double loop k,j is flattened to fit this linearly
+			// increasing 'me'.
+			// j = (numButterfly*me + butterflyIndex)%LS
+			// k = (numButterfly*me + butterflyIndex)/LS
+
+
+			std::string twType = RegBaseType<PR>(2);
+			std::string rType  = RegBaseType<PR>(1);
+
+			size_t butterflyIndex = numPrev;
+			std::string bufOffset;
+
+			std::string regBase;
+			RegBase(regC, regBase);
+
+			// special write back to global memory with float4 grouping, writing 2 complex numbers at once
+			if( numB && (numB%2 == 0) && (regC == 1) && (stride == 1) && (numButterfly%2 == 0) && (algLS%2 == 0) && (flag == SR_WRITE) &&
+				(nextPass == NULL) && interleaved && (component == SR_COMP_BOTH) && linearRegs && enableGrouping && !fft_doPostCallback )
+			{
+				assert((numButterfly * workGroupSize) == algLS);
+				assert(bufferRe.compare(bufferIm) == 0); // Make sure Real & Imag buffer strings are same for interleaved data
+
+				passStr += "\n\t";
+				passStr += "__global "; passStr += RegBaseType<PR>(4);
+				passStr += " *buff4g = "; passStr += bufferRe; passStr += ";\n\t"; // Assuming 'outOffset' is 0, so not adding it here
+
+				for(size_t r=0; r<radix; r++) // setting the radix loop outside to facilitate grouped writing
+				{
+					butterflyIndex = numPrev;
+
+					for(size_t i=0; i<(numB/2); i++)
+					{
+						std::string regIndexA = "(*R";
+						std::string regIndexB = "(*R";
+
+						RegBaseAndCountAndPos("", (2*i + 0)*radix + r, regIndexA); regIndexA += ")";
+						RegBaseAndCountAndPos("", (2*i + 1)*radix + r, regIndexB); regIndexB += ")";
+
+						passStr += "\n\t";
+						passStr += "buff4g"; passStr += "[ ";
+						passStr += SztToStr(numButterfly/2); passStr += "*me + "; passStr += SztToStr(butterflyIndex);
+						passStr += " + ";
+						passStr += SztToStr(r*(algLS/2)); passStr += " ]";
+						passStr += " = "; passStr += "("; passStr += RegBaseType<PR>(4); passStr += ")(";
+						passStr += regIndexA; passStr += ".x, ";
+						passStr += regIndexA; passStr += ".y, ";
+						passStr += regIndexB; passStr += ".x, ";
+						passStr += regIndexB; passStr += ".y) ";
+						if(scale != 1.0f) { passStr += " * "; passStr += FloatToStr(scale); passStr += FloatSuffix<PR>(); }
+						passStr += ";";
+
+						butterflyIndex++;
+					}
+				}
+
+				return;
+			}
+
+			size_t hid = 0;
+			bool swapElement = false;
+			size_t tIter = numB * radix;
+
+			// block to rearrange reads of adjacent memory locations together
+			if(linearRegs && (flag == SR_READ))
+			{
+				for(size_t r=0; r<radix; r++)
+				{
+					for(size_t i=0; i<numB; i++)
+					{
+						for(size_t c=cStart; c<cEnd; c++) // component loop: 0 - real, 1 - imaginary
+						{
+							swapElement = (fft_doPreCallback && c2r && component == SR_COMP_REAL); //reset at start of loop
+
+							std::string tail;
+							std::string regIndex;
+							std::string regIndexC;
+							regIndex = "(*R";
+							std::string buffer;
+
+							// Read real & imag at once
+							if(interleaved && (component == SR_COMP_BOTH))
+							{
+								assert(bufferRe.compare(bufferIm) == 0); // Make sure Real & Imag buffer strings are same for interleaved data
+								buffer = bufferRe;
+								RegBaseAndCountAndPos("", i*radix + r, regIndex); regIndex += ")";
+								tail = ";";
+							}
+							else
+							{
+								if(c == 0)
+								{
+									RegBaseAndCountAndPos("", i*radix + r, regIndex); 
+									
+									hid = (i * radix + r) / ( tIter > 1 ? (tIter / 2) : 1 );
+									swapElement = swapElement && hid != 0;
+									swapElement = (oddt && ((i * radix + r) >= (tIter - 1))) ? false : swapElement;  //for c2r odd size don't swap for last register
+									if (swapElement)
+									{
+										regIndexC = regIndex; regIndexC += ").y";
+									}
+									
+									regIndex += ").x";
+									buffer = bufferRe;
+									tail = interleaved ? ".x;" : ";";
+								}
+								else
+								{
+									RegBaseAndCountAndPos("", i*radix + r, regIndex); regIndex += ").y";
+									buffer = bufferIm;
+									tail = interleaved ? ".y;" : ";";
+								}
+							}
+
+							//get offset 
+							bufOffset.clear();
+							bufOffset += offset; bufOffset += " + ( "; bufOffset += SztToStr(numPrev); bufOffset += " + ";
+							bufOffset += "me*"; bufOffset += SztToStr(numButterfly); bufOffset += " + ";
+							bufOffset += SztToStr(i); bufOffset += " + ";
+							bufOffset += SztToStr(r*length/radix); bufOffset += " )*";
+							bufOffset += SztToStr(stride);
+
+							//If precallback is set invoke callback function
+							//Invoke callback only once in Planar data layout (i.e.c==0)
+							if (fft_doPreCallback && c == 0 && component == SR_COMP_BOTH)
+							{
+								passStr += "\n\t";
+								passStr += "retPrecallback = "; passStr += fft_preCallback.funcname; passStr += "("; 
+								if(interleaved)
+								{
+									passStr += buffer; passStr += ", ";
+								}
+								else
+								{
+									passStr += bufferRe; passStr += ", "; passStr += bufferIm; passStr += ", ";
+								}
+								passStr += bufOffset; passStr += ", pre_userdata";
+								if (fft_preCallback.localMemSize > 0)
+								{
+									passStr += ", localmem";
+								}
+								passStr += ");";
+							}
+
+							if (swapElement)
+							{
+								passStr += "\n\t";
+								passStr += regIndexC; passStr += " = "; passStr += regIndex; passStr += ";";
+							}
+
+							passStr += "\n\t";
+							passStr += regIndex;
+							passStr += " = ";
+
+							//Use the return value from precallback if set
+							if (fft_doPreCallback && (component == SR_COMP_BOTH || r2c))
+							{
+								if (component == SR_COMP_BOTH)
+								{
+									passStr += "retPrecallback"; 
+									passStr += interleaved ? tail : (c == 0) ? ".x;" : ".y;";
+								}
+								else if (r2c)
+								{
+									passStr += fft_preCallback.funcname; passStr += "("; passStr += buffer; passStr += ", ";
+									passStr += bufOffset; passStr += ", pre_userdata";
+
+									if (fft_preCallback.localMemSize > 0)
+									{
+										passStr += ", localmem";
+									}
+									passStr += ");";
+								}
+							}
+							else
+							{
+								passStr += buffer;
+								passStr += "["; passStr += bufOffset; passStr += "]"; passStr += tail;
+							}
+
+							// Since we read real & imag at once, we break the loop
+							if(interleaved && (component == SR_COMP_BOTH) )
+								break;
+						}
+					}
+				}
+				return;
+			}
+
+			// block to rearrange writes of adjacent memory locations together
+			if(linearRegs && (flag == SR_WRITE) && (nextPass == NULL))
+			{
+				for(size_t r=0; r<radix; r++)
+				{
+					butterflyIndex = numPrev;
+
+					for(size_t i=0; i<numB; i++)
+					{
+						if(realSpecial && (nextPass == NULL) && (r > (radix/2)))
+							break;
+
+						if(realSpecial && (nextPass == NULL) && (r == radix/2) && (i != 0))
+							break;
+
+						if(realSpecial && (nextPass == NULL) && (r == radix/2) && (i == 0))
+							passStr += "\n\t}\n\tif( rw && !me)\n\t{";
+
+						std::string regIndexC0;
+						for(size_t c=cStart; c<cEnd; c++) // component loop: 0 - real, 1 - imaginary
+						{
+							std::string tail;
+							std::string regIndex;
+							regIndex = "(*R";
+							std::string buffer;
+
+							// Write real & imag at once
+							if(interleaved && (component == SR_COMP_BOTH))
+							{
+								assert(bufferRe.compare(bufferIm) == 0); // Make sure Real & Imag buffer strings are same for interleaved data
+								buffer = bufferRe;
+								RegBaseAndCountAndPos("", i*radix + r, regIndex); regIndex += ")";
+								tail = "";
+							}
+							else
+							{
+								if(c == 0)
+								{
+									RegBaseAndCountAndPos("", i*radix + r, regIndex); regIndex += ").x";
+									buffer = bufferRe;
+									tail = interleaved ? ".x" : "";
+								}
+								else
+								{
+									RegBaseAndCountAndPos("", i*radix + r, regIndex); regIndex += ").y";
+									buffer = bufferIm;
+									tail = interleaved ? ".y" : "";
+								}
+							}
+
+							bufOffset.clear();
+							bufOffset += offset; bufOffset += " + ( "; 
+							if( (numButterfly * workGroupSize) > algLS )
+							{
+								bufOffset += "(("; bufOffset += SztToStr(numButterfly);
+								bufOffset += "*me + "; bufOffset += SztToStr(butterflyIndex); bufOffset += ")/";
+								bufOffset += SztToStr(algLS); bufOffset += ")*"; bufOffset += SztToStr(algL); bufOffset += " + (";
+								bufOffset += SztToStr(numButterfly); bufOffset += "*me + "; bufOffset += SztToStr(butterflyIndex);
+								bufOffset += ")%"; bufOffset += SztToStr(algLS); bufOffset += " + ";
+							}
+							else
+							{
+								bufOffset += SztToStr(numButterfly); bufOffset += "*me + "; bufOffset += SztToStr(butterflyIndex);
+								bufOffset += " + ";
+							}
+							bufOffset += SztToStr(r*algLS); bufOffset += " )*"; bufOffset += SztToStr(stride);
+
+							if(scale != 1.0f) { regIndex += " * "; regIndex += FloatToStr(scale); regIndex += FloatSuffix<PR>(); }
+							if (c == cStart)	regIndexC0 = regIndex;
+
+							if (fft_doPostCallback && !r2c)
+							{
+								if (interleaved || c == (cEnd - 1))
+								{
+							passStr += "\n\t";
+									passStr += fft_postCallback.funcname; passStr += "(";
+
+									if (interleaved || (c2r && bufferRe.compare(bufferIm) == 0))
+							{
+										passStr += buffer;
+							}
+							else
+							{
+										passStr += bufferRe; passStr += ", "; passStr += bufferIm;
+							}
+									passStr += ", ";
+									passStr += bufOffset; passStr += ", post_userdata, ("; passStr += regIndexC0; passStr += ")";
+									if (!(interleaved || (c2r && bufferRe.compare(bufferIm) == 0))) { passStr += ", ("; passStr += regIndex; passStr += ")"; }
+
+									if (fft_postCallback.localMemSize > 0)
+									{
+										passStr += ", post_localmem";
+									}
+									passStr += ");";
+								}
+							}
+							else
+							{	
+								passStr += "\n\t";
+								passStr += buffer; passStr += "["; passStr += bufOffset; passStr += "]";
+								passStr += tail; passStr += " = "; passStr += regIndex; passStr += ";";
+							}
+
+							// Since we write real & imag at once, we break the loop
+							if(interleaved && (component == SR_COMP_BOTH))
+								break;
+						}
+
+						if(realSpecial && (nextPass == NULL) && (r == radix/2) && (i == 0))
+							passStr += "\n\t}\n\tif(rw)\n\t{";
+
+						butterflyIndex++;
+					}
+				}
+
+				return;
+			}
+			
+			
+			for(size_t i=0; i<numB; i++)
+			{
+				std::string regBaseCount = regBase;
+				RegBaseAndCount(i, regBaseCount);
+
+				if(flag == SR_READ) // read operation
+				{
+					// the 'r' (radix index) loop is placed outer to the
+					// 'v' (vector index) loop to make possible vectorized reads
+
+					for(size_t r=0; r<radix; r++)
+					{
+						for(size_t c=cStart; c<cEnd; c++) // component loop: 0 - real, 1 - imaginary
+						{
+							std::string tail;
+							std::string regIndex;
+							std::string regIndexC;
+							regIndex = linearRegs ? "(*R" : regBaseCount;
+							std::string buffer;
+
+							// Read real & imag at once
+							if(interleaved && (component == SR_COMP_BOTH) && linearRegs)
+							{
+								assert(bufferRe.compare(bufferIm) == 0); // Make sure Real & Imag buffer strings are same for interleaved data
+								buffer = bufferRe;
+								RegBaseAndCountAndPos("", i*radix + r, regIndex); regIndex += ")";
+								tail = ";";
+							}
+							else
+							{
+								if(c == 0)
+								{
+									if(linearRegs) 
+									{ 
+										RegBaseAndCountAndPos("", i*radix + r, regIndex); 
+									
+										hid = (i * radix + r) / (numB * radix / 2);
+										if (fft_doPreCallback && c2r && component == SR_COMP_REAL && hid != 0)
+										{
+											regIndexC = regIndex; regIndexC += ").y";
+										}
+										regIndex += ").x"; 
+									}
+									else		   { RegBaseAndCountAndPos("R", r, regIndex); }
+									buffer = bufferRe;
+									tail = interleaved ? ".x;" : ";";
+								}
+								else
+								{
+									if(linearRegs) { RegBaseAndCountAndPos("", i*radix + r, regIndex); regIndex += ").y"; }
+									else		   { RegBaseAndCountAndPos("I", r, regIndex); }
+									buffer = bufferIm;
+									tail = interleaved ? ".y;" : ";";
+								}
+							}
+
+							for(size_t v=0; v<regC; v++) // TODO: vectorize the reads; instead of reading individually for consecutive reads of vector elements
+							{
+								std::string regIndexSub(regIndex);
+								if(regC != 1)
+								{
+									regIndexSub += ".s";
+									regIndexSub += SztToStr(v);
+								}
+
+								//get offset 
+								bufOffset.clear();
+								bufOffset += offset; bufOffset += " + ( "; bufOffset += SztToStr(numPrev); bufOffset += " + ";
+								bufOffset += "me*"; bufOffset += SztToStr(numButterfly); bufOffset += " + ";
+								bufOffset += SztToStr(i*regC + v); bufOffset += " + ";
+								bufOffset += SztToStr(r*length/radix); bufOffset += " )*";
+								bufOffset += SztToStr(stride);
+
+								//If precallback is set invoke callback function
+								//Invoke callback only once in Planar data layout (i.e.c==0)
+								if (fft_doPreCallback && c == 0 && component == SR_COMP_BOTH)
+								{
+									passStr += "\n\t";
+									passStr += "retPrecallback"; 
+									
+									if (isPrecallVector)
+									{
+										passStr += "["; passStr += SztToStr(v); passStr += "]"; 
+									}
+
+									passStr += " = "; passStr += fft_preCallback.funcname; passStr += "("; 
+									if(interleaved)
+									{
+										passStr += buffer; passStr += ", ";
+									}
+									else
+									{
+										passStr += bufferRe; passStr += ", "; passStr += bufferIm; passStr += ", ";
+									}
+									passStr += bufOffset; passStr += ", pre_userdata";
+									if (fft_preCallback.localMemSize > 0)
+									{
+										passStr += ", localmem";
+									}
+									passStr += ");";
+								}
+
+								if (fft_doPreCallback && c2r && component == SR_COMP_REAL && hid != 0)
+								{
+									passStr += "\n\t";
+									passStr += regIndexC; passStr += " = "; passStr += regIndexSub; passStr += ";";
+								}
+
+								passStr += "\n\t";
+								passStr += regIndexSub;
+								passStr += " = "; 
+
+								//Use the return value from precallback if set
+								if (fft_doPreCallback && (component == SR_COMP_BOTH || r2c))
+								{
+									if (component == SR_COMP_BOTH)
+									{
+										passStr += "retPrecallback"; 
+									
+										if (isPrecallVector)
+										{
+											passStr += "["; passStr += SztToStr(v); passStr += "]"; 
+										} 
+										passStr += interleaved ? tail : (c == 0) ? ".x;" : ".y;";
+									}
+									else if (r2c)
+									{
+										passStr += fft_preCallback.funcname; passStr += "("; passStr += buffer; passStr += ", ";
+										passStr += bufOffset; passStr += ", pre_userdata";
+
+										if (fft_preCallback.localMemSize > 0)
+										{
+											passStr += ", localmem";
+										}
+										passStr += ");";
+									}
+								}
+								else
+								{
+									passStr += buffer;
+									passStr += "["; passStr += bufOffset; passStr += "]"; passStr += tail;
+								}
+							}
+
+							// Since we read real & imag at once, we break the loop
+							if(interleaved && (component == SR_COMP_BOTH) && linearRegs)
+								break;
+						}
+					}
+				}
+				else if( (flag == SR_TWMUL) || (flag == SR_TWMUL_3STEP) ) // twiddle multiplies and writes require that 'r' loop be innermost
+				{
+					for(size_t v=0; v<regC; v++)
+					{
+						for(size_t r=0; r<radix; r++)
+						{
+
+							std::string regRealIndex, regImagIndex;
+							regRealIndex = linearRegs ? "(*R" : regBaseCount;
+							regImagIndex = linearRegs ? "(*R" : regBaseCount;
+
+							if(linearRegs)
+							{
+								RegBaseAndCountAndPos("", i*radix + r, regRealIndex); regRealIndex += ").x";
+								RegBaseAndCountAndPos("", i*radix + r, regImagIndex); regImagIndex += ").y";
+							}
+							else
+							{
+								RegBaseAndCountAndPos("R", r, regRealIndex);
+								RegBaseAndCountAndPos("I", r, regImagIndex);
+							}
+
+							if(regC != 1)
+							{
+								regRealIndex += ".s"; regRealIndex += SztToStr(v);
+								regImagIndex += ".s"; regImagIndex += SztToStr(v);
+							}
+
+
+							if(flag == SR_TWMUL) // twiddle multiply operation
+							{
+								if(r == 0) // no twiddle muls needed
+									continue;
+
+								passStr += "\n\t{\n\t\t"; passStr += twType; passStr += " W = ";
+								passStr += twTable; passStr += "["; passStr += SztToStr(algLS-1); passStr += " + ";
+								passStr += SztToStr(radix-1); passStr += "*(("; passStr += SztToStr(numButterfly);
+								passStr += "*me + "; passStr += SztToStr(butterflyIndex); passStr += ")%";
+								passStr += SztToStr(algLS); passStr += ") + "; passStr += SztToStr(r-1);
+								passStr += "];\n\t\t";
+							}
+							else	// 3-step twiddle
+							{
+								passStr += "\n\t{\n\t\t"; passStr += twType; passStr += " W = ";
+								passStr += tw3StepFunc; passStr += "( ";
+
+								if(frontTwiddle)
+								{
+									assert(linearRegs);
+									passStr += "("; passStr += "me*"; passStr += SztToStr(numButterfly);
+									passStr += " + "; passStr += SztToStr(i); passStr += " + ";
+									passStr += SztToStr(r*length/radix); passStr += ") * b";
+								}
+								else
+								{
+									passStr += "(("; passStr += SztToStr(numButterfly); passStr += "*me + ";
+									passStr += SztToStr(butterflyIndex);
+									passStr += ")%"; passStr += SztToStr(algLS); passStr += " + ";
+									passStr += SztToStr(r*algLS); passStr += ") * b";
+								}
+
+								passStr += " );\n\t\t";
+							}
+
+							passStr += rType; passStr += " TR, TI;\n\t\t";
+
+							if(realSpecial && (flag == SR_TWMUL_3STEP))
+							{
+								if(fwd)
+								{
+									passStr += "if(t==0)\n\t\t{\n\t\t";
+
+									passStr += "TR = (W.x * "; passStr += regRealIndex; passStr += ") - (W.y * ";
+									passStr += regImagIndex; passStr += ");\n\t\t";
+									passStr += "TI = (W.y * "; passStr += regRealIndex; passStr += ") + (W.x * ";
+									passStr += regImagIndex; passStr += ");\n\t\t";
+
+									passStr += "}\n\t\telse\n\t\t{\n\t\t";
+									
+									passStr += "TR = (W.x * "; passStr += regRealIndex; passStr += ") + (W.y * ";
+									passStr += regImagIndex; passStr += ");\n\t\t";
+									passStr += "TI = (W.y * "; passStr += regRealIndex; passStr += ") - (W.x * ";
+									passStr += regImagIndex; passStr += ");\n\t\t";
+									
+									passStr += "}\n\t\t";
+								}
+								else
+								{
+									passStr += "if(t==0)\n\t\t{\n\t\t";
+
+									passStr += "TR = (W.x * "; passStr += regRealIndex; passStr += ") + (W.y * ";
+									passStr += regImagIndex; passStr += ");\n\t\t";
+									passStr += "TI = (W.y * "; passStr += regRealIndex; passStr += ") - (W.x * ";
+									passStr += regImagIndex; passStr += ");\n\t\t";
+
+									passStr += "}\n\t\telse\n\t\t{\n\t\t";
+
+									passStr += "TR = (W.x * "; passStr += regRealIndex; passStr += ") - (W.y * ";
+									passStr += regImagIndex; passStr += ");\n\t\t";
+									passStr += "TI = (W.y * "; passStr += regRealIndex; passStr += ") + (W.x * ";
+									passStr += regImagIndex; passStr += ");\n\t\t";
+
+									passStr += "}\n\t\t";
+								}
+							}
+							else
+							{
+								if(fwd)
+								{
+									passStr += "TR = (W.x * "; passStr += regRealIndex; passStr += ") - (W.y * ";
+									passStr += regImagIndex; passStr += ");\n\t\t";
+									passStr += "TI = (W.y * "; passStr += regRealIndex; passStr += ") + (W.x * ";
+									passStr += regImagIndex; passStr += ");\n\t\t";
+								}
+								else
+								{
+									passStr += "TR =  (W.x * "; passStr += regRealIndex; passStr += ") + (W.y * ";
+									passStr += regImagIndex; passStr += ");\n\t\t";
+									passStr += "TI = -(W.y * "; passStr += regRealIndex; passStr += ") + (W.x * ";
+									passStr += regImagIndex; passStr += ");\n\t\t";
+								}
+							}
+
+							passStr += regRealIndex; passStr += " = TR;\n\t\t";
+							passStr += regImagIndex; passStr += " = TI;\n\t}\n";
+
+						}
+
+						butterflyIndex++;
+					}
+				}
+				else // write operation
+				{
+					for(size_t v=0; v<regC; v++)
+					{
+						for(size_t r=0; r<radix; r++)
+						{
+							if(realSpecial && (nextPass == NULL) && (r > (radix/2)))
+								break;
+
+							if(realSpecial && (nextPass == NULL) && (r == radix/2) && (i != 0))
+								break;
+
+							if(realSpecial && (nextPass == NULL) && (r == radix/2) && (i == 0))
+								passStr += "\n\t}\n\tif( rw && !me)\n\t{";
+
+							std::string regIndexC0;
+								
+							for(size_t c=cStart; c<cEnd; c++) // component loop: 0 - real, 1 - imaginary
+							{
+								std::string tail;
+								std::string regIndex;
+								regIndex = linearRegs ? "(*R" : regBaseCount;
+								std::string buffer;
+
+								// Write real & imag at once
+								if(interleaved && (component == SR_COMP_BOTH) && linearRegs)
+								{
+									assert(bufferRe.compare(bufferIm) == 0); // Make sure Real & Imag buffer strings are same for interleaved data
+									buffer = bufferRe;
+									RegBaseAndCountAndPos("", i*radix + r, regIndex); regIndex += ")";
+									tail = "";
+								}
+								else
+								{
+									if(c == 0)
+									{
+										if(linearRegs) { RegBaseAndCountAndPos("", i*radix + r, regIndex); regIndex += ").x"; }
+										else		   { RegBaseAndCountAndPos("R", r, regIndex); }
+										buffer = bufferRe;
+										tail = interleaved ? ".x" : "";
+									}
+									else
+									{
+										if(linearRegs) { RegBaseAndCountAndPos("", i*radix + r, regIndex); regIndex += ").y"; }
+										else		   { RegBaseAndCountAndPos("I", r, regIndex); }
+										buffer = bufferIm;
+										tail = interleaved ? ".y" : "";
+									}
+								}
+
+								if(regC != 1)
+								{
+									regIndex += ".s";
+									regIndex += SztToStr(v);
+								}
+
+								passStr += "\n\t";
+
+								if(scale != 1.0f) { regIndex += " * "; regIndex += FloatToStr(scale); regIndex += FloatSuffix<PR>(); }
+								if (c == 0) regIndexC0 += regIndex;
+
+								bufOffset.clear();
+								bufOffset += offset; bufOffset += " + ( ";
+								if( (numButterfly * workGroupSize) > algLS )
+								{
+									bufOffset += "(("; bufOffset += SztToStr(numButterfly);
+									bufOffset += "*me + "; bufOffset += SztToStr(butterflyIndex); bufOffset += ")/";
+									bufOffset += SztToStr(algLS); bufOffset += ")*"; bufOffset += SztToStr(algL); bufOffset += " + (";
+									bufOffset += SztToStr(numButterfly); bufOffset += "*me + "; bufOffset += SztToStr(butterflyIndex);
+									bufOffset += ")%"; bufOffset += SztToStr(algLS); bufOffset += " + ";
+								}
+								else
+								{
+									bufOffset += SztToStr(numButterfly); bufOffset += "*me + "; bufOffset += SztToStr(butterflyIndex);
+									bufOffset += " + ";
+								}
+
+								bufOffset += SztToStr(r*algLS); bufOffset += " )*"; bufOffset += SztToStr(stride); 
+								
+								if (fft_doPostCallback)
+								{
+									if(interleaved && (component == SR_COMP_BOTH))
+									{
+										if (c == (cEnd - 1))
+										{
+											passStr += "tempC.x = "; passStr += regIndexC0; passStr += ";\n\t";
+											passStr += "tempC.y = "; passStr += regIndex; passStr += ";\n\t";
+
+											passStr += fft_postCallback.funcname; passStr += "("; 
+											passStr += buffer; passStr += ", (";
+											passStr += bufOffset; passStr += "), post_userdata, tempC";
+											if (fft_postCallback.localMemSize > 0)
+											{
+												passStr += ", post_localmem";
+											}
+											passStr += ");";
+										}
+									}
+									else if (c == (cEnd - 1))
+									{
+										passStr += fft_postCallback.funcname; passStr += "("; 
+										passStr += bufferRe; passStr += ", "; passStr += bufferIm; passStr += ", (";
+										passStr += bufOffset; passStr += "), post_userdata, ("; 
+										passStr += regIndexC0; passStr += "), ("; passStr += regIndex; passStr += ")";
+										if (fft_postCallback.localMemSize > 0)
+										{
+											passStr += ", post_localmem";
+										}
+										passStr += ");";
+									}
+								}
+								else
+								{
+									passStr += buffer; passStr += "["; passStr += bufOffset; passStr += "]";
+								passStr += tail; passStr += " = "; passStr += regIndex;
+								passStr += ";";
+								}
+
+								// Since we write real & imag at once, we break the loop
+								if(interleaved && (component == SR_COMP_BOTH) && linearRegs)
+									break;
+							}
+
+							if(realSpecial && (nextPass == NULL) && (r == radix/2) && (i == 0))
+								passStr += "\n\t}\n\tif(rw)\n\t{";
+
+						}
+
+						butterflyIndex++;
+					}
+
+				}
+			}
+
+			assert(butterflyIndex <= numButterfly);
+		}
+
+
+		// Special SweepRegs function to carry out some R-C/C-R specific operations
+		void SweepRegsRC(	size_t flag, bool fwd, bool interleaved, size_t stride, size_t component,
+							double scale, bool setZero, bool batch2, bool oddt,
+							const std::string &bufferRe, const std::string &bufferIm, const std::string &offset,
+							std::string &passStr) const
+		{
+			assert( (flag == SR_READ ) ||
+					(flag == SR_WRITE) );
+
+
+			// component: 0 - real, 1 - imaginary, 2 - both
+			size_t cStart, cEnd;
+			switch(component)
+			{
+			case SR_COMP_REAL:	cStart = 0; cEnd = 1; break;
+			case SR_COMP_IMAG:	cStart = 1; cEnd = 2; break;
+			case SR_COMP_BOTH:	cStart = 0; cEnd = 2; break;
+			default:	assert(false);
+			}
+
+			std::string rType  = RegBaseType<PR>(1);
+
+			assert(r2c || c2r);
+			assert(linearRegs);
+			bool singlePass = ((position == 0) && (nextPass == NULL));
+
+			size_t numCR = numButterfly * radix;
+			if(!(numCR%2)) assert(!oddt);
+
+			size_t rStart = 0;
+			size_t rEnd = numCR;
+
+			bool oddp = ((numCR%2) && (numCR > 1) && !setZero);
+			if(oddp)
+			{
+				if(oddt)	{ rStart = numCR-1; rEnd = numCR+1; }
+				else		{ rStart = 0;		rEnd = numCR-1; }
+			}
+
+			if(!oddp) assert(!oddt);
+
+			for(size_t r=rStart; r<rEnd; r++)
+			{
+				std::string val1StrExt;
+
+				for(size_t c=cStart; c<cEnd; c++) // component loop: 0 - real, 1 - imaginary
+				{
+					if(flag == SR_READ) // read operation
+					{
+						std::string tail, tail2;
+						std::string regIndex = "(*R";
+						std::string buffer;
+
+						RegBaseAndCountAndPos("", r, regIndex); 
+						if (fft_doPreCallback && c2r)
+						{
+							 regIndex += ")";
+							 if (interleaved)
+							 {
+								buffer = (c == 0) ? bufferRe : bufferIm;
+							 }
+							 else
+							 {
+								 buffer += bufferRe; buffer += ", "; buffer += bufferIm;
+							 }
+						}
+						else
+						{
+							if(c == 0)
+							{
+								regIndex += ").x";
+								buffer = bufferRe;
+								tail  = interleaved ? ".x;" : ";";
+								tail2 = interleaved ? ".y;" : ";";
+							}
+							else
+							{
+								regIndex += ").y";
+								buffer = bufferIm;
+								tail  = interleaved ? ".y;" : ";";
+								tail2 = interleaved ? ".x;" : ";";
+							}
+						}
+
+						size_t bid = numCR/2;
+						bid = bid ? bid : 1;
+						size_t cid, lid;
+
+						if(oddt)
+						{
+							cid = r%2;
+							lid = 1 + (numCR/2);
+						}
+						else
+						{
+							cid = r/bid;
+							lid = 1 + r%bid;
+						}
+
+						std::string oddpadd = oddp ? " (me/2) + " : " ";
+
+						std::string idxStr, idxStrRev;
+						if((length <= 2) || ((length & (length - 1)) != 0))
+						{
+							idxStr += SztToStr(bid); idxStr += "*me +"; idxStr += oddpadd; idxStr += SztToStr(lid);
+						}
+						else
+						{
+							idxStr += "me + "; idxStr += SztToStr(1 + length*(r%bid)/numCR); idxStr += oddpadd;
+						}
+						idxStrRev += SztToStr(length); idxStrRev += " - ("; idxStrRev += idxStr; idxStrRev += " )";
+
+						bool act = ( fwd || ((cid == 0) && (!batch2)) || ((cid != 0) && batch2) );
+						if(act)
+						{
+							passStr += "\n\t";
+							passStr += regIndex;
+							passStr += " = ";
+						}
+
+						if(setZero)
+						{
+							if(act) passStr += "0;";
+						}
+						else
+						{
+							if(act)
+							{
+								if (fft_doPreCallback)
+								{
+									passStr += fft_preCallback.funcname; passStr += "(";
+									passStr += buffer; passStr += ", ";  
+								}
+								else
+								{
+									passStr += buffer;
+									passStr += "["; 
+								}
+								passStr += offset; passStr += " + ( ";
+							}
+
+							if(fwd)
+							{
+								if(cid == 0)	passStr += idxStr;
+								else			passStr += idxStrRev;
+							}
+							else
+							{
+								if(cid == 0)	{ if(!batch2) passStr += idxStr; }
+								else			{ if(batch2)  passStr += idxStr; }
+							}
+
+							if(act)
+							{
+								passStr += " )*"; passStr += SztToStr(stride); 
+								
+								if (fft_doPreCallback)
+								{
+									passStr += ", pre_userdata";
+									passStr += (fft_preCallback.localMemSize > 0) ? ", localmem);" : ");";
+								}
+								else
+								{
+									passStr += "]";
+
+									if(fwd) { passStr += tail; }
+									else	{ if(!batch2) passStr += tail; else passStr += tail2; }
+								}
+							}
+						}
+					}
+					else // write operation
+					{
+						std::string tail;
+						std::string regIndex = "(*R";
+						std::string regIndexPair = "(*R";
+						std::string buffer;
+
+						// Write real & imag at once
+						if(interleaved && (component == SR_COMP_BOTH))
+						{
+							assert(bufferRe.compare(bufferIm) == 0); // Make sure Real & Imag buffer strings are same for interleaved data
+							buffer = bufferRe;
+						}
+						else
+						{
+							if(c == 0)
+							{
+								buffer = bufferRe;
+								tail = interleaved ? ".x" : "";
+							}
+							else
+							{
+								buffer = bufferIm;
+								tail = interleaved ? ".y" : "";
+							}
+						}
+
+
+						size_t bid, cid, lid;
+						if(singlePass && fwd)
+						{
+							bid = 1 + radix/2;
+							lid = r;
+							cid = r/bid;
+
+							RegBaseAndCountAndPos("", r, regIndex); regIndex += ")";
+							RegBaseAndCountAndPos("", (radix - r)%radix , regIndexPair); regIndexPair += ")";
+						}
+						else
+						{
+							bid = numCR/2;
+
+							if(oddt)
+							{
+								cid = r%2;
+								lid = 1 + (numCR/2);
+
+								RegBaseAndCountAndPos("", r, regIndex); regIndex += ")";
+								RegBaseAndCountAndPos("", r + 1, regIndexPair); regIndexPair += ")";
+							}
+							else
+							{
+								cid = r/bid;
+								lid = 1 + r%bid;
+
+								RegBaseAndCountAndPos("", r, regIndex); regIndex += ")";
+								RegBaseAndCountAndPos("", r + bid, regIndexPair); regIndexPair += ")";
+							}
+						}
+
+
+						if(!cid)
+						{
+							std::string oddpadd = oddp ? " (me/2) + " : " ";
+
+							std::string sclStr = "";
+							if(scale != 1.0f) { sclStr += " * "; sclStr += FloatToStr(scale); sclStr += FloatSuffix<PR>(); }
+
+							if(fwd)
+							{
+								std::string idxStr, idxStrRev;
+								if((length <= 2) || ((length & (length - 1)) != 0))
+								{
+								idxStr += SztToStr(length/(2*workGroupSize)); idxStr += "*me +"; idxStr += oddpadd; idxStr += SztToStr(lid);
+								}
+								else
+								{
+								idxStr += "me + "; idxStr += SztToStr(1 + length*(r%bid)/numCR); idxStr += oddpadd;
+								}
+								idxStrRev += SztToStr(length); idxStrRev += " - ("; idxStrRev += idxStr; idxStrRev += " )";
+
+								std::string val1Str, val2Str;
+
+								if (fft_doPostCallback && !rcFull)
+								{
+									if (interleaved)
+									{
+										val1Str += "\n\t";
+										val1Str += fft_postCallback.funcname; val1Str += "("; val1Str += buffer; val1Str += ", ";
+										val1Str += offset; val1Str += " + ( "; val1Str += idxStr; val1Str += " )*"; val1Str += SztToStr(stride);
+										val1Str += ", post_userdata, ";
+									}
+									else if (c == 0)
+									{
+										val1StrExt += "\n\t";
+										val1StrExt += fft_postCallback.funcname; val1StrExt += "("; val1StrExt += bufferRe; val1StrExt += ", ";
+										val1StrExt += bufferIm; val1StrExt += ", "; val1StrExt += offset; val1StrExt += " + ( "; val1StrExt += idxStr; 
+										val1StrExt += " )*"; val1StrExt += SztToStr(stride); val1StrExt += ", post_userdata, ";
+									}									
+								}
+								else
+								{
+								val1Str += "\n\t";
+								val1Str += buffer; val1Str += "["; val1Str += offset; val1Str += " + ( ";
+								val1Str += idxStr; val1Str += " )*"; val1Str += SztToStr(stride); val1Str += "]";
+								val1Str += tail; val1Str += " = ";
+								}
+
+								val2Str += "\n\t";
+								val2Str += buffer; val2Str += "["; val2Str += offset; val2Str += " + ( ";
+								val2Str += idxStrRev; val2Str += " )*"; val2Str += SztToStr(stride); val2Str += "]";
+								val2Str += tail; val2Str += " = ";
+
+								std::string real1, imag1, real2, imag2;
+
+								real1 +=  "("; real1 += regIndex; real1 += ".x + "; real1 += regIndexPair; real1 += ".x)*0.5";
+								imag1 +=  "("; imag1 += regIndex; imag1 += ".y - "; imag1 += regIndexPair; imag1 += ".y)*0.5";
+								real2 +=  "("; real2 += regIndex; real2 += ".y + "; real2 += regIndexPair; real2 += ".y)*0.5";
+								imag2 += "(-"; imag2 += regIndex; imag2 += ".x + "; imag2 += regIndexPair; imag2 += ".x)*0.5";
+
+								if(interleaved && (component == SR_COMP_BOTH))
+								{
+									val1Str += "("; val1Str += RegBaseType<PR>(2); val1Str += ")( ";
+									val2Str += "("; val2Str += RegBaseType<PR>(2); val2Str += ")( ";
+
+									if(!batch2) { val1Str += real1; val1Str += ", "; val1Str += "+"; val1Str += imag1;
+												  val2Str += real1; val2Str += ", "; val2Str += "-"; val2Str += imag1; }
+									else		{ val1Str += real2; val1Str += ", "; val1Str += "+"; val1Str += imag2;
+												  val2Str += real2; val2Str += ", "; val2Str += "-"; val2Str += imag2; }
+
+									val1Str += " )";
+									val2Str += " )";
+								}
+								else
+								{
+									val1Str += " (";
+									val2Str += " (";
+									if(c == 0)
+									{
+										if(!batch2) { val1Str += real1;
+													  val2Str += real1; }
+										else		{ val1Str += real2;
+													  val2Str += real2; }
+									}
+									else
+									{
+										if(!batch2) { val1Str += "+"; val1Str += imag1;
+													  val2Str += "-"; val2Str += imag1; }
+										else		{ val1Str += "+"; val1Str += imag2;
+													  val2Str += "-"; val2Str += imag2; }
+									}
+									val1Str += " )";
+									val2Str += " )";
+								}
+
+								val1Str += sclStr;
+								val2Str += sclStr;
+
+								if (fft_doPostCallback && !rcFull) 
+								{
+									if (!interleaved) 
+									{
+										val1StrExt += val1Str;
+										val1Str.clear();
+
+										if(c == 0) val1StrExt += ", ";
+										else	val1Str += val1StrExt;
+									}
+
+									if (interleaved || c == (cEnd - 1))
+									{
+										if (fft_postCallback.localMemSize > 0)	val1Str += ", localmem";
+										val1Str += ");";
+									}
+								}
+								else
+								{
+									val1Str += ";";
+								}
+
+												passStr += val1Str; 
+								if(rcFull)	{	passStr += val2Str; passStr += ";"; }
+							}
+							else
+							{
+								std::string idxStr, idxStrRev;
+								if((length <= 2) || ((length & (length - 1)) != 0))
+								{
+								idxStr += SztToStr(bid); idxStr += "*me +"; idxStr += oddpadd; idxStr += SztToStr(lid);
+								}
+								else
+								{								
+								idxStr += "me + "; idxStr += SztToStr(1 + length*(r%bid)/numCR); idxStr += oddpadd;
+								}
+								idxStrRev += SztToStr(length); idxStrRev += " - ("; idxStrRev += idxStr; idxStrRev += " )";
+
+								passStr += "\n\t";
+								passStr += buffer; passStr += "["; passStr += offset; passStr += " + ( ";
+
+								if(!batch2)	passStr += idxStr;
+								else		passStr += idxStrRev;
+
+								passStr += " )*"; passStr += SztToStr(stride); passStr += "]";
+								passStr += tail; passStr += " = ";
+
+								passStr += "( ";
+								if(c == 0)
+								{
+									regIndex += ".x"; 
+									regIndexPair += fft_doPreCallback ? ".y" : ".x";
+
+									if(!batch2)	{ passStr += regIndex; passStr += " - "; passStr += regIndexPair; }
+									else		{ passStr += regIndex; passStr += " + "; passStr += regIndexPair; }
+								}
+								else
+								{
+									regIndex += ".y"; regIndexPair += (fft_doPreCallback && oddt) ? ".x" : ".y";
+
+									if(!batch2)	{					passStr += regIndex; passStr += " + "; passStr += regIndexPair; }
+									else		{ passStr += " - "; passStr += regIndex; passStr += " + "; passStr += regIndexPair; }
+								}
+								passStr += " )";
+								passStr += sclStr;
+								passStr += ";";
+							}
+
+
+
+							// Since we write real & imag at once, we break the loop
+							if(interleaved && (component == SR_COMP_BOTH))
+								break;
+						}
+					}
+				}
+			}
+
+		}
+
+
+		void CallButterfly(const std::string &bflyName, size_t regC, size_t numB, std::string &passStr) const
+		{
+			std::string regBase;
+			RegBase(regC, regBase);
+
+			for(size_t i=0; i<numB; i++)
+			{
+				std::string regBaseCount = regBase;
+				RegBaseAndCount(i, regBaseCount);
+
+				passStr += "\n\t";
+				passStr += bflyName;
+				passStr += "(";
+
+				for(size_t r=0; ; r++)
+				{
+					if(linearRegs)
+					{
+						std::string regIndex = "R";
+						RegBaseAndCountAndPos("", i*radix + r, regIndex);
+
+						passStr += regIndex;
+					}
+					else
+					{
+						std::string regRealIndex(regBaseCount);
+						std::string regImagIndex(regBaseCount);
+						RegBaseAndCountAndPos("R", r, regRealIndex);
+						RegBaseAndCountAndPos("I", r, regImagIndex);
+
+						passStr += "&"; passStr += regRealIndex; passStr += ", ";
+						passStr += "&"; passStr += regImagIndex;
+					}
+
+					if(r == radix-1)
+					{
+						passStr += ");";
+						break;
+					}
+					else
+					{
+						passStr += ", ";
+					}
+				}
+			}
+		}
+
+    public:
+		Pass(	size_t positionVal, size_t lengthVal, size_t radixVal, size_t cnPerWIVal,
+				size_t L, size_t LS, size_t R, bool linearRegsVal, bool halfLdsVal,
+				bool r2cVal, bool c2rVal, bool rcFullVal, bool rcSimpleVal, bool realSpecialVal) :
+			position(positionVal), length(lengthVal), radix(radixVal), cnPerWI(cnPerWIVal),
+			algL(L), algLS(LS), algR(R), linearRegs(linearRegsVal), halfLds(halfLdsVal),
+			r2c(r2cVal), c2r(c2rVal), rcFull(rcFullVal), rcSimple(rcSimpleVal), realSpecial(realSpecialVal),
+			enableGrouping(true),
+			numB1(0), numB2(0), numB4(0),
+			nextPass(NULL), fft_doPreCallback(false), fft_doPostCallback(false)
+		{
+			assert(radix <= length);
+			assert(length%radix == 0);
+
+			numButterfly = cnPerWI/radix;
+			workGroupSize = length/cnPerWI;
+
+			// Total number of butterflies (over all work-tems) must be divisible by LS
+			assert( ((numButterfly*workGroupSize)%algLS) == 0 );
+
+			// All butterflies in one work-item should always be part of no more than 1 FFT transform.
+			// In other words, there should not be more than 1 FFT transform per work-item.
+			assert(cnPerWI <= length);
+
+			// Calculate the different types of Butterflies needed
+			if(linearRegs || r2c || c2r)
+			{
+				numB1 = numButterfly;
+			}
+			else
+			{
+				numB4 = numButterfly/4;
+				numB2 = (numButterfly%4)/2; // can be 0 or 1
+				numB1 = (numButterfly%2); // can be 0 or 1
+
+				assert(numButterfly == (numB4*4 + numB2*2 + numB1));
+			}
+
+			// if only half LDS can be used, we need the passes to share registers
+			// and hence they need to be linear registers
+			if(halfLds) assert(linearRegs);
+		}
+
+		size_t GetNumB1() const { return numB1; }
+		size_t GetNumB2() const { return numB2; }
+		size_t GetNumB4() const { return numB4; }
+
+		size_t GetPosition() const { return position; }
+		size_t GetRadix() const { return radix; }
+
+		void SetNextPass(Pass<PR> *np) { nextPass = np; }
+		void SetGrouping(bool grp) { enableGrouping = grp; }
+
+		void SetPrecallback(bool hasPrecallback, clfftCallbackParam precallbackParam) 
+		{ 
+			fft_doPreCallback = hasPrecallback;
+			fft_preCallback = precallbackParam;
+		}
+
+		void SetPostcallback(bool hasPostcallback, clfftCallbackParam postcallbackParam) 
+		{ 
+			fft_doPostCallback = hasPostcallback;
+			fft_postCallback = postcallbackParam;
+		}
+
+		void GeneratePass(	bool fwd, std::string &passStr, bool fft_3StepTwiddle, bool twiddleFront,
+							bool inInterleaved, bool outInterleaved,
+							bool inReal, bool outReal,
+							size_t inStride, size_t outStride, double scale,
+							bool gIn = false, bool gOut = false) const
+		{
+			const std::string bufferInRe  = (inReal || inInterleaved) ?   "bufIn"  : "bufInRe";
+			const std::string bufferInIm  = (inReal || inInterleaved) ?   "bufIn"  : "bufInIm";
+			const std::string bufferOutRe = (outReal || outInterleaved) ? "bufOut" : "bufOutRe";
+			const std::string bufferOutIm = (outReal || outInterleaved) ? "bufOut" : "bufOutIm";
+
+			const std::string bufferInRe2  = (inReal || inInterleaved) ?   "bufIn2"  : "bufInRe2";
+			const std::string bufferInIm2  = (inReal || inInterleaved) ?   "bufIn2"  : "bufInIm2";
+			const std::string bufferOutRe2 = (outReal || outInterleaved) ? "bufOut2" : "bufOutRe2";
+			const std::string bufferOutIm2 = (outReal || outInterleaved) ? "bufOut2" : "bufOutIm2";
+
+			// for real transforms we use only B1 butteflies (regC = 1)
+			if(r2c || c2r)
+			{
+				assert(numB1 == numButterfly);
+				assert(linearRegs);
+			}
+
+			// Check if it is single pass transform
+			bool singlePass = ((position == 0) && (nextPass == NULL));
+			if(singlePass) assert(numButterfly == 1); // for single pass transforms, there can be only 1 butterfly per transform
+			if(singlePass) assert(workGroupSize == 1);
+
+			// Register types
+			std::string regB1Type = RegBaseType<PR>(1);
+			std::string regB2Type = RegBaseType<PR>(2);
+			std::string regB4Type = RegBaseType<PR>(4);
+
+			//Function attribute
+			passStr += "__attribute__((always_inline)) void\n";
+
+			//Function name
+			passStr += PassName(position, fwd);
+
+			// Function arguments
+			passStr += "(";
+			passStr += "uint rw, uint b, ";
+			if(realSpecial) passStr += "uint t, ";
+			passStr += "uint me, uint inOffset, uint outOffset, ";
+
+			if(r2c || c2r)
+			{
+				assert(halfLds);
+
+				if(gIn)
+				{
+					if(inInterleaved)
+					{
+										passStr += "__global "; passStr += regB2Type; passStr += " *"; passStr += bufferInRe;  passStr += ", ";
+						if(!rcSimple) {	passStr += "__global "; passStr += regB2Type; passStr += " *"; passStr += bufferInRe2; passStr += ", "; }
+					}
+					else if(inReal)
+					{
+										passStr += "__global "; passStr += regB1Type; passStr += " *"; passStr += bufferInRe;  passStr += ", ";
+						if(!rcSimple) {	passStr += "__global "; passStr += regB1Type; passStr += " *"; passStr += bufferInRe2; passStr += ", "; }
+					}
+					else
+					{
+										passStr += "__global "; passStr += regB1Type; passStr += " *"; passStr += bufferInRe;  passStr += ", ";
+						if(!rcSimple) {	passStr += "__global "; passStr += regB1Type; passStr += " *"; passStr += bufferInRe2; passStr += ", "; }
+										passStr += "__global "; passStr += regB1Type; passStr += " *"; passStr += bufferInIm;  passStr += ", ";
+						if(!rcSimple) {	passStr += "__global "; passStr += regB1Type; passStr += " *"; passStr += bufferInIm2; passStr += ", "; }
+					}
+				}
+				else
+				{
+					passStr += "__local "; passStr += regB1Type; passStr += " *"; passStr += bufferInRe; passStr += ", ";
+					passStr += "__local "; passStr += regB1Type; passStr += " *"; passStr += bufferInIm; passStr += ", ";
+				}
+
+				if(gOut)
+				{
+					if(outInterleaved)
+					{
+															passStr += "__global "; passStr += regB2Type; passStr += " *"; passStr += bufferOutRe;
+						if(!rcSimple) { passStr += ", ";	passStr += "__global "; passStr += regB2Type; passStr += " *"; passStr += bufferOutRe2; }
+					}
+					else if(outReal)
+					{
+															passStr += "__global "; passStr += regB1Type; passStr += " *"; passStr += bufferOutRe;
+						if(!rcSimple) { passStr += ", ";	passStr += "__global "; passStr += regB1Type; passStr += " *"; passStr += bufferOutRe2; }
+					}
+					else
+					{
+															passStr += "__global "; passStr += regB1Type; passStr += " *"; passStr += bufferOutRe;  passStr += ", ";
+						if(!rcSimple) {						passStr += "__global "; passStr += regB1Type; passStr += " *"; passStr += bufferOutRe2; passStr += ", "; }
+															passStr += "__global "; passStr += regB1Type; passStr += " *"; passStr += bufferOutIm;
+						if(!rcSimple) { passStr += ", ";	passStr += "__global "; passStr += regB1Type; passStr += " *"; passStr += bufferOutIm2; }
+					}
+				}
+				else
+				{
+					passStr += "__local "; passStr += regB1Type; passStr += " *"; passStr += bufferOutRe; passStr += ", ";
+					passStr += "__local "; passStr += regB1Type; passStr += " *"; passStr += bufferOutIm;
+				}
+			}
+			else
+			{
+				if(gIn)
+				{
+					if(inInterleaved)
+					{
+						passStr += "__global "; passStr += regB2Type; passStr += " *"; passStr += bufferInRe;  passStr += ", ";
+					}
+					else
+					{
+						passStr += "__global "; passStr += regB1Type; passStr += " *"; passStr += bufferInRe;  passStr += ", ";
+						passStr += "__global "; passStr += regB1Type; passStr += " *"; passStr += bufferInIm;  passStr += ", ";
+					}
+				}
+				else
+				{
+					if(inInterleaved)
+					{
+						passStr += "__local "; passStr += regB2Type; passStr += " *"; passStr += bufferInRe;  passStr += ", ";
+					}
+					else
+					{
+						passStr += "__local "; passStr += regB1Type; passStr += " *"; passStr += bufferInRe; passStr += ", ";
+						passStr += "__local "; passStr += regB1Type; passStr += " *"; passStr += bufferInIm; passStr += ", ";
+					}
+				}
+
+
+				if(gOut)
+				{
+					if(outInterleaved)
+					{
+						passStr += "__global "; passStr += regB2Type; passStr += " *"; passStr += bufferOutRe;
+					}
+					else
+					{
+						passStr += "__global "; passStr += regB1Type; passStr += " *"; passStr += bufferOutRe;  passStr += ", ";
+						passStr += "__global "; passStr += regB1Type; passStr += " *"; passStr += bufferOutIm;
+					}
+				}
+				else
+				{
+					if(outInterleaved)
+					{
+						passStr += "__local "; passStr += regB2Type; passStr += " *"; passStr += bufferOutRe;
+					}
+					else
+					{
+						passStr += "__local "; passStr += regB1Type; passStr += " *"; passStr += bufferOutRe; passStr += ", ";
+						passStr += "__local "; passStr += regB1Type; passStr += " *"; passStr += bufferOutIm;
+					}
+				}
+			}
+
+			// Register arguments
+			if(linearRegs)
+			{
+				passStr += ", "; passStr += IterRegArgs();
+			}
+
+			if (fft_doPreCallback || fft_doPostCallback)
+			{
+				//Include pre-callback parameters if pre-callback is set
+			if (fft_doPreCallback )
+			{
+				if ((r2c && !rcSimple) || c2r)
+				{
+					passStr += ", uint inOffset2";
+				}
+
+					passStr += ", __global void* pre_userdata";
+				}
+
+				//Include post-callback parameters if post-callback is set
+				if (fft_doPostCallback )
+				{
+					if (r2c || (c2r && !rcSimple))
+					{
+						passStr += ", uint outOffset2";
+					}
+					passStr += ", __global void* post_userdata";
+				}
+
+				if (fft_doPreCallback && fft_preCallback.localMemSize > 0)
+				{
+					passStr += ", __local void* localmem";
+				}
+				if (fft_doPostCallback && fft_postCallback.localMemSize > 0)
+				{
+					passStr += ", __local void* post_localmem";
+				}
+			}
+
+			passStr += ")\n{\n";
+
+			// Register Declarations
+			if(!linearRegs)
+			{
+				DeclareRegs(regB1Type, 1, numB1, passStr);
+				DeclareRegs(regB2Type, 2, numB2, passStr);
+				DeclareRegs(regB4Type, 4, numB4, passStr);
+			}
+
+			// odd cnPerWI processing
+			bool oddp = false;
+			oddp = ((cnPerWI%2) && (length > 1) && (!singlePass));
+
+			// additional register for odd
+			if( !rcSimple && oddp && ((r2c && (nextPass == NULL)) || (c2r && (position == 0))) )
+			{
+				passStr += "\n\t";
+				passStr += "uint brv = 0;\n\t";
+				passStr += "\n\t";
+				passStr += regB2Type; passStr += " R"; passStr += SztToStr(cnPerWI); passStr += "[1];\n\t";
+				passStr += "(*R"; passStr += SztToStr(cnPerWI); passStr += ").x = 0; ";
+				passStr += "(*R"; passStr += SztToStr(cnPerWI); passStr += ").y = 0;\n";
+			}
+
+			// Special private memory for c-r 1 pass transforms
+			if( !rcSimple && (c2r && (position == 0)) && singlePass )
+			{
+				assert(radix == length);
+
+				passStr += "\n\t";
+				passStr += regB1Type;
+				passStr += " mpvt["; passStr += SztToStr(length); passStr += "];\n";
+			}
+
+			passStr += "\n";
+
+			// Read into registers
+			if(r2c)
+			{
+				if(position == 0)
+				{
+					passStr += "\n\tif(rw)\n\t{";
+					SweepRegs(SR_READ, fwd, inInterleaved, inStride, SR_COMP_REAL, 1.0f, false, bufferInRe, bufferInIm, "inOffset", 1, numB1, 0, passStr);
+					passStr += "\n\t}\n";
+
+					if(rcSimple)
+					{
+						passStr += "\n";
+						SweepRegsRC(SR_READ, fwd, inInterleaved, inStride, SR_COMP_IMAG, 1.0f, true, true, false, bufferInRe2, bufferInIm2, "inOffset", passStr);
+						passStr += "\n";
+					}
+					else
+					{
+						passStr += "\n\tif(rw > 1)\n\t{";
+						if (fft_doPreCallback)
+						{
+							SweepRegs(SR_READ, fwd, inInterleaved, inStride, SR_COMP_IMAG, 1.0f, false, bufferInRe2, bufferInIm2, "inOffset2", 1, numB1, 0, passStr);
+						}
+						else
+						{
+							SweepRegs(SR_READ, fwd, inInterleaved, inStride, SR_COMP_IMAG, 1.0f, false, bufferInRe2, bufferInIm2, "inOffset", 1, numB1, 0, passStr);
+						}
+						passStr += "\n\t}\n";
+
+						passStr += "\telse\n\t{";
+						SweepRegsRC(SR_READ, fwd, inInterleaved, inStride, SR_COMP_IMAG, 1.0f, true, true, false, bufferInRe2, bufferInIm2, "inOffset", passStr);
+						passStr += "\n\t}\n";
+					}
+				}
+			}
+			else if(c2r && !rcSimple)
+			{
+				if(position == 0)
+				{
+					std::string processBufRe = bufferOutRe;
+					std::string processBufIm = bufferOutIm;
+					std::string processBufOffset = "outOffset";
+					size_t processBufStride = outStride;
+
+					if(singlePass)
+					{
+						processBufRe = "mpvt";
+						processBufIm = "mpvt";
+						processBufOffset = "0";
+						processBufStride = 1;
+					}
+
+					passStr += "\n\tif(rw && !me)\n\t{\n\t";
+					passStr += processBufRe; passStr += "["; passStr += processBufOffset; passStr += "] = ";
+					
+					if (fft_doPreCallback)
+					{
+						passStr += fft_preCallback.funcname; passStr += "("; passStr += bufferInRe; 
+						if (!inInterleaved) { passStr += ", "; passStr += bufferInIm; }
+						passStr += ", inOffset, pre_userdata";
+						passStr += fft_preCallback.localMemSize > 0 ? ", localmem)" : ")";
+					}
+					else
+					{
+						passStr += bufferInRe; passStr+= "[inOffset]";
+					}
+
+					if(inInterleaved || fft_doPreCallback) passStr += ".x;\n\t}"; else passStr += ";\n\t}";
+
+					if(length > 1)
+					{
+						passStr += "\n\n\tif(rw)\n\t{";
+						if (fft_doPreCallback && !inInterleaved)
+						{
+							SweepRegsRC(SR_READ, fwd, inInterleaved, inStride, SR_COMP_REAL, 1.0f, false, false, false, bufferInRe, bufferInIm, "inOffset", passStr);
+						}
+						else
+						{
+							SweepRegsRC(SR_READ, fwd, inInterleaved, inStride, SR_COMP_REAL, 1.0f, false, false, false, bufferInRe, bufferInRe, "inOffset", passStr);
+						}
+						passStr += "\n\t}\n";
+
+						passStr += "\n\tif(rw > 1)\n\t{";
+						if (fft_doPreCallback)
+						{
+							SweepRegsRC(SR_READ, fwd, inInterleaved, inStride, SR_COMP_REAL, 1.0f, false, true, false, bufferInRe2, bufferInIm2, "inOffset2", passStr);
+						}
+						else
+						{
+							SweepRegsRC(SR_READ, fwd, inInterleaved, inStride, SR_COMP_REAL, 1.0f, false, true, false, bufferInIm2, bufferInIm2, "inOffset", passStr);
+						}
+
+						passStr += "\n\t}\n\telse\n\t{";
+						SweepRegsRC(SR_READ, fwd, inInterleaved, inStride, SR_COMP_REAL, 1.0f, true, true, false, bufferInIm2, bufferInIm2, "inOffset", passStr);
+						passStr += "\n\t}\n";
+
+						if(oddp)
+						{
+							passStr += "\n\tif(rw && (me%2))\n\t{";
+							if (fft_doPreCallback)
+							{
+								SweepRegsRC(SR_READ, fwd, inInterleaved, inStride, SR_COMP_REAL, 1.0f, false, false, true, bufferInRe, bufferInIm, "inOffset", passStr);
+							}
+							else
+							{
+								SweepRegsRC(SR_READ, fwd, inInterleaved, inStride, SR_COMP_REAL, 1.0f, false, false, true, bufferInRe, bufferInRe, "inOffset", passStr);
+							}
+							passStr += "\n\t}";
+							passStr += "\n\tif((rw > 1) && (me%2))\n\t{";
+							if (fft_doPreCallback)
+							{
+								SweepRegsRC(SR_READ, fwd, inInterleaved, inStride, SR_COMP_REAL, 1.0f, false, true, true, bufferInRe2, bufferInIm2, "inOffset2", passStr);
+							}
+							else
+							{
+								SweepRegsRC(SR_READ, fwd, inInterleaved, inStride, SR_COMP_REAL, 1.0f, false, true, true, bufferInIm2, bufferInIm2, "inOffset", passStr);
+							}
+							passStr += "\n\t}\n";
+						}
+
+
+						SweepRegsRC(SR_WRITE, fwd, outInterleaved, processBufStride, SR_COMP_REAL, 1.0f, false, true, false, processBufRe, processBufIm, processBufOffset, passStr);
+						if(oddp)
+						{
+							passStr += "\n\tif(me%2)\n\t{";
+							SweepRegsRC(SR_WRITE, fwd, outInterleaved, processBufStride, SR_COMP_REAL, 1.0f, false, true, true, processBufRe, processBufIm, processBufOffset, passStr);
+							passStr += "\n\t}\n";
+						}
+						SweepRegsRC(SR_WRITE, fwd, outInterleaved, processBufStride, SR_COMP_REAL, 1.0f, false, false, false, processBufRe, processBufIm, processBufOffset, passStr);
+						if(oddp)
+						{
+							passStr += "\n\tif(me%2)\n\t{";
+							SweepRegsRC(SR_WRITE, fwd, outInterleaved, processBufStride, SR_COMP_REAL, 1.0f, false, false, true, processBufRe, processBufIm, processBufOffset, passStr);
+							passStr += "\n\t}\n";
+						}
+					}
+
+					passStr += "\n\n\tbarrier(CLK_LOCAL_MEM_FENCE);\n";
+					SweepRegs(SR_READ, fwd, outInterleaved, processBufStride, SR_COMP_REAL, 1.0f, false, processBufRe, processBufIm, processBufOffset, 1, numB1, 0, passStr, false, oddp);
+					passStr += "\n\n\tbarrier(CLK_LOCAL_MEM_FENCE);\n";
+
+
+					passStr += "\n\tif((rw > 1) && !me)\n\t{\n\t";
+					passStr += processBufIm; passStr += "["; passStr += processBufOffset; passStr += "] = ";
+					
+					if (fft_doPreCallback)
+					{
+						passStr += fft_preCallback.funcname; passStr += "("; passStr += bufferInRe2; 
+						if (!inInterleaved) { passStr += ", "; passStr += bufferInIm2; }
+						passStr += ", inOffset2, pre_userdata";
+						passStr += fft_preCallback.localMemSize > 0 ? ", localmem)" : ")";
+					}
+					else
+					{
+						passStr += bufferInRe2; passStr+= "[inOffset]";
+					}
+					if(inInterleaved || fft_doPreCallback) passStr += ".x;\n\t}"; else passStr += ";\n\t}";
+					passStr += "\n\tif((rw == 1) && !me)\n\t{\n\t"; passStr += processBufIm; passStr += "["; passStr += processBufOffset; passStr += "] = 0;\n\t}";
+
+
+					if(length > 1)
+					{
+						if (!fft_doPreCallback)
+						{
+							passStr += "\n\n\tif(rw)\n\t{";
+							SweepRegsRC(SR_READ, fwd, inInterleaved, inStride, SR_COMP_IMAG, 1.0f, false, false, false, bufferInIm, bufferInIm, "inOffset", passStr);
+							passStr += "\n\t}\n";
+
+							passStr += "\n\tif(rw > 1)\n\t{";
+							SweepRegsRC(SR_READ, fwd, inInterleaved, inStride, SR_COMP_IMAG, 1.0f, false, true, false, bufferInRe2, bufferInRe2, "inOffset", passStr);
+							passStr += "\n\t}\n\telse\n\t{";
+							SweepRegsRC(SR_READ, fwd, inInterleaved, inStride, SR_COMP_IMAG, 1.0f, true, true, false, bufferInRe2, bufferInRe2, "inOffset", passStr);
+							passStr += "\n\t}";
+						
+						
+							if(oddp)
+							{
+								passStr += "\n\tif(rw && (me%2))\n\t{";
+								SweepRegsRC(SR_READ, fwd, inInterleaved, inStride, SR_COMP_IMAG, 1.0f, false, false, true, bufferInIm, bufferInIm, "inOffset", passStr);
+								passStr += "\n\t}";
+								passStr += "\n\tif((rw > 1) && (me%2))\n\t{";
+								SweepRegsRC(SR_READ, fwd, inInterleaved, inStride, SR_COMP_IMAG, 1.0f, false, true, true, bufferInRe2, bufferInRe2, "inOffset", passStr);
+								passStr += "\n\t}";
+							}
+						}
+						passStr += "\n";
+
+						SweepRegsRC(SR_WRITE, fwd, outInterleaved, processBufStride, SR_COMP_IMAG, 1.0f, false, true, false, processBufRe, processBufIm, processBufOffset, passStr);
+						if(oddp)
+						{
+							passStr += "\n\tif(me%2)\n\t{";
+							SweepRegsRC(SR_WRITE, fwd, outInterleaved, processBufStride, SR_COMP_IMAG, 1.0f, false, true, true, processBufRe, processBufIm, processBufOffset, passStr);
+							passStr += "\n\t}\n";
+						}
+						SweepRegsRC(SR_WRITE, fwd, outInterleaved, processBufStride, SR_COMP_IMAG, 1.0f, false, false, false, processBufRe, processBufIm, processBufOffset, passStr);
+						if(oddp)
+						{
+							passStr += "\n\tif(me%2)\n\t{";
+							SweepRegsRC(SR_WRITE, fwd, outInterleaved, processBufStride, SR_COMP_IMAG, 1.0f, false, false, true, processBufRe, processBufIm, processBufOffset, passStr);
+							passStr += "\n\t}\n";
+						}
+					}
+
+					passStr += "\n\n\tbarrier(CLK_LOCAL_MEM_FENCE);\n";
+					SweepRegs(SR_READ, fwd, outInterleaved, processBufStride, SR_COMP_IMAG, 1.0f, false, processBufRe, processBufIm, processBufOffset, 1, numB1, 0, passStr);
+					passStr += "\n\n\tbarrier(CLK_LOCAL_MEM_FENCE);\n";
+				}
+			}
+			else
+			{
+				if( (!halfLds) || (halfLds && (position == 0)) )
+				{
+					bool isPrecallVector = false;
+					//If precallback is set
+					if (fft_doPreCallback)
+					{
+						passStr += "\n\t"; passStr += regB2Type; passStr += " retPrecallback"; 
+						
+						if (numB4 > 0 || numB2 > 0)
+						{
+							passStr += "["; 
+							passStr += (numB4 > 0) ? "4" : (numB2 > 0) ? "2" : "1"; 
+							passStr += "]";
+
+							isPrecallVector = true;
+						}
+						passStr += ";";
+					}
+					passStr += "\n\tif(rw)\n\t{";
+					SweepRegs(SR_READ, fwd, inInterleaved, inStride, SR_COMP_BOTH, 1.0f, false, bufferInRe, bufferInIm, "inOffset", 1, numB1, 0, passStr, isPrecallVector);
+					SweepRegs(SR_READ, fwd, inInterleaved, inStride, SR_COMP_BOTH, 1.0f, false, bufferInRe, bufferInIm, "inOffset", 2, numB2, numB1, passStr, isPrecallVector);
+					SweepRegs(SR_READ, fwd, inInterleaved, inStride, SR_COMP_BOTH, 1.0f, false, bufferInRe, bufferInIm, "inOffset", 4, numB4, 2*numB2 + numB1, passStr, isPrecallVector);
+					passStr += "\n\t}\n";
+				}
+			}
+
+			passStr += "\n";
+
+			// 3-step twiddle multiplies done in the front
+			bool tw3Done = false;
+			if(fft_3StepTwiddle && twiddleFront)
+			{
+				tw3Done = true;
+				if(linearRegs)
+				{
+					SweepRegs(SR_TWMUL_3STEP, fwd, false, 1, SR_COMP_BOTH, 1.0f, true, bufferInRe, bufferInIm, "", 1, numB1, 0, passStr);
+				}
+				else
+				{
+					SweepRegs(SR_TWMUL_3STEP, fwd, false, 1, SR_COMP_BOTH, 1.0f, true, bufferInRe, bufferInIm, "", 1, numB1, 0, passStr);
+					SweepRegs(SR_TWMUL_3STEP, fwd, false, 1, SR_COMP_BOTH, 1.0f, true, bufferInRe, bufferInIm, "", 2, numB2, numB1, passStr);
+					SweepRegs(SR_TWMUL_3STEP, fwd, false, 1, SR_COMP_BOTH, 1.0f, true, bufferInRe, bufferInIm, "", 4, numB4, 2*numB2 + numB1, passStr);
+				}
+			}
+
+			passStr += "\n";
+
+			// Twiddle multiply
+			if( (position > 0) && (radix > 1) )
+			{
+				SweepRegs(SR_TWMUL, fwd, false, 1, SR_COMP_BOTH, 1.0f, false, bufferInRe, bufferInIm, "", 1, numB1, 0, passStr);
+				SweepRegs(SR_TWMUL, fwd, false, 1, SR_COMP_BOTH, 1.0f, false, bufferInRe, bufferInIm, "", 2, numB2, numB1, passStr);
+				SweepRegs(SR_TWMUL, fwd, false, 1, SR_COMP_BOTH, 1.0f, false, bufferInRe, bufferInIm, "", 4, numB4, 2*numB2 + numB1, passStr);
+			}
+
+			// Butterfly calls
+			if(radix > 1)
+			{
+				if(numB1) CallButterfly(ButterflyName(radix, 1, fwd), 1, numB1, passStr);
+				if(numB2) CallButterfly(ButterflyName(radix, 2, fwd), 2, numB2, passStr);
+				if(numB4) CallButterfly(ButterflyName(radix, 4, fwd), 4, numB4, passStr);
+			}
+
+
+			if(!halfLds) passStr += "\n\n\tbarrier(CLK_LOCAL_MEM_FENCE);\n";
+			passStr += "\n\n";
+
+			// 3-step twiddle multiplies
+			if(fft_3StepTwiddle && !tw3Done)
+			{
+				assert(nextPass == NULL);
+				if(linearRegs)
+				{
+					SweepRegs(SR_TWMUL_3STEP, fwd, false, 1, SR_COMP_BOTH, 1.0f, false, bufferInRe, bufferInIm, "", 1, numB1, 0, passStr);
+				}
+				else
+				{
+					SweepRegs(SR_TWMUL_3STEP, fwd, false, 1, SR_COMP_BOTH, 1.0f, false, bufferInRe, bufferInIm, "", 1, numB1, 0, passStr);
+					SweepRegs(SR_TWMUL_3STEP, fwd, false, 1, SR_COMP_BOTH, 1.0f, false, bufferInRe, bufferInIm, "", 2, numB2, numB1, passStr);
+					SweepRegs(SR_TWMUL_3STEP, fwd, false, 1, SR_COMP_BOTH, 1.0f, false, bufferInRe, bufferInIm, "", 4, numB4, 2*numB2 + numB1, passStr);
+				}
+			}
+
+			// Write back from registers
+			if(halfLds)
+			{
+				// In this case, we have to write & again read back for the next pass since we are
+				// using only half the lds. Number of barriers will increase at the cost of halving the lds.
+
+				if(nextPass == NULL) // last pass
+				{
+					if(r2c && !rcSimple)
+					{
+						if(!singlePass)
+						{
+							SweepRegs(SR_WRITE, fwd, inInterleaved, inStride, SR_COMP_REAL, 1.0f, false, bufferInRe, bufferInIm, "inOffset", 1, numB1, 0, passStr);
+							passStr += "\n\n\tbarrier(CLK_LOCAL_MEM_FENCE);\n";
+							SweepRegsRC(SR_READ, fwd, inInterleaved, inStride, SR_COMP_REAL, 1.0f, false, false, false, bufferInRe, bufferInIm, "inOffset", passStr);
+							if(oddp)
+							{
+								passStr += "\n\tif(me%2)\n\t{";
+								SweepRegsRC(SR_READ, fwd, inInterleaved, inStride, SR_COMP_REAL, 1.0f, false, false, true, bufferInRe, bufferInIm, "inOffset", passStr);
+								passStr += "\n\t}\n";
+							}
+
+							passStr += "\n\tif(rw && !me)\n\t{\n\t";
+							if(outInterleaved)
+							{
+								if (fft_doPostCallback)
+								{
+									passStr += fft_postCallback.funcname; passStr += "(bufOut, outOffset, post_userdata, ";
+									passStr += "("; passStr += RegBaseType<PR>(2); passStr += ") ( ("; passStr += bufferInRe; passStr += "[inOffset]";
+									if(scale != 1.0) { passStr += " * "; passStr += FloatToStr(scale); passStr += FloatSuffix<PR>(); } passStr += ") , 0 )";
+									if (fft_postCallback.localMemSize > 0)
+									{
+										passStr += ", localmem";
+									}
+									passStr += ");\n\t}";
+								}
+								else
+								{
+								passStr += bufferOutRe; passStr+= "[outOffset].x = "; passStr += bufferInRe; passStr += "[inOffset]";
+								if(scale != 1.0) { passStr += " * "; passStr += FloatToStr(scale); passStr += FloatSuffix<PR>(); } passStr += ";\n\t";
+								passStr += bufferOutIm; passStr+= "[outOffset].y = "; passStr += "0;\n\t}";
+							}
+							}
+							else
+							{
+								if (fft_doPostCallback)
+								{
+									passStr += fft_postCallback.funcname; passStr += "("; passStr += bufferOutRe; passStr += ", "; passStr += bufferOutIm;
+									passStr += ", outOffset, post_userdata, "; passStr += bufferInRe; passStr += "[inOffset]";
+									if(scale != 1.0) { passStr += " * "; passStr += FloatToStr(scale); passStr += FloatSuffix<PR>(); } passStr += ", 0";
+									if (fft_postCallback.localMemSize > 0)
+									{
+										passStr += ", localmem";
+									}
+									passStr += ");\n\t}";
+								}
+							else
+							{
+								passStr += bufferOutRe; passStr+= "[outOffset] = ";   passStr += bufferInRe; passStr += "[inOffset]";
+								if(scale != 1.0) { passStr += " * "; passStr += FloatToStr(scale); passStr += FloatSuffix<PR>(); } passStr += ";\n\t";
+								passStr += bufferOutIm; passStr+= "[outOffset] = ";   passStr += "0;\n\t}";
+							}
+							}
+							passStr += "\n\n\tbarrier(CLK_LOCAL_MEM_FENCE);\n";
+
+
+							SweepRegs(SR_WRITE, fwd, inInterleaved, inStride, SR_COMP_IMAG, 1.0f, false, bufferInRe, bufferInIm, "inOffset", 1, numB1, 0, passStr);
+							passStr += "\n\n\tbarrier(CLK_LOCAL_MEM_FENCE);\n";
+							SweepRegsRC(SR_READ, fwd, inInterleaved, inStride, SR_COMP_IMAG, 1.0f, false, false, false, bufferInRe, bufferInIm, "inOffset", passStr);
+							if(oddp)
+							{
+								passStr += "\n\tif(me%2)\n\t{";
+								SweepRegsRC(SR_READ, fwd, inInterleaved, inStride, SR_COMP_IMAG, 1.0f, false, false, true, bufferInRe, bufferInIm, "inOffset", passStr);
+								passStr += "\n\t}\n";
+							}
+
+							passStr += "\n\tif((rw > 1) && !me)\n\t{\n\t";
+							if(outInterleaved)
+							{
+								if (fft_doPostCallback)
+								{
+									passStr += fft_postCallback.funcname; passStr += "(bufOut2, outOffset2, post_userdata, ";
+									passStr += "("; passStr += RegBaseType<PR>(2); passStr += ") ( ("; passStr += bufferInIm; passStr += "[inOffset]";
+									if(scale != 1.0) { passStr += " * "; passStr += FloatToStr(scale); passStr += FloatSuffix<PR>(); } passStr += ") , 0 )";
+									if (fft_postCallback.localMemSize > 0)
+									{
+										passStr += ", localmem";
+									}
+									passStr += ");\n\t}";
+								}
+								else
+								{
+								passStr += bufferOutRe2; passStr+= "[outOffset].x = "; passStr += bufferInIm; passStr += "[inOffset]";
+								if(scale != 1.0) { passStr += " * "; passStr += FloatToStr(scale); passStr += FloatSuffix<PR>(); } passStr += ";\n\t";
+								passStr += bufferOutIm2; passStr+= "[outOffset].y = "; passStr += "0;\n\t}";
+							}
+							}
+							else
+							{
+								if (fft_doPostCallback)
+								{
+									passStr += fft_postCallback.funcname; passStr += "("; passStr += bufferOutRe2; passStr += ", "; passStr += bufferOutIm2;
+									passStr+= ", outOffset2, post_userdata, "; passStr += bufferInIm; passStr += "[inOffset]";
+									if(scale != 1.0) { passStr += " * "; passStr += FloatToStr(scale); passStr += FloatSuffix<PR>(); } passStr += ", 0";
+									if (fft_postCallback.localMemSize > 0)
+									{
+										passStr += ", localmem";
+									}
+									passStr += ");\n\t}";
+								}
+							else
+							{
+								passStr += bufferOutRe2; passStr+= "[outOffset] = ";   passStr += bufferInIm; passStr += "[inOffset]";
+								if(scale != 1.0) { passStr += " * "; passStr += FloatToStr(scale); passStr += FloatSuffix<PR>(); } passStr += ";\n\t";
+								passStr += bufferOutIm2; passStr+= "[outOffset] = ";   passStr += "0;\n\t}";
+							}
+							}
+							passStr += "\n\n\tbarrier(CLK_LOCAL_MEM_FENCE);\n";
+						}
+
+
+						passStr += "\n\n\tif(rw)\n\t{";
+						SweepRegsRC(SR_WRITE, fwd, outInterleaved, outStride, SR_COMP_BOTH, scale, false, false, false, bufferOutRe, bufferOutIm, "outOffset", passStr);
+						passStr += "\n\t}\n";
+						if(oddp)
+						{
+							passStr += "\n\n\tbrv = ((rw != 0) & (me%2 == 1));\n\t";
+							passStr += "if(brv)\n\t{";
+							SweepRegsRC(SR_WRITE, fwd, outInterleaved, outStride, SR_COMP_BOTH, scale, false, false, true, bufferOutRe, bufferOutIm, "outOffset", passStr);
+							passStr += "\n\t}\n";
+						}
+
+						passStr += "\n\n\tif(rw > 1)\n\t{";
+						
+						std::string outOffset;
+						outOffset += "outOffset";
+						if (fft_doPostCallback) outOffset += "2";
+
+						SweepRegsRC(SR_WRITE, fwd, outInterleaved, outStride, SR_COMP_BOTH, scale, false, true, false, bufferOutRe2, bufferOutIm2, outOffset, passStr);
+						passStr += "\n\t}\n";
+						if(oddp)
+						{
+							passStr += "\n\n\tbrv = ((rw > 1) & (me%2 == 1));\n\t";
+							passStr += "if(brv)\n\t{";
+							SweepRegsRC(SR_WRITE, fwd, outInterleaved, outStride, SR_COMP_BOTH, scale, false, true, true, bufferOutRe2, bufferOutIm2, outOffset, passStr);
+							passStr += "\n\t}\n";
+						}
+
+					}
+					else if(c2r)
+					{
+						passStr += "\n\tif(rw)\n\t{";
+						SweepRegs(SR_WRITE, fwd, outInterleaved, outStride, SR_COMP_REAL, scale, false, bufferOutRe, bufferOutIm, "outOffset", 1, numB1, 0, passStr);
+						passStr += "\n\t}\n";
+
+						if(!rcSimple)
+						{
+							std::string outOffset;
+							outOffset += "outOffset";
+							if (fft_doPostCallback) outOffset += "2";
+
+							passStr += "\n\tif(rw > 1)\n\t{";
+							SweepRegs(SR_WRITE, fwd, outInterleaved, outStride, SR_COMP_IMAG, scale, false, bufferOutRe2, bufferOutIm2, outOffset, 1, numB1, 0, passStr);
+							passStr += "\n\t}\n";
+						}
+					}
+					else
+					{
+						passStr += "\n\tif(rw)\n\t{";
+						SweepRegs(SR_WRITE, fwd, outInterleaved, outStride, SR_COMP_BOTH, scale, false, bufferOutRe, bufferOutIm, "outOffset", 1, numB1, 0, passStr);
+						passStr += "\n\t}\n";
+					}
+				}
+				else
+				{
+					passStr += "\n\tif(rw)\n\t{";
+					SweepRegs(SR_WRITE, fwd, outInterleaved, outStride, SR_COMP_REAL, scale, false, bufferOutRe, bufferOutIm, "outOffset", 1, numB1, 0, passStr);
+					passStr += "\n\t}\n";
+					passStr += "\n\n\tbarrier(CLK_LOCAL_MEM_FENCE);\n";
+					passStr += "\n\tif(rw)\n\t{";
+					nextPass->SweepRegs(SR_READ, fwd, outInterleaved, outStride, SR_COMP_REAL, scale, false, bufferOutRe, bufferOutIm, "outOffset", 1, nextPass->GetNumB1(), 0, passStr);
+					passStr += "\n\t}\n";
+					passStr += "\n\n\tbarrier(CLK_LOCAL_MEM_FENCE);\n";
+					passStr += "\n\tif(rw)\n\t{";
+					SweepRegs(SR_WRITE, fwd, outInterleaved, outStride, SR_COMP_IMAG, scale, false, bufferOutRe, bufferOutIm, "outOffset", 1, numB1, 0, passStr);
+					passStr += "\n\t}\n";
+					passStr += "\n\n\tbarrier(CLK_LOCAL_MEM_FENCE);\n";
+					passStr += "\n\tif(rw)\n\t{";
+					nextPass->SweepRegs(SR_READ, fwd, outInterleaved, outStride, SR_COMP_IMAG, scale, false, bufferOutRe, bufferOutIm, "outOffset", 1, nextPass->GetNumB1(), 0, passStr);
+					passStr += "\n\t}\n";
+					passStr += "\n\n\tbarrier(CLK_LOCAL_MEM_FENCE);\n";
+				}
+			}
+			else
+			{
+				if (fft_doPostCallback && outInterleaved)
+				{
+					passStr += "\n\t"; passStr += regB2Type; passStr += " tempC;";
+				}
+				passStr += "\n\tif(rw)\n\t{";
+				SweepRegs(SR_WRITE, fwd, outInterleaved, outStride, SR_COMP_BOTH, scale, false, bufferOutRe, bufferOutIm, "outOffset", 1, numB1, 0, passStr);
+				SweepRegs(SR_WRITE, fwd, outInterleaved, outStride, SR_COMP_BOTH, scale, false, bufferOutRe, bufferOutIm, "outOffset", 2, numB2, numB1, passStr);
+				SweepRegs(SR_WRITE, fwd, outInterleaved, outStride, SR_COMP_BOTH, scale, false, bufferOutRe, bufferOutIm, "outOffset", 4, numB4, 2*numB2 + numB1, passStr);
+				passStr += "\n\t}\n";
+			}
+
+
+			passStr += "\n}\n\n";
+		}
+    };
+
+    // FFT kernel
+    template <Precision PR>
+    class Kernel
+    {
+        size_t length;							// Length of FFT
+        size_t workGroupSize;					// Work group size
+		size_t cnPerWI;							// complex numbers per work-item
+
+		size_t numTrans;						// Number of transforms per work-group
+		size_t workGroupSizePerTrans;			// Work group subdivision per transform
+		size_t numPasses;						// Number of FFT passes
+        std::vector<size_t> radices;			// Base radix at each pass
+        std::vector<Pass<PR> > passes;			// Array of pass objects
+
+		bool halfLds;							// LDS used to store one component (either real or imaginary) at a time
+												// for passing intermediate data between the passes, if this is set
+												// then each pass-function should accept same set of registers
+
+		bool linearRegs;						// scalar registers
+
+		// Future optimization ideas
+		// bool limitRegs;							// TODO: Incrementally write to LDS, thereby using same set of registers for more than 1 butterflies
+		// bool combineReadTwMul;					// TODO: Combine reading into registers and Twiddle multiply
+
+		bool r2c2r;								// real to complex or complex to real transform
+		bool r2c, c2r;
+		bool rcFull;
+		bool rcSimple;
+
+		bool blockCompute;						// When we have to compute FFT in blocks (either read or write is along columns)
+		BlockComputeType blockComputeType;
+		size_t blockWidth, blockWGS, blockLDS;
+
+		bool realSpecial;
+
+		const FFTKernelGenKeyParams params;		// key params
+
+
+		inline std::string IterRegs(const std::string &pfx, bool initComma = true)
+		{
+			std::string str = "";
+
+			if(linearRegs)
+			{
+				if(initComma) str += ", ";
+
+				for(size_t i=0; i<cnPerWI; i++)
+				{
+					if(i != 0) str += ", ";
+					str += pfx; str += "R";
+					str += SztToStr(i);
+				}
+			}
+
+			return str;
+		}
+
+		inline bool IsGroupedReadWritePossible()
+		{
+			bool possible = true;
+			const size_t *iStride, *oStride;
+
+			if(r2c2r)
+				return false;
+
+			if(realSpecial)
+				return false;
+
+			if(params.fft_placeness == CLFFT_INPLACE)
+			{
+				iStride = oStride = params.fft_inStride;
+			}
+			else
+			{
+				iStride = params.fft_inStride;
+				oStride = params.fft_outStride;
+			}
+
+			for(size_t i=1; i < params.fft_DataDim; i++)
+			{
+				if(iStride[i] % 2) { possible = false; break; }
+				if(oStride[i] % 2) { possible = false; break; }
+			}
+
+			return possible;
+		}
+
+		inline std::string OffsetCalcBlock(const std::string &off, bool input = true)
+		{
+			std::string str;
+
+			const size_t *pStride = input ? params.fft_inStride : params.fft_outStride;
+
+			str += "\t"; str += off; str += " = ";
+			std::string nextBatch = "batch";
+			for(size_t i=(params.fft_DataDim - 1); i>2; i--)
+			{
+				size_t currentLength = 1;
+				for(int j=2; j<i; j++) currentLength *= params.fft_N[j];
+				currentLength *= (params.fft_N[1]/blockWidth);
+
+				str += "("; str += nextBatch; str += "/"; str += SztToStr(currentLength);
+				str += ")*"; str += SztToStr(pStride[i]); str += " + ";
+
+				nextBatch = "(" + nextBatch + "%" + SztToStr(currentLength) + ")";
+			}
+
+			str += "("; str += nextBatch; str += "/"; str += SztToStr(params.fft_N[1]/blockWidth);
+			str += ")*"; str += SztToStr(pStride[2]); str += " + ("; str += nextBatch;
+			str += "%"; str += SztToStr(params.fft_N[1]/blockWidth); str += ")*";
+			if( (input && (blockComputeType == BCT_R2C)) || (!input && (blockComputeType == BCT_C2R)) )
+				str += SztToStr(blockWidth*length);
+			else
+				str += SztToStr(blockWidth);
+			str += ";\n";
+
+			return str;
+		}
+
+		inline std::string OffsetCalc(const std::string &off, bool input = true, bool rc_second_index = false)
+		{
+			std::string str;
+
+			const size_t *pStride = input ? params.fft_inStride : params.fft_outStride;
+
+			std::string batch;
+			if(r2c2r && !rcSimple)
+			{
+				batch += "(batch*"; batch += SztToStr(2*numTrans);
+				if(rc_second_index) batch += " + 1";
+				else				batch += " + 0";
+
+				if(numTrans != 1)	{ batch += " + 2*(me/"; batch += SztToStr(workGroupSizePerTrans); batch += "))"; }
+				else				{ batch += ")"; }
+			}
+			else
+			{
+				if(numTrans == 1)	{	batch += "batch"; }
+				else				{	batch += "(batch*"; batch += SztToStr(numTrans);
+										batch += " + (me/"; batch += SztToStr(workGroupSizePerTrans); batch += "))"; }
+			}
+
+			str += "\t"; str += off; str += " = ";
+			std::string nextBatch = batch;
+			for(size_t i=(params.fft_DataDim - 1); i>1; i--)
+			{
+				size_t currentLength = 1;
+				for(int j=1; j<i; j++) currentLength *= params.fft_N[j];
+
+				str += "("; str += nextBatch; str += "/"; str += SztToStr(currentLength);
+				str += ")*"; str += SztToStr(pStride[i]); str += " + ";
+
+				nextBatch = "(" + nextBatch + "%" + SztToStr(currentLength) + ")";
+			}
+
+			str += nextBatch; str += "*"; str += SztToStr(pStride[1]); str += ";\n";
+
+			return str;
+		}
+
+    public:
+        Kernel( const FFTKernelGenKeyParams &paramsVal) :
+			params(paramsVal), r2c2r(false)
+
+        {
+			length = params.fft_N[0];
+			workGroupSize = params.fft_SIMD;
+			numTrans = (workGroupSize * params.fft_R) / length;
+
+			r2c = false;
+			c2r = false;
+			// Check if it is R2C or C2R transform
+			if(params.fft_inputLayout == CLFFT_REAL)  r2c = true;
+			if(params.fft_outputLayout == CLFFT_REAL) c2r = true;
+			r2c2r = (r2c || c2r);
+
+			if(r2c)
+			{
+				rcFull = (	(params.fft_outputLayout == CLFFT_COMPLEX_INTERLEAVED) ||
+							(params.fft_outputLayout == CLFFT_COMPLEX_PLANAR) ) ? true : false;
+			}
+			if(c2r)
+			{
+				rcFull = (	(params.fft_inputLayout  == CLFFT_COMPLEX_INTERLEAVED) ||
+							(params.fft_inputLayout  == CLFFT_COMPLEX_PLANAR) ) ? true : false;
+			}
+
+			rcSimple = params.fft_RCsimple;
+
+			halfLds = true;
+			linearRegs = true;
+
+			realSpecial = params.fft_realSpecial;
+
+			blockCompute = params.blockCompute;
+			blockComputeType = params.blockComputeType;
+			// Make sure we can utilize all Lds if we are going to
+			// use blocked columns to compute FFTs
+			if(blockCompute)
+			{
+				assert(length <= 256);  // 256 parameter comes from prototype experiments
+										// largest length at which block column possible given 32KB LDS limit
+										// if LDS limit is different this number need to be changed appropriately
+				halfLds = false;
+				linearRegs = true;
+			}
+
+			assert( ((length*numTrans)%workGroupSize) == 0 );
+			cnPerWI = (numTrans * length) / workGroupSize;
+			workGroupSizePerTrans = workGroupSize/numTrans;
+
+			// !!!! IMPORTANT !!!! Keep these assertions unchanged, algorithm depend on these to be true
+			assert( (cnPerWI * workGroupSize) == (numTrans * length) );
+			assert( cnPerWI <= length ); // Don't do more than 1 fft per work-item
+
+			// Breakdown into passes
+
+			size_t LS = 1;
+			size_t L;
+			size_t R = length;
+			size_t pid = 0;
+
+			// See if we can get radices from the lookup table
+			const size_t *pRadices = NULL;
+			size_t nPasses;
+			KernelCoreSpecs<PR> kcs;
+			kcs.GetRadices(length, nPasses, pRadices);
+			if((params.fft_MaxWorkGroupSize >= 256) && (pRadices != NULL))
+			{
+				for(size_t i=0; i<nPasses; i++)
+				{
+					size_t rad = pRadices[i];
+					L = LS * rad;
+					R /= rad;
+
+					radices.push_back(rad);
+					passes.push_back(Pass<PR>(i, length, rad, cnPerWI, L, LS, R, linearRegs, halfLds, r2c, c2r, rcFull, rcSimple, realSpecial));
+					
+					//Pass precallback information to Pass object if its the first pass. 
+					//This will be used in single kernel transforms
+					if (params.fft_hasPreCallback && i == 0 && !params.blockCompute)
+					{
+						passes[0].SetPrecallback(params.fft_hasPreCallback, params.fft_preCallback);
+					}
+
+					//Pass post-callback information to Pass object if its the last pass. 
+					//This will be used in single kernel transforms
+					if (params.fft_hasPostCallback && i == (nPasses - 1) && !params.blockCompute)
+					{
+						passes[i].SetPostcallback(params.fft_hasPostCallback, params.fft_postCallback);
+					}
+
+					LS *= rad;
+				}
+				assert(R == 1); // this has to be true for correct radix composition of the length
+				numPasses = nPasses;
+			}
+			else
+			{
+				// Possible radices
+				size_t cRad[] = {13,11,10,8,7,6,5,4,3,2,1}; // Must be in descending order
+				size_t cRadSize = (sizeof(cRad)/sizeof(cRad[0]));
+
+				// Generate the radix and pass objects
+				while(true)
+				{
+					size_t rad;
+
+					assert(cRadSize >= 1);
+
+					// Picks the radices in descending order (biggest radix first)
+					for(size_t r=0; r<cRadSize; r++)
+					{
+						rad = cRad[r];
+
+						if((rad > cnPerWI) || (cnPerWI%rad))
+							continue;
+
+						if(!(R % rad))
+							break;
+					}
+
+					assert((cnPerWI%rad) == 0);
+
+					L = LS * rad;
+					R /= rad;
+
+					radices.push_back(rad);
+					passes.push_back(Pass<PR>(pid, length, rad, cnPerWI, L, LS, R, linearRegs, halfLds, r2c, c2r, rcFull, rcSimple, realSpecial));
+
+					//Pass precallback information to Pass object if its the first pass. 
+					//This will be used in single kernel transforms
+					if (pid == 0 && params.fft_hasPreCallback)
+					{
+						passes[0].SetPrecallback(params.fft_hasPreCallback, params.fft_preCallback);
+					}
+
+					pid++;
+					LS *= rad;
+
+					assert(R >= 1);
+					if(R == 1)
+						break;
+				}
+				numPasses = pid;
+
+				//Pass post-callback information to Pass object if its the last pass. 
+				//This will be used in single kernel transforms
+				if (params.fft_hasPostCallback)
+				{
+					passes[numPasses - 1].SetPostcallback(params.fft_hasPostCallback, params.fft_postCallback);
+				}
+			}
+
+			assert(numPasses == passes.size());
+			assert(numPasses == radices.size());
+
+#ifdef PARMETERS_TO_BE_READ
+
+			ParamRead pr;
+			ReadParameterFile(pr);
+
+			radices.clear();
+			passes.clear();
+
+			radices = pr.radices;
+			numPasses = radices.size();
+
+			LS = 1;
+			R = length;
+			for(size_t i=0; i<numPasses; i++)
+			{
+				size_t rad = radices[i];
+				L = LS * rad;
+				R /= rad;
+
+				passes.push_back(Pass<PR>(i, length, rad, cnPerWI, L, LS, R, linearRegs));
+
+				LS *= rad;
+			}
+			assert(R == 1);
+#endif
+
+			// Grouping read/writes ok?
+			bool grp = IsGroupedReadWritePossible();
+			for(size_t i=0; i < numPasses; i++)
+				passes[i].SetGrouping(grp);
+
+			// Store the next pass-object pointers
+			if(numPasses > 1)
+				for(size_t i=0; i < (numPasses - 1); i++)
+					passes[i].SetNextPass(&passes[i+1]);
+
+
+			if(blockCompute)
+			{
+				blockWidth = BlockSizes::BlockWidth(length);
+				blockWGS = BlockSizes::BlockWorkGroupSize(length);
+				blockLDS = BlockSizes::BlockLdsSize(length);
+			}
+			else
+			{
+				blockWidth = blockWGS = blockLDS = 0;
+			}
+		}
+
+		class BlockSizes
+		{
+		public:
+			enum ValType
+			{
+				BS_VT_WGS,
+				BS_VT_BWD,
+				BS_VT_LDS,
+			};
+
+			static size_t BlockLdsSize(size_t N) { return GetValue(N, BS_VT_LDS); }
+			static size_t BlockWidth(size_t N) { return GetValue(N, BS_VT_BWD); }
+			static size_t BlockWorkGroupSize(size_t N) { return GetValue(N, BS_VT_WGS); }
+
+		private:
+
+			static size_t GetValue(size_t N, ValType vt)
+			{
+				size_t wgs; // preferred work group size
+				size_t bwd; // block width to be used
+				size_t lds; // LDS size to be used for the block
+
+
+				KernelCoreSpecs<PR> kcs;
+				size_t t_wgs, t_nt;
+				kcs.GetWGSAndNT(N, t_wgs, t_nt);
+
+				switch(N)
+				{
+				case 256:	bwd = 8/PrecisionWidth<PR>();   wgs = (bwd > t_nt) ? 256 : t_wgs; break;
+				case 128:	bwd = 8/PrecisionWidth<PR>();   wgs = (bwd > t_nt) ? 128 : t_wgs; break;
+				case 64:	bwd = 16/PrecisionWidth<PR>();  wgs = (bwd > t_nt) ? 128 : t_wgs; break;
+				case 32:	bwd = 32/PrecisionWidth<PR>();  wgs = (bwd > t_nt) ? 64  : t_wgs; break;
+				case 16:	bwd = 64/PrecisionWidth<PR>();  wgs = (bwd > t_nt) ? 64  : t_wgs; break;
+				case 8:		bwd = 128/PrecisionWidth<PR>(); wgs = (bwd > t_nt) ? 64  : t_wgs; break;
+				default:	assert(false);
+				}
+
+				// block width cannot be less than numTrans, math in other parts of code depend on this assumption
+				assert(bwd >= t_nt);
+
+				lds = N*bwd;
+
+				switch(vt)
+				{
+				case BS_VT_WGS: return wgs;
+				case BS_VT_BWD: return bwd;
+				case BS_VT_LDS: return lds;
+				default: assert(false); return 0;
+				}
+			}
+		};
+
+        void GenerateKernel(std::string &str, cl_device_id Dev_ID)
+		{
+			std::string twType = RegBaseType<PR>(2);
+			std::string rType  = RegBaseType<PR>(1);
+			std::string r2Type  = RegBaseType<PR>(2);
+
+			bool inInterleaved;	 // Input is interleaved format
+			bool outInterleaved; // Output is interleaved format
+			inInterleaved  = (	(params.fft_inputLayout == CLFFT_COMPLEX_INTERLEAVED) ||
+								(params.fft_inputLayout == CLFFT_HERMITIAN_INTERLEAVED) ) ? true : false;
+			outInterleaved = (	(params.fft_outputLayout == CLFFT_COMPLEX_INTERLEAVED) ||
+								(params.fft_outputLayout == CLFFT_HERMITIAN_INTERLEAVED) ) ? true : false;
+
+			// use interleaved LDS when halfLds constraint absent
+			bool ldsInterleaved = inInterleaved || outInterleaved;
+			ldsInterleaved = halfLds ? false : ldsInterleaved;
+			ldsInterleaved = blockCompute ? true : ldsInterleaved;
+
+			bool inReal;  // Input is real format
+			bool outReal; // Output is real format
+			inReal  = (params.fft_inputLayout == CLFFT_REAL) ? true : false;
+			outReal = (params.fft_outputLayout == CLFFT_REAL) ? true : false;
+
+			size_t large1D = 0;
+			if(params.fft_realSpecial)
+				large1D = params.fft_N[0] * params.fft_realSpecial_Nr;
+			else
+				large1D = params.fft_N[0] * params.fft_N[1];
+
+			// Pragma
+			str += ClPragma<PR>();
+
+			// Twiddle table
+			if(length > 1)
+			{
+				TwiddleTable twTable(length);
+
+				str += "\n__constant ";
+				str += twType; str += " ";
+				str += TwTableName();
+				str += "["; str += SztToStr(length-1); str += "] = {\n";
+				twTable.GenerateTwiddleTable<PR>(radices, str);
+				str += "};\n\n";
+			}
+			str += "\n";
+
+			// twiddle factors for 1d-large 3-step algorithm
+			if(params.fft_3StepTwiddle)
+			{
+				TwiddleTableLarge twLarge(large1D);
+				twLarge.GenerateTwiddleTable<PR>(str);
+			}
+
+			std::string sfx = FloatSuffix<PR>();
+
+			// Base type
+			str += "#define fptype "; str += RegBaseType<PR>(1); str += "\n\n";
+
+			// Vector type
+			str += "#define fvect2 "; str += RegBaseType<PR>(2); str += "\n\n";
+
+			bool cReg = linearRegs ? true : false;
+
+			// Generate butterflies for all unique radices
+			std::list<size_t> uradices;
+			for(std::vector<size_t>::const_iterator r = radices.begin(); r != radices.end(); r++)
+				uradices.push_back(*r);
+
+			uradices.sort();
+			uradices.unique();
+
+
+			//constants
+			if (length%8 == 0)
+			{
+				str += "#define C8Q  0.70710678118654752440084436210485"; str += sfx; str += "\n";
+			}
+
+			if (length % 5 == 0)
+			{
+				str += "#define C5QA 0.30901699437494742410229341718282"; str += sfx; str += "\n";
+				str += "#define C5QB 0.95105651629515357211643933337938"; str += sfx; str += "\n";
+				str += "#define C5QC 0.50000000000000000000000000000000"; str += sfx; str += "\n";
+				str += "#define C5QD 0.58778525229247312916870595463907"; str += sfx; str += "\n";
+				str += "#define C5QE 0.80901699437494742410229341718282"; str += sfx; str += "\n";
+			}
+
+			if (length % 3 == 0)
+			{
+				str += "#define C3QA 0.50000000000000000000000000000000"; str += sfx; str += "\n";
+				str += "#define C3QB 0.86602540378443864676372317075294"; str += sfx; str += "\n";
+			}
+
+			if (length % 7 == 0)
+			{
+				str += "#define C7Q1 -1.16666666666666651863693004997913"; str += sfx; str += "\n";
+				str += "#define C7Q2  0.79015646852540022404554065360571"; str += sfx; str += "\n";
+				str += "#define C7Q3  0.05585426728964774240049351305970"; str += sfx; str += "\n";
+				str += "#define C7Q4  0.73430220123575240531721419756650"; str += sfx; str += "\n";
+				str += "#define C7Q5  0.44095855184409837868031445395900"; str += sfx; str += "\n";
+				str += "#define C7Q6  0.34087293062393136944265847887436"; str += sfx; str += "\n";
+				str += "#define C7Q7 -0.53396936033772524066165487965918"; str += sfx; str += "\n";
+				str += "#define C7Q8  0.87484229096165666561546458979137"; str += sfx; str += "\n";
+			}
+
+			if (length % 11 == 0)
+			{
+				str += "#define b11_0 0.9898214418809327"; str += sfx; str += "\n";
+				str += "#define b11_1 0.9594929736144973"; str += sfx; str += "\n";
+				str += "#define b11_2 0.9189859472289947"; str += sfx; str += "\n";
+				str += "#define b11_3 0.8767688310025893"; str += sfx; str += "\n";
+				str += "#define b11_4 0.8308300260037728"; str += sfx; str += "\n";
+				str += "#define b11_5 0.7784344533346518"; str += sfx; str += "\n";
+				str += "#define b11_6 0.7153703234534297"; str += sfx; str += "\n";
+				str += "#define b11_7 0.6343562706824244"; str += sfx; str += "\n";
+				str += "#define b11_8 0.3425847256816375"; str += sfx; str += "\n";
+				str += "#define b11_9 0.5211085581132027"; str += sfx; str += "\n";
+			}
+
+			if (length % 13 == 0)
+			{
+				str += "#define b13_0  0.9682872443619840"; str += sfx; str += "\n";
+				str += "#define b13_1  0.9578059925946651"; str += sfx; str += "\n";
+				str += "#define b13_2  0.8755023024091479"; str += sfx; str += "\n";
+				str += "#define b13_3  0.8660254037844386"; str += sfx; str += "\n";
+				str += "#define b13_4  0.8595425350987748"; str += sfx; str += "\n";
+				str += "#define b13_5  0.8534800018598239"; str += sfx; str += "\n";
+				str += "#define b13_6  0.7693388175729806"; str += sfx; str += "\n";
+				str += "#define b13_7  0.6865583707817543"; str += sfx; str += "\n";
+				str += "#define b13_8  0.6122646503767565"; str += sfx; str += "\n";
+				str += "#define b13_9  0.6004772719326652"; str += sfx; str += "\n";
+				str += "#define b13_10 0.5817047785105157"; str += sfx; str += "\n";
+				str += "#define b13_11 0.5751407294740031"; str += sfx; str += "\n";
+				str += "#define b13_12 0.5220263851612750"; str += sfx; str += "\n";
+				str += "#define b13_13 0.5200285718888646"; str += sfx; str += "\n";
+				str += "#define b13_14 0.5165207806234897"; str += sfx; str += "\n";
+				str += "#define b13_15 0.5149187780863157"; str += sfx; str += "\n";
+				str += "#define b13_16 0.5035370328637666"; str += sfx; str += "\n";
+				str += "#define b13_17 0.5000000000000000"; str += sfx; str += "\n";
+				str += "#define b13_18 0.3027756377319946"; str += sfx; str += "\n";
+				str += "#define b13_19 0.3014792600477098"; str += sfx; str += "\n";
+				str += "#define b13_20 0.3004626062886657"; str += sfx; str += "\n";
+				str += "#define b13_21 0.2517685164318833"; str += sfx; str += "\n";
+				str += "#define b13_22 0.2261094450357824"; str += sfx; str += "\n";
+				str += "#define b13_23 0.0833333333333333"; str += sfx; str += "\n";
+				str += "#define b13_24 0.0386329546443481"; str += sfx; str += "\n";
+			}
+
+			str += "\n";
+
+
+			//If pre-callback is set for the plan
+			std::string callbackstr;
+			if (params.fft_hasPreCallback)
+			{
+				//Insert pre-callback function code at the beginning 
+				callbackstr += params.fft_preCallback.funcstring;
+				callbackstr += "\n\n";
+
+				str += callbackstr;
+			}
+
+			//If post-callback is set for the plan
+			if (params.fft_hasPostCallback)
+			{
+				//Insert post-callback function code 
+				str += params.fft_postCallback.funcstring;
+				str += "\n\n";
+			}
+
+			typename std::vector< Pass<PR> >::const_iterator p;
+			if(length > 1)
+			{
+				for(std::list<size_t>::const_iterator r = uradices.begin(); r != uradices.end(); r++)
+				{
+					size_t rad = *r;
+					p = passes.begin();
+					while(p->GetRadix() != rad) p++;
+
+					for(size_t d=0; d<2; d++)
+					{
+						bool fwd = d ? false : true;
+
+						if(p->GetNumB1()) { Butterfly<PR> bfly(rad, 1, fwd, cReg); bfly.GenerateButterfly(str); str += "\n"; }
+						if(p->GetNumB2()) { Butterfly<PR> bfly(rad, 2, fwd, cReg); bfly.GenerateButterfly(str); str += "\n"; }
+						if(p->GetNumB4()) { Butterfly<PR> bfly(rad, 4, fwd, cReg); bfly.GenerateButterfly(str); str += "\n"; }
+					}
+				}
+			}
+
+			// Generate passes
+			for(size_t d=0; d<2; d++)
+			{
+				bool fwd;
+
+				if(r2c2r)
+				{
+					fwd = r2c;
+				}
+				else
+				{
+					fwd = d ? false : true;
+				}
+
+				double scale = fwd ? params.fft_fwdScale : params.fft_backScale;
+
+				for(p = passes.begin(); p != passes.end(); p++)
+				{
+					double s = 1.0;
+					size_t ins = 1, outs = 1;
+					bool gIn = false, gOut = false;
+					bool inIlvd = false, outIlvd = false;
+					bool inRl = false, outRl = false;
+					bool tw3Step = false;
+
+
+					if(p == passes.begin() && params.fft_twiddleFront ) { tw3Step = params.fft_3StepTwiddle; }
+					if((p+1) == passes.end())	{ s = scale; if(!params.fft_twiddleFront) tw3Step = params.fft_3StepTwiddle; }
+
+					if(blockCompute && !r2c2r)
+					{
+						inIlvd = ldsInterleaved;
+						outIlvd = ldsInterleaved;
+					}
+					else
+					{
+						if(p == passes.begin())		{ inIlvd  = inInterleaved;  inRl  = inReal;  gIn  = true; ins  = params.fft_inStride[0];  }
+						if((p+1) == passes.end())	{ outIlvd = outInterleaved; outRl = outReal; gOut = true; outs = params.fft_outStride[0]; }
+
+						if(p != passes.begin())		{ inIlvd = ldsInterleaved; }
+						if((p+1) != passes.end())	{ outIlvd = ldsInterleaved; }
+					}
+
+					p->GeneratePass(fwd, str, tw3Step, params.fft_twiddleFront, inIlvd, outIlvd, inRl, outRl, ins, outs, s, gIn, gOut);
+				}
+
+				// if real transform we do only 1 direction
+				if(r2c2r)
+					break;
+			}
+
+
+
+			// TODO : address this kludge
+			str += " typedef union  { uint u; int i; } cb_t;\n\n";
+
+			for(size_t d=0; d<2; d++)
+			{
+				bool fwd;
+
+				if(r2c2r)
+				{
+					fwd = inReal ? true : false;
+				}
+				else
+				{
+					fwd = d ? false : true;
+				}
+
+				// FFT kernel begin
+				// Function attribute
+				str += "__kernel __attribute__((reqd_work_group_size (";
+				if(blockCompute)	str += SztToStr(blockWGS);
+				else				str += SztToStr(workGroupSize);
+				str += ",1,1)))\nvoid ";
+
+				// Function name
+				if(fwd) str += "fft_fwd";
+				else	str += "fft_back";
+				str += "(";
+
+        // TODO : address this kludge
+        size_t SizeParam_ret = 0;
+        clGetDeviceInfo(Dev_ID, CL_DEVICE_VENDOR, 0, NULL, &SizeParam_ret);
+        char* nameVendor = new char[SizeParam_ret];
+        clGetDeviceInfo(Dev_ID, CL_DEVICE_VENDOR, SizeParam_ret, nameVendor, NULL);
+
+        //nv compiler doesn't support __constant kernel argument
+        if (strncmp(nameVendor, "NVIDIA",6)!=0)
+          str += "__constant cb_t *cb __attribute__((max_constant_size(32))), ";
+        else
+          str += "__global cb_t *cb, ";
+
+        delete [] nameVendor;
+
+		//If plan has pre/post callback
+		callbackstr.clear();
+		bool hasCallback = params.fft_hasPreCallback || params.fft_hasPostCallback;
+
+		if (hasCallback)
+		{
+		if (params.fft_hasPreCallback)
+		{
+				callbackstr += ", __global void* pre_userdata";
+			}
+			if (params.fft_hasPostCallback)
+			{
+				callbackstr += ", __global void* post_userdata";
+			}
+
+			if (params.fft_preCallback.localMemSize > 0 || params.fft_postCallback.localMemSize > 0)
+			{
+				callbackstr += ", __local void* localmem";
+			}
+		}
+
+				// Function attributes
+				if(params.fft_placeness == CLFFT_INPLACE)
+				{
+					if(r2c2r)
+					{
+						if(outInterleaved)
+						{
+							str += "__global "; str += r2Type; str += " * restrict gb";
+						}
+						else
+						{
+							str += "__global "; str += rType; str += " * restrict gb";
+						}
+
+						//If plan has callback
+						if (hasCallback)
+						{
+							str += callbackstr;
+						}
+
+						str += ")\n";
+					}
+					else
+					{
+						assert(inInterleaved == outInterleaved);
+						assert(params.fft_inStride[1] == params.fft_outStride[1]);
+						assert(params.fft_inStride[0] == params.fft_outStride[0]);
+
+						if(inInterleaved)
+						{
+							str += "__global "; str += r2Type; str += " * restrict gb";
+
+							//If plan has callback
+							if (hasCallback)
+							{
+								str += callbackstr;
+							}
+							
+							str += ")\n";
+						}
+						else
+						{
+							str += "__global "; str += rType; str += " * restrict gbRe, ";
+							str += "__global "; str += rType; str += " * restrict gbIm";
+
+							//If plan has callback
+							if (hasCallback)
+							{
+								str += callbackstr;
+							}
+
+							str += ")\n";
+						}
+					}
+				}
+				else
+				{
+					if(r2c2r)
+					{
+						if(inInterleaved)
+						{
+							str += "__global "; str += r2Type; str += " * restrict gbIn, ";
+						}
+						else if(inReal)
+						{
+							str += "__global "; str += rType; str += " * restrict gbIn, ";
+						}
+						else
+						{
+							str += "__global const "; str += rType; str += " * restrict gbInRe, ";
+							str += "__global const "; str += rType; str += " * restrict gbInIm, ";
+						}
+
+						if(outInterleaved)
+						{
+							str += "__global "; str += r2Type; str += " * restrict gbOut";
+						}
+						else if(outReal)
+						{
+							str += "__global "; str += rType; str += " * restrict gbOut";
+						}
+						else
+						{
+							str += "__global "; str += rType; str += " * restrict gbOutRe, ";
+							str += "__global "; str += rType; str += " * restrict gbOutIm";
+						}
+
+						//If plan has callback
+						if (hasCallback)
+						{
+							str += callbackstr;
+						}
+
+						str += ")\n";
+					}
+					else
+					{
+						if(inInterleaved)
+						{
+							str += "__global const "; str += r2Type; str += " * restrict gbIn, ";
+						}
+						else
+						{
+							str += "__global const "; str += rType; str += " * restrict gbInRe, ";
+							str += "__global const "; str += rType; str += " * restrict gbInIm, ";
+						}
+
+						if(outInterleaved)
+						{
+							str += "__global "; str += r2Type; str += " * restrict gbOut";
+						}
+						else
+						{
+							str += "__global "; str += rType; str += " * restrict gbOutRe, ";
+							str += "__global "; str += rType; str += " * restrict gbOutIm";
+						}
+
+						//If plan has callback
+						if (hasCallback)
+						{
+							str += callbackstr;
+						}
+
+						str += ")\n";
+					}
+				}
+
+				str += "{\n";
+
+				// Initialize
+				str += "\t";
+				str += "uint me = get_local_id(0);\n\t";
+				str += "uint batch = get_group_id(0);";
+				str += "\n";
+
+
+
+				// Allocate LDS
+				if(blockCompute)
+				{
+					str += "\n\t"; str += "__local "; str += r2Type; str += " lds[";
+					str += SztToStr(blockLDS); str += "];\n";
+				}
+				else
+				{
+					size_t ldsSize = halfLds ? length*numTrans : 2*length*numTrans;
+					ldsSize = ldsInterleaved ? ldsSize/2 : ldsSize;
+
+					if(numPasses > 1)
+					{
+						str += "\n\t";
+						str += "__local "; str += ldsInterleaved ? r2Type: rType; str += " lds[";
+						str += SztToStr(ldsSize); str += "];\n";
+					}
+				}
+
+				// Declare memory pointers
+				str += "\n\t";
+				if(r2c2r)
+				{
+					str += "uint iOffset;\n\t";
+					str += "uint oOffset;\n\n\t";
+					if(!rcSimple)
+					{
+						str += "uint iOffset2;\n\t";
+						str += "uint oOffset2;\n\n\t";
+					}
+
+					if (!params.fft_hasPreCallback)	
+					{ 
+						if(inInterleaved)
+						{
+							if(!rcSimple)	{	str += "__global "; str += r2Type; str += " *lwbIn2;\n\t"; }
+												str += "__global "; str += r2Type; str += " *lwbIn;\n\t";  
+						}
+						else if(inReal)
+						{
+							if(!rcSimple)	{	str += "__global "; str += rType; str += " *lwbIn2;\n\t"; }
+												str += "__global "; str += rType; str += " *lwbIn;\n\t";
+
+						}
+						else
+						{
+							if(!rcSimple)	{	str += "__global "; str += rType; str += " *lwbInRe2;\n\t"; }
+							if(!rcSimple)	{	str += "__global "; str += rType; str += " *lwbInIm2;\n\t"; }
+							  
+												str += "__global "; str += rType; str += " *lwbInRe;\n\t"; 
+												str += "__global "; str += rType; str += " *lwbInIm;\n\t"; 
+							
+						}
+					}
+
+					if(outInterleaved)
+					{
+						if (!params.fft_hasPostCallback)	
+						{ 
+						if(!rcSimple)	{	str += "__global "; str += r2Type; str += " *lwbOut2;\n\t"; }
+												str += "__global "; str += r2Type; str += " *lwbOut;\n";
+						}
+					}
+					else if(outReal)
+					{
+						if (!params.fft_hasPostCallback)	
+						{
+						if(!rcSimple)	{	str += "__global "; str += rType; str += " *lwbOut2;\n\t"; }
+												str += "__global "; str += rType; str += " *lwbOut;\n";
+						}
+					}
+					else
+					{
+						if (!params.fft_hasPostCallback)	
+						{
+						if(!rcSimple)	{	str += "__global "; str += rType; str += " *lwbOutRe2;\n\t"; }
+						if(!rcSimple)	{	str += "__global "; str += rType; str += " *lwbOutIm2;\n\t"; }
+											str += "__global "; str += rType; str += " *lwbOutRe;\n\t";
+												str += "__global "; str += rType; str += " *lwbOutIm;\n";
+						}
+					}
+					str += "\n";
+				}
+				else
+				{
+					if(params.fft_placeness == CLFFT_INPLACE)
+					{
+						str += "uint ioOffset;\n\t";
+
+						//Skip if callback is set 
+						if (!params.fft_hasPreCallback || !params.fft_hasPostCallback)
+						{
+							if(inInterleaved)
+							{
+								str += "__global "; str += r2Type; str += " *lwb;\n";
+							}
+							else
+							{
+								str += "__global "; str += rType; str += " *lwbRe;\n\t";
+								str += "__global "; str += rType; str += " *lwbIm;\n";
+							}
+						}
+						str += "\n";
+					}
+					else
+					{
+						str += "uint iOffset;\n\t";
+						str += "uint oOffset;\n\t";
+
+						//Skip if precallback is set 
+						if (!(params.fft_hasPreCallback))
+						{
+							if(inInterleaved)
+							{
+								str += "__global "; str += r2Type; str += " *lwbIn;\n\t";
+							}
+							else
+							{
+								str += "__global "; str += rType; str += " *lwbInRe;\n\t";
+								str += "__global "; str += rType; str += " *lwbInIm;\n\t";
+							}
+						}
+
+						//Skip if postcallback is set 
+						if (!params.fft_hasPostCallback)
+						{
+						if(outInterleaved)
+						{
+								str += "__global "; str += r2Type; str += " *lwbOut;\n";
+						}
+						else
+						{
+							str += "__global "; str += rType; str += " *lwbOutRe;\n\t";
+								str += "__global "; str += rType; str += " *lwbOutIm;\n";
+							}
+						}
+						str += "\n";
+					}
+				}
+
+				// Setup registers if needed
+				if(linearRegs)
+				{
+					str += "\t"; str += RegBaseType<PR>(2);
+					str += " "; str += IterRegs("", false);
+					str += ";\n\n";
+				}
+
+				// Calculate total transform count
+				std::string totalBatch = "(";
+				size_t i = 0;
+				while(i < (params.fft_DataDim - 2))
+				{
+					totalBatch += SztToStr(params.fft_N[i+1]); totalBatch += " * ";
+					i++;
+				}
+				totalBatch += "cb[0].u)";
+
+				// Conditional read-write ('rw') for arbitrary batch number
+				if(r2c2r && !rcSimple)
+				{
+					str += "\tuint this = "; str += totalBatch; str += " - batch*";
+					str +=  SztToStr(2*numTrans); str += ";\n";
+					str += "\tuint rw = (me < ((this+1)/2)*"; str += SztToStr(workGroupSizePerTrans);
+					str += ") ? (this - 2*(me/"; str += SztToStr(workGroupSizePerTrans); str += ")) : 0;\n\n";
+				}
+				else
+				{
+					if( (numTrans > 1) && !blockCompute )
+					{
+						str += "\tuint rw = (me < ("; str += totalBatch;
+						str += " - batch*"; str += SztToStr(numTrans); str += ")*";
+						str += SztToStr(workGroupSizePerTrans); str += ") ? 1 : 0;\n\n";
+					}
+					else
+					{
+						str += "\tuint rw = 1;\n\n";
+					}
+				}
+
+				// Transform index for 3-step twiddles
+				if(params.fft_3StepTwiddle && !blockCompute)
+				{
+					if(numTrans == 1)
+					{
+						str += "\tuint b = batch%";
+					}
+					else
+					{
+						str += "\tuint b = (batch*"; str += SztToStr(numTrans); str += " + (me/";
+						str += SztToStr(workGroupSizePerTrans); str += "))%";
+					}
+
+					str += SztToStr(params.fft_N[1]); str += ";\n\n";
+
+					if(params.fft_realSpecial)
+					{
+						str += "\tuint bt = b;\n\n";
+					}
+				}
+				else
+				{
+					str += "\tuint b = 0;\n\n";
+				}
+
+				// Setup memory pointers
+				if(r2c2r)
+				{
+					str += OffsetCalc("iOffset", true);
+					str += OffsetCalc("oOffset", false);
+					if(!rcSimple) { str += OffsetCalc("iOffset2",  true, true); }
+					if(!rcSimple) { str += OffsetCalc("oOffset2", false, true); }
+
+					str += "\n\t";
+					if(params.fft_placeness == CLFFT_INPLACE)
+					{
+						if(!params.fft_hasPreCallback)
+						{
+							if(inInterleaved)
+							{
+								if(!rcSimple) {	str += "lwbIn2 = (__global "; str += r2Type; str += " *)gb + iOffset2;\n\t"; }
+												str += "lwbIn  = (__global "; str += r2Type; str += " *)gb + iOffset;\n\t"; 
+							}
+							else
+							{
+								if(!rcSimple) {	str += "lwbIn2 = (__global "; str += rType; str += " *)gb + iOffset2;\n\t"; }
+												str += "lwbIn  = (__global "; str += rType; str += " *)gb + iOffset;\n\t";
+
+							}
+						}
+
+						if(!params.fft_hasPostCallback)
+						{
+						if(!rcSimple) {	str += "lwbOut2 = gb + oOffset2;\n\t"; }
+											str += "lwbOut = gb + oOffset;\n";
+						}
+						str += "\n";
+					}
+					else
+					{
+						if (!params.fft_hasPreCallback)
+						{
+							if(inInterleaved || inReal)
+							{
+								if(!rcSimple) {	str += "lwbIn2 = gbIn + iOffset2;\n\t"; }
+								str += "lwbIn = gbIn + iOffset;\n\t"; 
+							}
+							else
+							{
+								if(!rcSimple) {	str += "lwbInRe2 = gbInRe + iOffset2;\n\t"; }
+								if(!rcSimple) {	str += "lwbInIm2 = gbInIm + iOffset2;\n\t"; }
+												str += "lwbInRe = gbInRe + iOffset;\n\t";
+												str += "lwbInIm = gbInIm + iOffset;\n\t";
+							}
+						}
+
+						if (!params.fft_hasPostCallback)
+						{
+						if(outInterleaved || outReal)
+						{
+							if(!rcSimple) {	str += "lwbOut2 = gbOut + oOffset2;\n\t"; }
+												str += "lwbOut = gbOut + oOffset;\n";
+						}
+						else
+						{
+								
+							if(!rcSimple) {	str += "lwbOutRe2 = gbOutRe + oOffset2;\n\t"; }
+							if(!rcSimple) {	str += "lwbOutIm2 = gbOutIm + oOffset2;\n\t"; }
+											str += "lwbOutRe = gbOutRe + oOffset;\n\t";
+												str += "lwbOutIm = gbOutIm + oOffset;\n";
+						}
+					}
+						str += "\n";
+					}
+				}
+				else
+				{
+					if(params.fft_placeness == CLFFT_INPLACE)
+					{
+						if(blockCompute)
+							str += OffsetCalcBlock("ioOffset", true);
+						else
+							str += OffsetCalc("ioOffset", true);
+
+						str += "\t";
+
+						//Skip if callback is set 
+						if (!params.fft_hasPreCallback || !params.fft_hasPostCallback)
+						{
+							if(inInterleaved)
+							{
+								str += "lwb = gb + ioOffset;\n";
+							}
+							else
+							{
+								str += "lwbRe = gbRe + ioOffset;\n\t";
+								str += "lwbIm = gbIm + ioOffset;\n";
+							}
+						}
+						str += "\n";
+					}
+					else
+					{
+						if(blockCompute)
+						{
+							str += OffsetCalcBlock("iOffset", true);
+							str += OffsetCalcBlock("oOffset", false);
+						}
+						else
+						{
+							str += OffsetCalc("iOffset", true);
+							str += OffsetCalc("oOffset", false);
+						}
+
+						str += "\t";
+
+						//Skip if precallback is set 
+						if (!(params.fft_hasPreCallback))
+						{
+							if(inInterleaved)
+							{
+								str += "lwbIn = gbIn + iOffset;\n\t";
+							}
+							else
+							{
+								str += "lwbInRe = gbInRe + iOffset;\n\t";
+								str += "lwbInIm = gbInIm + iOffset;\n\t";
+							}
+						}
+
+						//Skip if postcallback is set 
+						if (!params.fft_hasPostCallback)
+						{
+						if(outInterleaved)
+						{
+								str += "lwbOut = gbOut + oOffset;\n";
+						}
+						else
+						{
+							str += "lwbOutRe = gbOutRe + oOffset;\n\t";
+								str += "lwbOutIm = gbOutIm + oOffset;\n";
+							}
+						}
+						str += "\n";
+					}
+				}
+
+				std::string inOffset;
+				std::string outOffset;
+				if (params.fft_placeness == CLFFT_INPLACE && !r2c2r)
+				{
+					inOffset += "ioOffset";
+					outOffset += "ioOffset";
+				}
+				else
+				{
+					inOffset += "iOffset";
+					outOffset += "oOffset";
+				}
+				
+				// Read data into LDS for blocked access
+				if(blockCompute)
+				{
+
+					size_t loopCount = (length * blockWidth)/blockWGS;
+					
+					if ((blockComputeType == BCT_C2C) && params.fft_hasPreCallback)
+					{
+						str += "\n\t"; str += r2Type; str += " retCallback;";
+					}
+
+					str += "\n\tfor(uint t=0; t<"; str += SztToStr(loopCount);
+					str += "; t++)\n\t{\n";
+
+					//get offset 
+					std::string bufOffset;
+
+					for(size_t c=0; c<2; c++)
+					{
+						std::string comp = "";
+						std::string readBuf = (params.fft_placeness == CLFFT_INPLACE) ? "lwb" : "lwbIn";
+						if(!inInterleaved) comp = c ? ".y" : ".x";
+						if(!inInterleaved)
+							readBuf = (params.fft_placeness == CLFFT_INPLACE) ? (c ? "lwbIm" : "lwbRe") : (c ? "lwbInIm" : "lwbInRe");
+
+						if( (blockComputeType == BCT_C2C) || (blockComputeType == BCT_C2R) )
+						{
+							bufOffset.clear();
+							bufOffset += "(me%"; bufOffset += SztToStr(blockWidth); bufOffset += ") + ";
+							bufOffset += "(me/"; bufOffset+= SztToStr(blockWidth); bufOffset+= ")*"; bufOffset += SztToStr(params.fft_inStride[0]);
+							bufOffset += " + t*"; bufOffset += SztToStr(params.fft_inStride[0]*blockWGS/blockWidth);
+
+							if ((blockComputeType == BCT_C2C) && params.fft_hasPreCallback)
+							{
+								if (c == 0)
+								{
+									str += "\t\tretCallback = "; str += params.fft_preCallback.funcname; str += "(";
+								
+									if(inInterleaved)
+									{
+										str += (params.fft_placeness == CLFFT_INPLACE) ? "gb, " : "gbIn, ";
+									}
+									else
+									{
+										str += (params.fft_placeness == CLFFT_INPLACE) ? "gbRe, gbIm, " : "gbInRe, gbInIm, ";
+									}
+
+									str += inOffset; str += " + "; str += bufOffset; str += ", pre_userdata";
+									str += (params.fft_preCallback.localMemSize > 0) ? str += ", localmem);\n" : ");\n";
+								}
+
+								str += "\t\tR0"; str+= comp; str+= " = retCallback"; str+= comp; str += ";\n";
+							}
+							else
+							{
+								str += "\t\tR0"; str+= comp; str+= " = "; 
+								str += readBuf; str += "[";	str += bufOffset; str += "];\n";
+							}
+						}
+						else
+						{
+							str += "\t\tR0"; str+= comp; str+= " = "; str += readBuf; str += "[me + t*"; str += SztToStr(blockWGS); str += "];\n";
+						}
+
+
+						if(inInterleaved) break;
+					}
+
+					if( (blockComputeType == BCT_C2C) || (blockComputeType == BCT_C2R) )
+					{
+						str += "\t\tlds[t*"; str += SztToStr(blockWGS/blockWidth); str += " + ";
+						str += "(me%"; str+= SztToStr(blockWidth); str+= ")*"; str += SztToStr(length); str += " + ";
+						str += "(me/"; str+= SztToStr(blockWidth); str+= ")] = R0;"; str +="\n";
+					}
+					else
+					{
+						str += "\t\tlds[t*"; str += SztToStr(blockWGS); str += " + me] = R0;"; str +="\n";
+					}
+
+					str += "\t}\n\n";		
+					str += "\tbarrier(CLK_LOCAL_MEM_FENCE);\n\n";
+				}
+
+
+				// Set rw and 'me' per transform
+				// rw string also contains 'b'
+				std::string rw, me;
+
+				if(r2c2r && !rcSimple)	rw = "rw, b, ";
+				else					rw = ((numTrans > 1) || realSpecial) ? "rw, b, " : "1, b, ";
+
+				if(numTrans > 1)	{ me += "me%"; me += SztToStr(workGroupSizePerTrans); me += ", "; }
+				else				{ me += "me, "; }
+
+				if(blockCompute) { me = "me%"; me += SztToStr(workGroupSizePerTrans); me += ", "; }
+
+				// Buffer strings
+				std::string inBuf, outBuf;
+				if(r2c2r)
+				{
+					if(rcSimple)
+					{
+						if(inInterleaved || inReal)		inBuf  = params.fft_hasPreCallback ?  "gbIn, " : "lwbIn, ";
+						else							inBuf  = "lwbInRe, lwbInIm, ";
+						if(outInterleaved || outReal)	outBuf = params.fft_hasPostCallback ? "gbOut" : "lwbOut";
+						else							outBuf = "lwbOutRe, lwbOutIm";
+					}
+					else
+					{
+						if(inInterleaved || inReal)		
+						{
+							if (!params.fft_hasPreCallback)
+							{
+								inBuf  = "lwbIn, lwbIn2, ";
+							}
+							else
+							{
+								if (params.fft_placeness == CLFFT_INPLACE) 
+								{
+									inBuf = "(__global "; inBuf += r2c ? rType : r2Type; inBuf += "*) gb, ";
+									inBuf += "(__global "; inBuf += r2c ? rType : r2Type; inBuf += "*) gb, ";
+								}
+								else
+								{
+									inBuf  = "gbIn, gbIn, " ;
+								}
+							}	
+						}
+						else							inBuf  = (params.fft_hasPreCallback) ? "gbInRe, gbInRe, gbInIm, gbInIm, " : "lwbInRe, lwbInRe2, lwbInIm, lwbInIm2, ";
+
+						if(outInterleaved || outReal)	outBuf = params.fft_hasPostCallback ? ((params.fft_placeness == CLFFT_INPLACE) ? "gb, gb" : "gbOut, gbOut") : "lwbOut, lwbOut2";
+						else							outBuf = params.fft_hasPostCallback ? "gbOutRe, gbOutRe, gbOutIm, gbOutIm" : "lwbOutRe, lwbOutRe2, lwbOutIm, lwbOutIm2";
+					}
+				}
+				else
+				{
+					if(params.fft_placeness == CLFFT_INPLACE)
+					{
+						if(inInterleaved)	
+						{
+							inBuf = params.fft_hasPreCallback ? "gb, " : "lwb, ";
+							outBuf = params.fft_hasPostCallback ? "gb" : "lwb"; 
+						}
+						else	
+						{ 
+							inBuf = params.fft_hasPreCallback ? "gbRe, gbIm, " : "lwbRe, lwbIm, ";
+							outBuf = params.fft_hasPostCallback ? "gbRe, gbIm" : "lwbRe, lwbIm"; 
+						}
+					}
+					else
+					{
+						if(inInterleaved)	inBuf  = params.fft_hasPreCallback ? "gbIn, " : "lwbIn, ";
+						else				inBuf  = params.fft_hasPreCallback ? "gbInRe, gbInIm, " : "lwbInRe, lwbInIm, ";
+						if(outInterleaved)	outBuf = params.fft_hasPostCallback ? "gbOut" : "lwbOut";
+						else				outBuf = params.fft_hasPostCallback ? "gbOutRe, gbOutIm" : "lwbOutRe, lwbOutIm";
+					}
+				}
+
+
+				if(blockCompute)
+				{
+					str += "\n\tfor(uint t=0; t<"; str += SztToStr(blockWidth/(blockWGS/workGroupSizePerTrans));
+					str += "; t++)\n\t{\n\n";
+
+					inBuf = "lds, ";
+					outBuf = "lds";
+
+					if(params.fft_3StepTwiddle)
+					{
+						str += "\t\tb = (batch%"; str += SztToStr(params.fft_N[1]/blockWidth); str += ")*";
+						str += SztToStr(blockWidth); str += " + t*"; str += SztToStr(blockWGS/workGroupSizePerTrans);
+						str += " + (me/"; str += SztToStr(workGroupSizePerTrans); str += ");\n\n";
+					}
+				}
+
+				if(realSpecial)
+				{
+					str += "\n\tfor(uint t=0; t<2; t++)\n\t{\n\n";
+				}
+
+				// Call passes
+				if(numPasses == 1)
+				{
+					str += "\t";
+					str += PassName(0, fwd);
+					str += "("; str += rw; str += me;
+					
+					str += (params.fft_hasPreCallback) ? inOffset : "0";
+					
+					if (params.fft_hasPostCallback)
+					{
+						str += ", "; str += outOffset; str += ", ";
+					}
+					else
+					{
+					str += ", 0, ";
+					}
+
+					str += inBuf; str += outBuf;
+					str += IterRegs("&");
+
+					//If callback is set
+					if (hasCallback)
+					{
+						//if pre-calback set 
+					if (params.fft_hasPreCallback)
+					{
+							str += (r2c2r && !rcSimple) ?  ", iOffset2, pre_userdata" : ", pre_userdata";
+						}
+
+						//if post-calback set 
+						if (params.fft_hasPostCallback)
+						{
+							if ((r2c || c2r) && !rcSimple) { str += ", "; str += outOffset; str += "2"; }
+
+							str += ", post_userdata";
+						}
+
+						if (params.fft_preCallback.localMemSize > 0)
+						{
+							str += ", localmem";
+						}
+						if (params.fft_postCallback.localMemSize > 0)
+						{
+							//if precallback localmem also requested, send the localmem with the right offset
+							if (params.fft_hasPreCallback && params.fft_preCallback.localMemSize > 0)
+							{
+								str += ", ((__local char *)localmem + "; str += SztToStr(params.fft_preCallback.localMemSize); str += ")";
+							}
+							else
+							{
+								str += ", localmem";
+							}
+						}
+					}
+
+					str += ");\n";
+				}
+				else
+				{
+					for(typename std::vector<Pass<PR> >::const_iterator p = passes.begin(); p != passes.end(); p++)
+					{
+						std::string exTab = "";
+						if(blockCompute || realSpecial) exTab = "\t";
+
+						str += exTab;
+						str += "\t";
+						str += PassName(p->GetPosition(), fwd);
+						str += "(";
+
+						std::string ldsOff;
+						if(blockCompute)
+						{
+							ldsOff += "t*"; ldsOff += SztToStr(length*(blockWGS/workGroupSizePerTrans)); ldsOff += " + (me/";
+							ldsOff += SztToStr(workGroupSizePerTrans); ldsOff += ")*"; ldsOff += SztToStr(length);
+						}
+						else
+						{
+							if(numTrans > 1)
+							{
+								ldsOff += "(me/"; ldsOff += SztToStr(workGroupSizePerTrans);
+								ldsOff += ")*"; ldsOff += SztToStr(length);
+							}
+							else
+							{
+								ldsOff += "0";
+							}
+						}
+
+						std::string ldsArgs;
+						if(halfLds) { ldsArgs += "lds, lds"; }
+						else		{	if(ldsInterleaved) { ldsArgs += "lds"; }
+										else { ldsArgs += "lds, lds + "; ldsArgs += SztToStr(length*numTrans); } }
+
+						str += rw;
+						if(params.fft_realSpecial) str += "t, ";
+						str += me;
+						if(p == passes.begin()) // beginning pass
+						{
+							if (blockCompute)
+							{
+								str += ldsOff;
+							}
+							else
+							{
+								str += (params.fft_hasPreCallback) ? inOffset : "0";
+							}
+							str += ", ";
+							str += ldsOff;
+							str += ", ";
+							str += inBuf;
+							str += ldsArgs; str += IterRegs("&"); 
+							
+							//if precalback set, append additional arguments
+							if (!blockCompute && params.fft_hasPreCallback)
+							{
+								str += (r2c2r && !rcSimple) ?  ", iOffset2, pre_userdata" : ", pre_userdata";
+
+								if (params.fft_preCallback.localMemSize > 0)
+								{
+									str += ", localmem";
+								}
+							}
+
+							str += ");\n";
+							if(!halfLds) { str += exTab; str += "\tbarrier(CLK_LOCAL_MEM_FENCE);\n"; }
+						}
+						else if((p+1) == passes.end()) // ending pass
+						{
+							str += ldsOff;
+							str += ", ";
+							if (blockCompute)
+							{
+								str += ldsOff;
+							}
+							else
+							{
+								str += (params.fft_hasPostCallback) ? outOffset : "0";
+							}
+							str += ", ";
+							str += ldsArgs; str += ", ";
+							str += outBuf;
+
+							str += IterRegs("&"); 
+							
+							if (!blockCompute && params.fft_hasPostCallback)
+							{
+								if ((c2r || r2c) && !rcSimple) { str += ", "; str += outOffset; str += "2"; }
+
+								str += ", post_userdata";
+
+								if (params.fft_postCallback.localMemSize > 0)
+								{
+									//if precallback localmem also requested, send the localmem with the right offset
+									if (params.fft_hasPreCallback && params.fft_preCallback.localMemSize > 0)
+									{
+										str += ", ((__local char *)localmem + "; str += SztToStr(params.fft_preCallback.localMemSize); str += ")";
+									}
+									else
+									{
+										str += ", localmem";
+									}
+								}
+							}
+							str += ");\n";
+							
+							if (!halfLds) { str += exTab; str += "\tbarrier(CLK_LOCAL_MEM_FENCE);\n"; }
+						}
+						else // intermediate pass
+						{
+							str += ldsOff;
+							str += ", ";
+							str += ldsOff;
+							str += ", ";
+							str += ldsArgs; str += ", ";
+							str += ldsArgs; str += IterRegs("&"); str += ");\n";
+							if(!halfLds) { str += exTab; str += "\tbarrier(CLK_LOCAL_MEM_FENCE);\n"; }
+						}
+					}
+				}
+
+				if(realSpecial)
+				{
+					size_t Nt = 1 + length/2;
+					str += 	"\n\t\tif( (bt == 0) || (2*bt == ";
+					str += SztToStr(params.fft_realSpecial_Nr); str += ") ) { rw = 0; }\n";
+
+					str += "\t\tlwbOut += ("; str += SztToStr(params.fft_realSpecial_Nr);
+					str += " - 2*bt)*"; str += SztToStr(Nt); str += ";\n";
+					str += "\t\tb = "; str += SztToStr(params.fft_realSpecial_Nr);
+					str += " - b;\n\n";
+				}
+
+				if(blockCompute || realSpecial)
+				{
+					str += "\n\t}\n\n";
+				}
+
+
+
+				// Write data from LDS for blocked access
+				if(blockCompute)
+				{
+
+					size_t loopCount = (length * blockWidth)/blockWGS;
+					
+					str += "\tbarrier(CLK_LOCAL_MEM_FENCE);\n\n";
+					str += "\n\tfor(uint t=0; t<"; str += SztToStr(loopCount);
+					str += "; t++)\n\t{\n";
+
+					if( (blockComputeType == BCT_C2C) || (blockComputeType == BCT_R2C) )
+					{
+						str += "\t\tR0 = lds[t*"; str += SztToStr(blockWGS/blockWidth); str += " + ";
+						str += "(me%"; str+= SztToStr(blockWidth); str+= ")*"; str += SztToStr(length); str += " + ";
+						str += "(me/"; str+= SztToStr(blockWidth); str+= ")];"; str +="\n";
+					}
+					else
+					{
+						str += "\t\tR0 = lds[t*"; str += SztToStr(blockWGS); str += " + me];"; str +="\n";
+					}
+
+					for(size_t c=0; c<2; c++)
+					{
+						std::string comp = "";
+						std::string writeBuf = (params.fft_placeness == CLFFT_INPLACE) ? "lwb" : "lwbOut";
+						if(!outInterleaved) comp = c ? ".y" : ".x";
+						if(!outInterleaved)
+							writeBuf = (params.fft_placeness == CLFFT_INPLACE) ? (c ? "lwbIm" : "lwbRe") : (c ? "lwbOutIm" : "lwbOutRe");
+
+						if( (blockComputeType == BCT_C2C) || (blockComputeType == BCT_R2C) )
+						{
+							if (blockComputeType == BCT_R2C && params.fft_hasPostCallback)
+							{
+								if (outInterleaved)
+									writeBuf = (params.fft_placeness == CLFFT_INPLACE) ? "gb" : "gbOut";
+								else
+									writeBuf = (params.fft_placeness == CLFFT_INPLACE) ? "gbRe, gbIm" : "gbOutRe, gbOutIm";
+								
+								str += "\t\t"; str += params.fft_postCallback.funcname; str += "("; str += writeBuf; str += ", (";
+								str += outOffset; str += " + (me%"; str+= SztToStr(blockWidth); str += ") + ";
+								str += "(me/"; str+= SztToStr(blockWidth); str+= ")*"; str += SztToStr(params.fft_outStride[0]);
+								str += " + t*"; str += SztToStr(params.fft_outStride[0]*blockWGS/blockWidth); 
+								str += "), post_userdata, R0"; 
+								if (!outInterleaved) str += ".x, R0.y";
+
+								if (params.fft_postCallback.localMemSize > 0)
+								{
+									if (params.fft_hasPreCallback && params.fft_preCallback.localMemSize > 0)
+									{
+										str += ", (char *)(localmem + "; str += SztToStr(params.fft_preCallback.localMemSize); str += ")";
+									}
+									else
+									{
+										str += ", localmem";
+									}
+								}
+								str += ");\n";
+
+								//in the planar case, break from for loop since both real and imag components are handled
+								//together in post-callback
+								if (!outInterleaved) break;
+							}
+							else
+							{
+							str += "\t\t"; str += writeBuf; str += "[(me%"; str+= SztToStr(blockWidth); str += ") + ";
+							str += "(me/"; str+= SztToStr(blockWidth); str+= ")*"; str += SztToStr(params.fft_outStride[0]);
+							str += " + t*"; str += SztToStr(params.fft_outStride[0]*blockWGS/blockWidth); str += "] = R0"; str+= comp; str += ";\n";
+						}
+						}
+						else
+						{
+							str += "\t\t"; str += writeBuf; str += "[me + t*"; str += SztToStr(blockWGS); str += "] = R0"; str+= comp; str += ";\n";
+						}
+
+						if(outInterleaved) break;
+					}
+					
+					str += "\t}\n\n";		
+				}
+				
+
+
+				str += "}\n\n";
+
+				if(r2c2r)
+					break;
+			}
+		}
+    };
+};
+
+using namespace StockhamGenerator;
+
+clfftStatus FFTGeneratedStockhamAction::initParams ()
+{
+
+    //    Query the devices in this context for their local memory sizes
+    //    How we generate a kernel depends on the *minimum* LDS size for all devices.
+    //
+    const FFTEnvelope * pEnvelope = NULL;
+    OPENCL_V(this->plan->GetEnvelope (& pEnvelope), _T("GetEnvelope failed"));
+    BUG_CHECK (NULL != pEnvelope);
+
+    // Remainder: params was properly cleared by its constructor
+    //            clearing it again would destroy datasize and id!!
+    this->signature.fft_precision    = this->plan->precision;
+    this->signature.fft_placeness    = this->plan->placeness;
+    this->signature.fft_inputLayout  = this->plan->inputLayout;
+	this->signature.fft_MaxWorkGroupSize = this->plan->envelope.limit_WorkGroupSize;
+
+    ARG_CHECK(this->plan->length.size()    > 0);
+	ARG_CHECK(this->plan->inStride.size()  > 0);
+    ARG_CHECK(this->plan->outStride.size() > 0);
+
+    ARG_CHECK (this->plan->inStride.size() == this->plan->outStride.size())
+
+	bool real_transform = ((this->plan->inputLayout == CLFFT_REAL) || (this->plan->outputLayout == CLFFT_REAL));
+
+    if ( (CLFFT_INPLACE == this->plan->placeness) && (!real_transform) ) {
+        //    If this is an in-place transform the
+        //    input and output layout, dimensions and strides
+        //    *MUST* be the same.
+        //
+        ARG_CHECK (this->plan->inputLayout == this->plan->outputLayout)
+        this->signature.fft_outputLayout = this->plan->inputLayout;
+        for (size_t u = this->plan->inStride.size(); u-- > 0; ) {
+            ARG_CHECK (this->plan->inStride[u] == this->plan->outStride[u]);
+        }
+    } else {
+        this->signature.fft_outputLayout = this->plan->outputLayout;
+    }
+
+	this->signature.fft_DataDim = this->plan->length.size() + 1;
+	int i = 0;
+	for(i = 0; i < (this->signature.fft_DataDim - 1); i++)
+	{
+        this->signature.fft_N[i]         = this->plan->length[i];
+        this->signature.fft_inStride[i]  = this->plan->inStride[i];
+        this->signature.fft_outStride[i] = this->plan->outStride[i];
+
+	}
+    this->signature.fft_inStride[i]  = this->plan->iDist;
+    this->signature.fft_outStride[i] = this->plan->oDist;
+
+
+	this->signature.fft_RCsimple = this->plan->RCsimple;
+
+	this->signature.fft_realSpecial = this->plan->realSpecial;
+	this->signature.fft_realSpecial_Nr = this->plan->realSpecial_Nr;
+
+	this->signature.blockCompute = this->plan->blockCompute;
+	this->signature.blockComputeType = this->plan->blockComputeType;
+
+	this->signature.fft_twiddleFront = this->plan->twiddleFront;
+
+	size_t wgs, nt;
+#ifdef PARMETERS_TO_BE_READ
+	ParamRead pr;
+	ReadParameterFile(pr);
+	wgs = pr.workGroupSize;
+	nt = pr.numTransformsPerWg;
+#else
+	size_t t_wgs, t_nt;
+	Precision pr = (this->signature.fft_precision == CLFFT_SINGLE) ? P_SINGLE : P_DOUBLE;
+	switch(pr)
+	{
+	case P_SINGLE:
+		{
+			KernelCoreSpecs<P_SINGLE> kcs;
+			kcs.GetWGSAndNT(this->signature.fft_N[0], t_wgs, t_nt);
+			if(this->signature.blockCompute)
+			{
+				this->signature.blockSIMD = Kernel<P_SINGLE>::BlockSizes::BlockWorkGroupSize(this->signature.fft_N[0]);
+				this->signature.blockLDS  = Kernel<P_SINGLE>::BlockSizes::BlockLdsSize(this->signature.fft_N[0]);
+			}
+		} break;
+	case P_DOUBLE:
+		{
+			KernelCoreSpecs<P_DOUBLE> kcs;
+			kcs.GetWGSAndNT(this->signature.fft_N[0], t_wgs, t_nt);
+			if(this->signature.blockCompute)
+			{
+				this->signature.blockSIMD = Kernel<P_DOUBLE>::BlockSizes::BlockWorkGroupSize(this->signature.fft_N[0]);
+				this->signature.blockLDS  = Kernel<P_DOUBLE>::BlockSizes::BlockLdsSize(this->signature.fft_N[0]);
+			}
+		} break;
+	}
+
+	if((t_wgs != 0) && (t_nt != 0) && (this->plan->envelope.limit_WorkGroupSize >= 256))
+	{
+		wgs = t_wgs;
+		nt = t_nt;
+	}
+	else
+		DetermineSizes(this->plan->envelope.limit_WorkGroupSize, this->signature.fft_N[0], wgs, nt, pr);
+#endif
+
+	assert((nt * this->signature.fft_N[0]) >= wgs);
+	assert((nt * this->signature.fft_N[0])%wgs == 0);
+
+	this->signature.fft_R = (nt * this->signature.fft_N[0])/wgs;
+	this->signature.fft_SIMD = wgs;
+
+	//Set pre-callback if specified
+	if (this->plan->hasPreCallback)
+	{
+		this->signature.fft_hasPreCallback = true;
+		this->signature.fft_preCallback = this->plan->preCallback;
+	}
+
+	//Set post-callback if specified
+	if (this->plan->hasPostCallback)
+	{
+		this->signature.fft_hasPostCallback = true;
+		this->signature.fft_postCallback = this->plan->postCallbackParam;
+	}
+	this->signature.limit_LocalMemSize = this->plan->envelope.limit_LocalMemSize;
+
+    if (this->plan->large1D != 0) {
+        ARG_CHECK (this->signature.fft_N[0] != 0)
+        ARG_CHECK ((this->plan->large1D % this->signature.fft_N[0]) == 0)
+        this->signature.fft_3StepTwiddle = true;
+		if(!(this->plan->realSpecial))
+			ARG_CHECK ( this->plan->large1D  == (this->signature.fft_N[1] * this->signature.fft_N[0]) );
+    }
+
+    this->signature.fft_fwdScale  = this->plan->forwardScale;
+    this->signature.fft_backScale = this->plan->backwardScale;
+
+    return CLFFT_SUCCESS;
+}
+
+clfftStatus FFTGeneratedStockhamAction::getWorkSizes (std::vector<size_t> & globalWS, std::vector<size_t> & localWS)
+{
+    //    How many complex numbers in the input mutl-dimensional array?
+    //
+    unsigned long long count = 1;
+    for (unsigned u = 0; u < this->plan->length.size(); ++u) {
+        count *= std::max<size_t> (1, this->plan->length[ u ]);
+    }
+    count *= this->plan->batchsize;
+
+
+	if(this->signature.blockCompute)
+	{
+		count = DivRoundingUp<unsigned long long> (count, this->signature.blockLDS); 
+		count = count * this->signature.blockSIMD; 
+
+		globalWS.push_back( static_cast< size_t >( count ) );
+		localWS.push_back( this->signature.blockSIMD );
+
+		return    CLFFT_SUCCESS;
+	}
+
+    count = DivRoundingUp<unsigned long long> (count, this->signature.fft_R);      // count of WorkItems
+    count = DivRoundingUp<unsigned long long> (count, this->signature.fft_SIMD);   // count of WorkGroups
+
+	// for real transforms we only need half the work groups since we do twice the work in 1 work group
+	if( !(this->signature.fft_RCsimple) && ((this->signature.fft_inputLayout == CLFFT_REAL) || (this->signature.fft_outputLayout == CLFFT_REAL)) )
+		count = DivRoundingUp<unsigned long long> (count, 2);
+
+    count = std::max<unsigned long long> (count, 1) * this->signature.fft_SIMD;
+        // .. count of WorkItems, rounded up to next multiple of fft_SIMD.
+
+	// 1 dimension work group size
+	globalWS.push_back( static_cast< size_t >( count ) );
+
+    localWS.push_back( this->signature.fft_SIMD );
+
+    return    CLFFT_SUCCESS;
+}
+
+clfftStatus FFTPlan::GetMax1DLengthStockham (size_t * longest) const
+{
+	// TODO  The caller has already acquired the lock on *this
+	//	However, we shouldn't depend on it.
+
+	//	Query the devices in this context for their local memory sizes
+	//	How large a kernel we can generate depends on the *minimum* LDS
+	//	size for all devices.
+	//
+	const FFTEnvelope * pEnvelope = NULL;
+	OPENCL_V(this->GetEnvelope (& pEnvelope), _T("GetEnvelope failed"));
+	BUG_CHECK (NULL != pEnvelope);
+
+	ARG_CHECK (NULL != longest)
+	size_t LdsperElement = this->ElementSize();
+	size_t result = pEnvelope->limit_LocalMemSize /
+		(1 * LdsperElement);
+	result = FloorPo2 (result);
+	*longest = result;
+	return CLFFT_SUCCESS;
+}
+
+clfftStatus FFTGeneratedStockhamAction::generateKernel(FFTRepo& fftRepo, const cl_command_queue commQueueFFT )
+{
+    cl_int status = CL_SUCCESS;
+    cl_device_id Device = NULL;
+    status = clGetCommandQueueInfo(commQueueFFT, CL_QUEUE_DEVICE, sizeof(cl_device_id), &Device, NULL);
+    OPENCL_V( status, _T( "clGetCommandQueueInfo failed" ) );
+
+    cl_context QueueContext = NULL;
+    status = clGetCommandQueueInfo(commQueueFFT, CL_QUEUE_CONTEXT, sizeof(cl_context), &QueueContext, NULL);
+    OPENCL_V( status, _T( "clGetCommandQueueInfo failed" ) );
+
+	std::string programCode;
+	Precision pr = (this->signature.fft_precision == CLFFT_SINGLE) ? P_SINGLE : P_DOUBLE;
+	switch(pr)
+	{
+	case P_SINGLE:
+		{
+			Kernel<P_SINGLE> kernel(this->signature);
+			kernel.GenerateKernel(programCode, Device);
+		} break;
+	case P_DOUBLE:
+		{
+			Kernel<P_DOUBLE> kernel(this->signature);
+			kernel.GenerateKernel(programCode, Device);
+		} break;
+	}
+
+	//Requested local memory size by callback must not exceed the device LDS limits after factoring the LDS size required by main FFT kernel
+	if ((this->signature.fft_hasPreCallback && this->signature.fft_preCallback.localMemSize > 0) || 
+		(this->signature.fft_hasPostCallback && this->signature.fft_postCallback.localMemSize > 0))
+	{
+		bool validLDSSize = false;
+		size_t requestedCallbackLDS = 0;
+
+		if (this->signature.fft_hasPreCallback && this->signature.fft_preCallback.localMemSize > 0)
+			requestedCallbackLDS = this->signature.fft_preCallback.localMemSize;
+		if (this->signature.fft_hasPostCallback && this->signature.fft_postCallback.localMemSize > 0)
+			requestedCallbackLDS += this->signature.fft_postCallback.localMemSize;
+
+		if (this->plan->blockCompute)
+		{
+			validLDSSize = ((this->signature.blockLDS * this->plan->ElementSize()) +  requestedCallbackLDS) < this->plan->envelope.limit_LocalMemSize;
+		}
+		else
+		{
+			size_t length = this->signature.fft_N[0];
+			size_t workGroupSize = this->signature.fft_SIMD;
+			size_t numTrans = (workGroupSize * this->signature.fft_R) / length;
+
+			//TODO - Need to abstract this out. Repeating the same compute as in GenerateKernel. 
+			// Set half lds only for power-of-2 problem sizes & interleaved data
+			bool halfLds = ( (this->signature.fft_inputLayout == CLFFT_COMPLEX_INTERLEAVED) &&
+						(this->signature.fft_outputLayout == CLFFT_COMPLEX_INTERLEAVED) ) ? true : false;
+			halfLds = halfLds ? ((length & (length-1)) ? false : true) : false;
+
+			// Set half lds for real transforms
+			halfLds = ( (this->signature.fft_inputLayout == CLFFT_REAL) &&
+						(this->signature.fft_outputLayout == CLFFT_REAL) ) ? true : halfLds;
+
+			size_t ldsSize = halfLds ? length*numTrans : 2*length*numTrans;
+			size_t elementSize = ((this->signature.fft_precision == CLFFT_DOUBLE) || (this->signature.fft_precision == CLFFT_DOUBLE_FAST)) ? sizeof(double) : sizeof(float);
+
+			validLDSSize = ((ldsSize * elementSize) + requestedCallbackLDS) < this->plan->envelope.limit_LocalMemSize;
+		}
+
+		if(!validLDSSize)
+		{
+			fprintf(stderr, "Requested local memory size not available\n");
+			return CLFFT_INVALID_ARG_VALUE;
+		}
+	}
+
+#ifdef KERNEL_INTERJECT
+	ReadKernelFromFile(programCode);
+#endif
+
+    OPENCL_V( fftRepo.setProgramCode( this->getGenerator(), this->getSignatureData(), programCode, Device, QueueContext ), _T( "fftRepo.setclString() failed!" ) );
+    OPENCL_V( fftRepo.setProgramEntryPoints( this->getGenerator(), this->getSignatureData(), "fft_fwd", "fft_back", Device, QueueContext ), _T( "fftRepo.setProgramEntryPoint() failed!" ) );
+
+    return CLFFT_SUCCESS;
+}
diff -Naru5 clFFT.old/src/library/generator.transpose.cpp clFFT/src/library/generator.transpose.cpp
--- clFFT.old/src/library/generator.transpose.cpp	2020-11-04 16:35:17.425724470 +0000
+++ clFFT/src/library/generator.transpose.cpp	2020-11-04 16:48:27.209671041 +0000
@@ -29,12 +29,13 @@
 void OffsetCalc(std::stringstream& transKernel, const FFTKernelGenKeyParams& params, bool input)
 {
 	const size_t *stride = input ? params.fft_inStride : params.fft_outStride;
 	std::string offset = input ? "iOffset" : "oOffset";
 
-
-	clKernWrite(transKernel, 3) << "size_t " << offset << " = 0;" << std::endl;
+	
+	std::string offsetInOut = input ? "offsetIn" : "offsetOut";
+	clKernWrite( transKernel, 3 ) << "size_t " << offset << " = " << offsetInOut << " ;" << std::endl;
 	clKernWrite(transKernel, 3) << "g_index = get_group_id(0);" << std::endl;
 
 	for (size_t i = params.fft_DataDim - 2; i > 0; i--)
 	{
 		clKernWrite(transKernel, 3) << offset << " += (g_index/numGroupsY_" << i << ")*" << stride[i + 1] << ";" << std::endl;
@@ -48,11 +49,12 @@
 void OffsetCalcLeadingDimensionBatched(std::stringstream& transKernel, const FFTKernelGenKeyParams& params)
 {
 	const size_t *stride = params.fft_inStride;
 	std::string offset = "iOffset";
 
-	clKernWrite(transKernel, 3) << "size_t " << offset << " = 0;" << std::endl;
+	
+	clKernWrite(transKernel, 3) << "size_t " << offset << " = offsetIn;" << std::endl;
 	clKernWrite(transKernel, 3) << "g_index = get_group_id(0);" << std::endl;
 
 	for (size_t i = params.fft_DataDim - 2; i > 0; i--)
 	{
 		clKernWrite(transKernel, 3) << offset << " += (g_index/numGroupsY_" << i << ")*" << stride[i + 1] << ";" << std::endl;
@@ -66,11 +68,12 @@
 void Swap_OffsetCalc(std::stringstream& transKernel, const FFTKernelGenKeyParams& params)
 {
 	const size_t *stride = params.fft_inStride;
 	std::string offset = "iOffset";
 
-	clKernWrite(transKernel, 3) << "size_t " << offset << " = 0;" << std::endl;
+	
+	clKernWrite(transKernel, 3) << "size_t " << offset << " = offsetOut;" << std::endl;
 
 	for (size_t i = params.fft_DataDim - 2; i > 0; i--)
 	{
 		clKernWrite(transKernel, 3) << offset << " += (g_index/numGroupsY_" << i << ")*" << stride[i + 1] << ";" << std::endl;
 		clKernWrite(transKernel, 3) << "g_index = g_index % numGroupsY_" << i << ";" << std::endl;
@@ -244,10 +247,13 @@
 		{
 			clKernWrite(transKernel, 0) << ", __global void* post_userdata";
 		}
 	}
 
+	
+	clKernWrite( transKernel, 0 ) << ", const int offsetIn, const int offsetOut ";
+
 	// Close the method signature
 	clKernWrite(transKernel, 0) << " )\n{" << std::endl;
 	return CLFFT_SUCCESS;
 }
 
@@ -314,10 +320,13 @@
 		}
 	}
 
 
 	// Close the method signature
+	
+	clKernWrite( transKernel, 0 ) << ", const int offsetIn, const int offsetOut ";
+
 	clKernWrite(transKernel, 0) << " )\n{" << std::endl;
 	return CLFFT_SUCCESS;
 }
 
 /* -> get_cycles function gets the swapping logic required for given row x col matrix.
diff -Naru5 clFFT.old/src/library/generator.transpose.gcn.cpp clFFT/src/library/generator.transpose.gcn.cpp
--- clFFT.old/src/library/generator.transpose.gcn.cpp	2020-11-04 16:35:17.425724470 +0000
+++ clFFT/src/library/generator.transpose.gcn.cpp	2020-11-04 16:48:27.213004431 +0000
@@ -123,12 +123,14 @@
 static void OffsetCalc(std::stringstream& transKernel, const FFTKernelGenKeyParams& params, bool input )
 {
 	const size_t *stride = input ? params.fft_inStride : params.fft_outStride;
 	std::string offset = input ? "iOffset" : "oOffset";
 
+	
+	std::string offsetInOut = input ? "offsetIn" : "offsetOut";
+	clKernWrite( transKernel, 3 ) << "size_t " << offset << " = " << offsetInOut << " ;" << std::endl;
 
-	clKernWrite( transKernel, 3 ) << "size_t " << offset << " = 0;" << std::endl;
 	clKernWrite( transKernel, 3 ) << "currDimIndex = groupIndex.y;" << std::endl;
 
 
 	for(size_t i = params.fft_DataDim - 2; i > 0 ; i--)
 	{
@@ -342,10 +344,14 @@
 			clKernWrite( transKernel, 0 ) << ", __global void* post_userdata";
 		}
 	}
 
     // Close the method signature
+
+	
+	clKernWrite( transKernel, 0 ) << ", const int offsetIn, const int offsetOut ";
+
     clKernWrite( transKernel, 0 ) << " )\n{" << std::endl;
 
     return CLFFT_SUCCESS;
 }
 
diff -Naru5 clFFT.old/src/library/plan.cpp clFFT/src/library/plan.cpp
--- clFFT.old/src/library/plan.cpp	2020-11-04 16:35:17.429057864 +0000
+++ clFFT/src/library/plan.cpp	2020-11-04 16:48:27.213004431 +0000
@@ -29,13 +29,13 @@
 #include "action.h"
 #include "fft_binary_lookup.h"
 
 using std::vector;
 
-const std::string beginning_of_binary( "<[_beginning_of_binary_]>" );
-const std::string end_of_binary( "<[_I_may_be_a_sorry_case,_but_I_don't_write_jokes_in_base_13_]>" );
-const std::string end_of_file( "<[_You're_off_the_edge_of_the_map,_mate._Here_there_be_monsters_]>" );
+const std::string beginning_of_binary( "<[_beginning_of_binary_]>" );
+const std::string end_of_binary( "<[_I_may_be_a_sorry_case,_but_I_don't_write_jokes_in_base_13_]>" );
+const std::string end_of_file( "<[_You're_off_the_edge_of_the_map,_mate._Here_there_be_monsters_]>" );
 
 static bool pow235(size_t num, size_t &pow2, size_t &pow3, size_t &pow5)
 {
 	//a helper function to decide if a number is only radix 2, 3 and 5
 	if (num % 2 != 0 && num % 3 != 0 && num % 5 != 0)
@@ -271,10 +271,12 @@
 	fftPlan->context		= context;
 	fftPlan->forwardScale	= 1.0;
 	fftPlan->backwardScale	= 1.0 / static_cast< double >( lenX * lenY * lenZ );
 	fftPlan->batchsize		= 1;
 	fftPlan->gen			= Stockham; //default setting
+	fftPlan->offsetIn		= 0;
+	fftPlan->offsetOut		= 0;
 
 	OPENCL_V(fftPlan->SetEnvelope(), _T("SetEnvelope failed"));
 
 	clRetainContext( fftPlan->context );
 
diff -Naru5 clFFT.old/src/library/plan.h clFFT/src/library/plan.h
--- clFFT.old/src/library/plan.h	2020-11-04 16:35:17.429057864 +0000
+++ clFFT/src/library/plan.h	2020-11-04 16:48:27.213004431 +0000
@@ -149,10 +149,13 @@
 	clfftLayout           fft_outputLayout;
 	clfftPrecision        fft_precision;
 	double                   fft_fwdScale;
 	double                   fft_backScale;
 
+	size_t				  fft_offsetIn;
+	size_t				  fft_offsetOut;
+
 	size_t                   fft_SIMD;          // Assume this SIMD/workgroup size
 	size_t                   fft_LDSsize;       // Limit the use of LDS to this many bytes.
 	size_t                   fft_R;             // # of complex values to keep in working registers
 	                                            // SIMD size * R must be <= size of LDS!
 
@@ -216,10 +219,13 @@
 		fft_R = 0;
 		fft_MaxWorkGroupSize = 0;
 		fft_3StepTwiddle = false;
 		fft_twiddleFront = false;
 
+		fft_offsetIn  = 0;
+		fft_offsetOut = 0;
+
 		transOutHorizontal = false;
 
 		fft_realSpecial = false;
 		fft_realSpecial_Nr = 0;
 
@@ -413,10 +419,13 @@
 	cl_context              context;
 	double                  forwardScale, backwardScale;
 	size_t                  iDist, oDist;
 	size_t                  batchsize;
 
+	size_t					offsetIn;
+	size_t					offsetOut;
+
 	// Note the device passed to BakePlan, assuming we are baking for one device
 	// TODO, change this logic for handling multiple GPUs/devices
 	cl_device_id bakeDevice;
 
 	// Disabling devices member, plan has 1-on-1 mapping with single device as identified by bakeDevice
@@ -573,14 +582,15 @@
 	,   transposeMiniBatchSize(1)
 	,   nonSquareKernelOrder(NOT_A_TRANSPOSE)
     ,   plHandle(0)
 	,   hasPreCallback(false)
 	,   hasPostCallback(false)
+	,	offsetIn(0)
+	,	offsetOut(0)
 	{
 	};
 
-
 	size_t ElementSize() const;
 
 	clfftStatus AllocateBuffers ();
 	clfftStatus ReleaseBuffers ();
 
